{
    "sourceFile": "lib/widgets/shared/helper/listenable_animated_widget/listenable_animated_widget.dart",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1698818471623,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1698819557518,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,77 @@\n+import \"package:flutter/foundation.dart\";\r\n+import \"package:flutter/material.dart\";\r\n+\r\n+/// An abstract class for building widgets that animate changes to their\r\n+/// properties. This includes additional properties that allows finer control\r\n+/// over the lifetime of the animation.\r\n+///\r\n+abstract class ListenableImplicitlyAnimatedWidget extends ImplicitlyAnimatedWidget {\r\n+  /// Initializes fields for subclasses.\r\n+  const ListenableImplicitlyAnimatedWidget({\r\n+    required super.duration,\r\n+    super.key,\r\n+    super.curve = Curves.linear,\r\n+    this.onForward,\r\n+    this.onReverse,\r\n+    this.onDismiss,\r\n+    super.onEnd,\r\n+  }) : super();\r\n+\r\n+  /// Called every time an animation starts.\r\n+  final VoidCallback? onForward;\r\n+\r\n+  /// Called every time an animation reverses.\r\n+  final VoidCallback? onReverse;\r\n+\r\n+  /// Called every time an animation dismisses.\r\n+  final VoidCallback? onDismiss;\r\n+\r\n+  @override\r\n+  ListenableImplicitlyAnimatedWidgetState<ListenableImplicitlyAnimatedWidget> createState();\r\n+\r\n+  @override\r\n+  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\r\n+    super.debugFillProperties(properties);\r\n+    properties.add(IntProperty(\"duration\", duration.inMilliseconds, unit: \"ms\"));\r\n+  }\r\n+}\r\n+\r\n+/// A base class for the `State` of widgets with implicit animations.\r\n+///\r\n+/// [ListenableImplicitlyAnimatedWidgetState] requires that subclasses respond to the\r\n+/// animation themselves. If you would like `setState()` to be called\r\n+/// automatically as the animation changes, use [ListenableAnimatedWidgetBaseState].\r\n+///\r\n+/// Properties that subclasses choose to animate are represented by [Tween]\r\n+/// instances. Subclasses must implement the [forEachTween] method to allow\r\n+/// [ListenableImplicitlyAnimatedWidgetState] to iterate through the widget's fields and\r\n+/// animate them.\r\n+abstract class ListenableImplicitlyAnimatedWidgetState<T extends ListenableImplicitlyAnimatedWidget>\r\n+    extends ImplicitlyAnimatedWidgetState<T> {\r\n+  @override\r\n+  void initState() {\r\n+    super.initState();\r\n+    super.controller.addStatusListener((status) {\r\n+      if (status case AnimationStatus.dismissed) {\r\n+        widget.onDismiss?.call();\r\n+      } else if (status case AnimationStatus.forward) {\r\n+        widget.onForward?.call();\r\n+      } else if (status case AnimationStatus.reverse) {\r\n+        widget.onReverse?.call();\r\n+      }\r\n+    });\r\n+  }\r\n+}\r\n+\r\n+abstract class ListenableAnimatedWidgetBaseState<T extends ListenableImplicitlyAnimatedWidget>\r\n+    extends ListenableImplicitlyAnimatedWidgetState<T> {\r\n+  @override\r\n+  void initState() {\r\n+    super.initState();\r\n+    controller.addListener(_handleAnimationChanged);\r\n+  }\r\n+\r\n+  void _handleAnimationChanged() {\r\n+    setState(() {/* The animation ticked. Rebuild with new animation value */});\r\n+  }\r\n+}\r\n"
                },
                {
                    "date": 1698819589960,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,9 +3,8 @@\n \r\n /// An abstract class for building widgets that animate changes to their\r\n /// properties. This includes additional properties that allows finer control\r\n /// over the lifetime of the animation.\r\n-///\r\n abstract class ListenableImplicitlyAnimatedWidget extends ImplicitlyAnimatedWidget {\r\n   /// Initializes fields for subclasses.\r\n   const ListenableImplicitlyAnimatedWidget({\r\n     required super.duration,\r\n@@ -14,9 +13,9 @@\n     this.onForward,\r\n     this.onReverse,\r\n     this.onDismiss,\r\n     super.onEnd,\r\n-  }) : super();\r\n+  });\r\n \r\n   /// Called every time an animation starts.\r\n   final VoidCallback? onForward;\r\n \r\n@@ -45,9 +44,9 @@\n /// Properties that subclasses choose to animate are represented by [Tween]\r\n /// instances. Subclasses must implement the [forEachTween] method to allow\r\n /// [ListenableImplicitlyAnimatedWidgetState] to iterate through the widget's fields and\r\n /// animate them.\r\n-abstract class ListenableImplicitlyAnimatedWidgetState<T extends ListenableImplicitlyAnimatedWidget>\r\n+abstract class ListenableImplicitlyAnimatedWidgetState<T extends I>\r\n     extends ImplicitlyAnimatedWidgetState<T> {\r\n   @override\r\n   void initState() {\r\n     super.initState();\r\n@@ -74,136 +73,4 @@\n   void _handleAnimationChanged() {\r\n     setState(() {/* The animation ticked. Rebuild with new animation value */});\r\n   }\r\n }\r\n-import \"package:flutter/foundation.dart\";\r\n-import \"package:flutter/material.dart\";\r\n-\r\n-/// An abstract class for building widgets that animate changes to their\r\n-/// properties. This includes additional properties that allows finer control\r\n-/// over the lifetime of the animation.\r\n-///\r\n-/// Widgets of this type will not animate when they are first added to the\r\n-/// widget tree. Rather, when they are rebuilt with different values, they will\r\n-/// respond to those _changes_ by animating the changes over a specified\r\n-/// [duration].\r\n-///\r\n-/// Which properties are animated is left up to the subclass. Subclasses' [State]s\r\n-/// must extend [ImplicitlyAnimatedWidgetState] and provide a way to visit the\r\n-/// relevant fields to animate.\r\n-///\r\n-/// ## Relationship to [AnimatedWidget]s\r\n-///\r\n-/// [ImplicitlyAnimatedWidget]s (and their subclasses) automatically animate\r\n-/// changes in their properties whenever they change. For this,\r\n-/// they create and manage their own internal [AnimationController]s to power\r\n-/// the animation. While these widgets are simple to use and don't require you\r\n-/// to manually manage the lifecycle of an [AnimationController], they\r\n-/// are also somewhat limited: Besides the target value for the animated\r\n-/// property, developers can only choose a [duration] and [curve] for the\r\n-/// animation. If you require more control over the animation (e.g. you want\r\n-/// to stop it somewhere in the middle), consider using an\r\n-/// [AnimatedWidget] or one of its subclasses. These widgets take an [Animation]\r\n-/// as an argument to power the animation. This gives the developer full control\r\n-/// over the animation at the cost of requiring you to manually manage the\r\n-/// underlying [AnimationController].\r\n-///\r\n-/// ## Common implicitly animated widgets\r\n-///\r\n-/// A number of implicitly animated widgets ship with the framework. They are\r\n-/// usually named `AnimatedFoo`, where `Foo` is the name of the non-animated\r\n-/// version of that widget. Commonly used implicitly animated widgets include:\r\n-///\r\n-///  * [TweenAnimationBuilder], which animates any property expressed by\r\n-///    a [Tween] to a specified target value.\r\n-///  * [AnimatedAlign], which is an implicitly animated version of [Align].\r\n-///  * [AnimatedContainer], which is an implicitly animated version of\r\n-///    [Container].\r\n-///  * [AnimatedDefaultTextStyle], which is an implicitly animated version of\r\n-///    [DefaultTextStyle].\r\n-///  * [AnimatedScale], which is an implicitly animated version of [Transform.scale].\r\n-///  * [AnimatedRotation], which is an implicitly animated version of [Transform.rotate].\r\n-///  * [AnimatedSlide], which implicitly animates the position of a widget relative to its normal position.\r\n-///  * [AnimatedOpacity], which is an implicitly animated version of [Opacity].\r\n-///  * [AnimatedPadding], which is an implicitly animated version of [Padding].\r\n-///  * [AnimatedPhysicalModel], which is an implicitly animated version of\r\n-///    [PhysicalModel].\r\n-///  * [AnimatedPositioned], which is an implicitly animated version of\r\n-///    [Positioned].\r\n-///  * [AnimatedPositionedDirectional], which is an implicitly animated version\r\n-///    of [PositionedDirectional].\r\n-///  * [AnimatedTheme], which is an implicitly animated version of [Theme].\r\n-///  * [AnimatedCrossFade], which cross-fades between two given children and\r\n-///    animates itself between their sizes.\r\n-///  * [AnimatedSize], which automatically transitions its size over a given\r\n-///    duration.\r\n-///  * [AnimatedSwitcher], which fades from one widget to another.\r\n-abstract class ListenableImplicitlyAnimatedWidget extends ImplicitlyAnimatedWidget {\r\n-  /// Initializes fields for subclasses.\r\n-  const ListenableImplicitlyAnimatedWidget({\r\n-    required super.duration,\r\n-    super.key,\r\n-    super.curve = Curves.linear,\r\n-    this.onForward,\r\n-    this.onReverse,\r\n-    this.onDismiss,\r\n-    super.onEnd,\r\n-  }) : super();\r\n-\r\n-  /// Called every time an animation starts.\r\n-  final VoidCallback? onForward;\r\n-\r\n-  /// Called every time an animation reverses.\r\n-  final VoidCallback? onReverse;\r\n-\r\n-  /// Called every time an animation dismisses.\r\n-  final VoidCallback? onDismiss;\r\n-\r\n-  @override\r\n-  ListenableImplicitlyAnimatedWidgetState<ListenableImplicitlyAnimatedWidget> createState();\r\n-\r\n-  @override\r\n-  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\r\n-    super.debugFillProperties(properties);\r\n-    properties.add(IntProperty(\"duration\", duration.inMilliseconds, unit: \"ms\"));\r\n-  }\r\n-}\r\n-\r\n-/// A base class for the `State` of widgets with implicit animations.\r\n-///\r\n-/// [ListenableImplicitlyAnimatedWidgetState] requires that subclasses respond to the\r\n-/// animation themselves. If you would like `setState()` to be called\r\n-/// automatically as the animation changes, use [ListenableAnimatedWidgetBaseState].\r\n-///\r\n-/// Properties that subclasses choose to animate are represented by [Tween]\r\n-/// instances. Subclasses must implement the [forEachTween] method to allow\r\n-/// [ListenableImplicitlyAnimatedWidgetState] to iterate through the widget's fields and\r\n-/// animate them.\r\n-abstract class ListenableImplicitlyAnimatedWidgetState<T extends ListenableImplicitlyAnimatedWidget>\r\n-    extends ImplicitlyAnimatedWidgetState<T> {\r\n-  @override\r\n-  void initState() {\r\n-    super.initState();\r\n-    super.controller.addStatusListener((status) {\r\n-      if (status case AnimationStatus.dismissed) {\r\n-        widget.onDismiss?.call();\r\n-      } else if (status case AnimationStatus.forward) {\r\n-        widget.onForward?.call();\r\n-      } else if (status case AnimationStatus.reverse) {\r\n-        widget.onReverse?.call();\r\n-      }\r\n-    });\r\n-  }\r\n-}\r\n-\r\n-abstract base class ListenableAnimatedWidgetBaseState<T extends ListenableImplicitlyAnimatedWidget>\r\n-    extends ListenableImplicitlyAnimatedWidgetState<T> {\r\n-  @override\r\n-  void initState() {\r\n-    super.initState();\r\n-    controller.addListener(_handleAnimationChanged);\r\n-  }\r\n-\r\n-  void _handleAnimationChanged() {\r\n-    setState(() {/* The animation ticked. Rebuild with new animation value */});\r\n-  }\r\n-}\r\n"
                }
            ],
            "date": 1698818471623,
            "name": "Commit-0",
            "content": "import \"package:flutter/foundation.dart\";\r\nimport \"package:flutter/material.dart\";\r\n\r\n/// An abstract class for building widgets that animate changes to their\r\n/// properties. This includes additional properties that allows finer control\r\n/// over the lifetime of the animation.\r\n///\r\n/// Widgets of this type will not animate when they are first added to the\r\n/// widget tree. Rather, when they are rebuilt with different values, they will\r\n/// respond to those _changes_ by animating the changes over a specified\r\n/// [duration].\r\n///\r\n/// Which properties are animated is left up to the subclass. Subclasses' [State]s\r\n/// must extend [ImplicitlyAnimatedWidgetState] and provide a way to visit the\r\n/// relevant fields to animate.\r\n///\r\n/// ## Relationship to [AnimatedWidget]s\r\n///\r\n/// [ImplicitlyAnimatedWidget]s (and their subclasses) automatically animate\r\n/// changes in their properties whenever they change. For this,\r\n/// they create and manage their own internal [AnimationController]s to power\r\n/// the animation. While these widgets are simple to use and don't require you\r\n/// to manually manage the lifecycle of an [AnimationController], they\r\n/// are also somewhat limited: Besides the target value for the animated\r\n/// property, developers can only choose a [duration] and [curve] for the\r\n/// animation. If you require more control over the animation (e.g. you want\r\n/// to stop it somewhere in the middle), consider using an\r\n/// [AnimatedWidget] or one of its subclasses. These widgets take an [Animation]\r\n/// as an argument to power the animation. This gives the developer full control\r\n/// over the animation at the cost of requiring you to manually manage the\r\n/// underlying [AnimationController].\r\n///\r\n/// ## Common implicitly animated widgets\r\n///\r\n/// A number of implicitly animated widgets ship with the framework. They are\r\n/// usually named `AnimatedFoo`, where `Foo` is the name of the non-animated\r\n/// version of that widget. Commonly used implicitly animated widgets include:\r\n///\r\n///  * [TweenAnimationBuilder], which animates any property expressed by\r\n///    a [Tween] to a specified target value.\r\n///  * [AnimatedAlign], which is an implicitly animated version of [Align].\r\n///  * [AnimatedContainer], which is an implicitly animated version of\r\n///    [Container].\r\n///  * [AnimatedDefaultTextStyle], which is an implicitly animated version of\r\n///    [DefaultTextStyle].\r\n///  * [AnimatedScale], which is an implicitly animated version of [Transform.scale].\r\n///  * [AnimatedRotation], which is an implicitly animated version of [Transform.rotate].\r\n///  * [AnimatedSlide], which implicitly animates the position of a widget relative to its normal position.\r\n///  * [AnimatedOpacity], which is an implicitly animated version of [Opacity].\r\n///  * [AnimatedPadding], which is an implicitly animated version of [Padding].\r\n///  * [AnimatedPhysicalModel], which is an implicitly animated version of\r\n///    [PhysicalModel].\r\n///  * [AnimatedPositioned], which is an implicitly animated version of\r\n///    [Positioned].\r\n///  * [AnimatedPositionedDirectional], which is an implicitly animated version\r\n///    of [PositionedDirectional].\r\n///  * [AnimatedTheme], which is an implicitly animated version of [Theme].\r\n///  * [AnimatedCrossFade], which cross-fades between two given children and\r\n///    animates itself between their sizes.\r\n///  * [AnimatedSize], which automatically transitions its size over a given\r\n///    duration.\r\n///  * [AnimatedSwitcher], which fades from one widget to another.\r\nabstract class ListenableImplicitlyAnimatedWidget extends ImplicitlyAnimatedWidget {\r\n  /// Initializes fields for subclasses.\r\n  const ListenableImplicitlyAnimatedWidget({\r\n    required super.duration,\r\n    super.key,\r\n    super.curve = Curves.linear,\r\n    this.onForward,\r\n    this.onReverse,\r\n    this.onDismiss,\r\n    super.onEnd,\r\n  }) : super();\r\n\r\n  /// Called every time an animation starts.\r\n  final VoidCallback? onForward;\r\n\r\n  /// Called every time an animation reverses.\r\n  final VoidCallback? onReverse;\r\n\r\n  /// Called every time an animation dismisses.\r\n  final VoidCallback? onDismiss;\r\n\r\n  @override\r\n  ListenableImplicitlyAnimatedWidgetState<ListenableImplicitlyAnimatedWidget> createState();\r\n\r\n  @override\r\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\r\n    super.debugFillProperties(properties);\r\n    properties.add(IntProperty(\"duration\", duration.inMilliseconds, unit: \"ms\"));\r\n  }\r\n}\r\n\r\n/// A base class for the `State` of widgets with implicit animations.\r\n///\r\n/// [ListenableImplicitlyAnimatedWidgetState] requires that subclasses respond to the\r\n/// animation themselves. If you would like `setState()` to be called\r\n/// automatically as the animation changes, use [ListenableAnimatedWidgetBaseState].\r\n///\r\n/// Properties that subclasses choose to animate are represented by [Tween]\r\n/// instances. Subclasses must implement the [forEachTween] method to allow\r\n/// [ListenableImplicitlyAnimatedWidgetState] to iterate through the widget's fields and\r\n/// animate them.\r\nabstract class ListenableImplicitlyAnimatedWidgetState<T extends ListenableImplicitlyAnimatedWidget>\r\n    extends ImplicitlyAnimatedWidgetState<T> {\r\n  @override\r\n  void initState() {\r\n    super.initState();\r\n    super.controller.addStatusListener((status) {\r\n      if (status case AnimationStatus.dismissed) {\r\n        widget.onDismiss?.call();\r\n      } else if (status case AnimationStatus.forward) {\r\n        widget.onForward?.call();\r\n      } else if (status case AnimationStatus.reverse) {\r\n        widget.onReverse?.call();\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nabstract base class ListenableAnimatedWidgetBaseState<T extends ListenableImplicitlyAnimatedWidget>\r\n    extends ListenableImplicitlyAnimatedWidgetState<T> {\r\n  @override\r\n  void initState() {\r\n    super.initState();\r\n    controller.addListener(_handleAnimationChanged);\r\n  }\r\n\r\n  void _handleAnimationChanged() {\r\n    setState(() {/* The animation ticked. Rebuild with new animation value */});\r\n  }\r\n}\r\n"
        }
    ]
}