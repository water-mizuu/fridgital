{
    "sourceFile": "lib/widgets/shared/helper/listenable_animated_widget/listenable_animated_transform.dart",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 15,
            "patches": [
                {
                    "date": 1698818298689,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1699166073180,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,88 @@\n+import \"package:flutter/material.dart\";\r\n+import \"package:fridgital/widgets/shared/helper/listenable_animated_widget/listenable_animated_widget.dart\";\r\n+\r\n+class ListenableAnimatedTransform extends ListenableImplicitlyAnimatedWidget {\r\n+  // ignore: unreachable_from_main\r\n+  const ListenableAnimatedTransform({\r\n+    required this.transform,\r\n+    required this.child,\r\n+    required super.duration,\r\n+    super.curve,\r\n+    super.key,\r\n+    super.onForward,\r\n+    super.onReverse,\r\n+    super.onDismiss,\r\n+    super.onEnd,\r\n+    this.origin,\r\n+    this.alignment,\r\n+    this.transformHitTests = true,\r\n+    this.filterQuality,\r\n+  });\r\n+\r\n+  ListenableAnimatedTransform.translate({\r\n+    required Offset offset,\r\n+    required super.duration,\r\n+    super.curve,\r\n+    super.key,\r\n+    super.onForward,\r\n+    super.onReverse,\r\n+    super.onDismiss,\r\n+    super.onEnd,\r\n+    this.transformHitTests = true,\r\n+    this.filterQualit,\r\n+    this.child,\r\n+  })  : transform = Matrix4.translationValues(offset.dx, offset.dy, 0.0),\r\n+        origin = null,\r\n+        alignment = null;\r\n+\r\n+  final Matrix4 transform;\r\n+  final Offset? origin;\r\n+  final AlignmentGeometry? alignment;\r\n+  final bool transformHitTests;\r\n+  final FilterQuality? filterQuality;\r\n+  final Widget? child;\r\n+\r\n+  @override\r\n+  AnimatedTransformState createState() => AnimatedTransformState();\r\n+}\r\n+\r\n+final class AnimatedTransformState extends ListenableAnimatedWidgetBaseState<ListenableAnimatedTransform> {\r\n+  Matrix4Tween? transform;\r\n+  Tween<Offset>? origin;\r\n+  AlignmentGeometryTween? alignment;\r\n+\r\n+  @override\r\n+  Widget build(BuildContext context) {\r\n+    var animation = this.animation;\r\n+\r\n+    return Transform(\r\n+      transform: transform!.evaluate(animation),\r\n+      origin: origin?.evaluate(animation),\r\n+      alignment: alignment?.evaluate(animation),\r\n+      transformHitTests: widget.transformHitTests,\r\n+      filterQuality: widget.filterQuality,\r\n+      child: widget.child,\r\n+    );\r\n+  }\r\n+\r\n+  @override\r\n+  void forEachTween(TweenVisitor<Object?> visitor) {\r\n+    transform = visitor(\r\n+      transform,\r\n+      widget.transform,\r\n+      (value) => Matrix4Tween(begin: value as Matrix4?),\r\n+    ) as Matrix4Tween?;\r\n+\r\n+    origin = visitor(\r\n+      origin,\r\n+      widget.origin,\r\n+      (value) => Tween<Offset>(begin: value as Offset?),\r\n+    ) as Tween<Offset>?;\r\n+\r\n+    alignment = visitor(\r\n+      alignment,\r\n+      widget.alignment,\r\n+      (value) => AlignmentGeometryTween(begin: value as AlignmentGeometry?),\r\n+    ) as AlignmentGeometryTween?;\r\n+  }\r\n+}\r\n"
                },
                {
                    "date": 1699166147359,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -28,97 +28,9 @@\n     super.onReverse,\r\n     super.onDismiss,\r\n     super.onEnd,\r\n     this.transformHitTests = true,\r\n-    this.filterQualit,\r\n-    this.child,\r\n-  })  : transform = Matrix4.translationValues(offset.dx, offset.dy, 0.0),\r\n-        origin = null,\r\n-        alignment = null;\r\n-\r\n-  final Matrix4 transform;\r\n-  final Offset? origin;\r\n-  final AlignmentGeometry? alignment;\r\n-  final bool transformHitTests;\r\n-  final FilterQuality? filterQuality;\r\n-  final Widget? child;\r\n-\r\n-  @override\r\n-  AnimatedTransformState createState() => AnimatedTransformState();\r\n-}\r\n-\r\n-final class AnimatedTransformState extends ListenableAnimatedWidgetBaseState<ListenableAnimatedTransform> {\r\n-  Matrix4Tween? transform;\r\n-  Tween<Offset>? origin;\r\n-  AlignmentGeometryTween? alignment;\r\n-\r\n-  @override\r\n-  Widget build(BuildContext context) {\r\n-    var animation = this.animation;\r\n-\r\n-    return Transform(\r\n-      transform: transform!.evaluate(animation),\r\n-      origin: origin?.evaluate(animation),\r\n-      alignment: alignment?.evaluate(animation),\r\n-      transformHitTests: widget.transformHitTests,\r\n-      filterQuality: widget.filterQuality,\r\n-      child: widget.child,\r\n-    );\r\n-  }\r\n-\r\n-  @override\r\n-  void forEachTween(TweenVisitor<Object?> visitor) {\r\n-    transform = visitor(\r\n-      transform,\r\n-      widget.transform,\r\n-      (value) => Matrix4Tween(begin: value as Matrix4?),\r\n-    ) as Matrix4Tween?;\r\n-\r\n-    origin = visitor(\r\n-      origin,\r\n-      widget.origin,\r\n-      (value) => Tween<Offset>(begin: value as Offset?),\r\n-    ) as Tween<Offset>?;\r\n-\r\n-    alignment = visitor(\r\n-      alignment,\r\n-      widget.alignment,\r\n-      (value) => AlignmentGeometryTween(begin: value as AlignmentGeometry?),\r\n-    ) as AlignmentGeometryTween?;\r\n-  }\r\n-}\r\n-import \"package:flutter/material.dart\";\r\n-import \"package:fridgital/widgets/shared/helper/listenable_animated_widget/listenable_animated_widget.dart\";\r\n-\r\n-class ListenableAnimatedTransform extends ListenableImplicitlyAnimatedWidget {\r\n-  // ignore: unreachable_from_main\r\n-  const ListenableAnimatedTransform({\r\n-    required this.transform,\r\n-    required this.child,\r\n-    required super.duration,\r\n-    super.curve,\r\n-    super.key,\r\n-    super.onForward,\r\n-    super.onReverse,\r\n-    super.onDismiss,\r\n-    super.onEnd,\r\n-    this.origin,\r\n-    this.alignment,\r\n-    this.transformHitTests = true,\r\n     this.filterQuality,\r\n-  });\r\n-\r\n-  ListenableAnimatedTransform.translate({\r\n-    required Offset offset,\r\n-    required super.duration,\r\n-    super.curve,\r\n-    super.key,\r\n-    super.onForward,\r\n-    super.onReverse,\r\n-    super.onDismiss,\r\n-    super.onEnd,\r\n-    this.transformHitTests = true,\r\n-    this.filterQuality,\r\n     this.child,\r\n   })  : transform = Matrix4.translationValues(offset.dx, offset.dy, 0.0),\r\n         origin = null,\r\n         alignment = null;\r\n@@ -140,9 +52,8 @@\n   AlignmentGeometryTween? alignment;\r\n \r\n   @override\r\n   Widget build(BuildContext context) {\r\n-    var animation = this.animation;\r\n \r\n     return Transform(\r\n       transform: transform!.evaluate(animation),\r\n       origin: origin?.evaluate(animation),\r\n"
                },
                {
                    "date": 1699285915284,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,85 @@\n+import \"package:flutter/material.dart\";\r\n+import \"package:fridgital/widgets/shared/helper/listenable_animated_widget/listenable_animated_widget.dart\";\r\n+\r\n+class ListenableAnimatedTransform extends ListenableImplicitlyAnimatedWidget {\r\n+  const ListenableAnimatedTransform({\r\n+    required this.transform,\r\n+    required this.child,\r\n+    required super.duration,\r\n+    super.curve,\r\n+    super.key,\r\n+    super.onForward,\r\n+    super.onReverse,\r\n+    super.onDismiss,\r\n+    super.onEnd,\r\n+    this.origin,\r\n+    this.alignment,\r\n+    this.transformHitTests = true,\r\n+    this.filterQuality,\r\n+  });\r\n+\r\n+  ListenableAnimatedTransform.translate({\r\n+    required Offset offset,\r\n+    required super.duration,\r\n+    super.curve,\r\n+    super.key,\r\n+    super.onForward,\r\n+    super.onReverse,\r\n+    super.onDismiss,\r\n+    super.onEnd,\r\n+    this.transformHitTests = true,\r\n+    this.filterQuality,\r\n+    this.child,\r\n+  })  : transform = Matrix4.translationValues(offset.dx, offset.dy, 0.0),\r\n+        origin = null,\r\n+        alignment = null;\r\n+\r\n+  final Matrix4 transform;\r\n+  final Offset? origin;\r\n+  final AlignmentGeometry? alignment;\r\n+  final bool transformHitTests;\r\n+  final FilterQuality? filterQuality;\r\n+  final Widget? child;\r\n+\r\n+  @override\r\n+  AnimatedTransformState createState() => AnimatedTransformState();\r\n+}\r\n+\r\n+final class AnimatedTransformState extends ListenableAnimatedWidgetBaseState<ListenableAnimatedTransform> {\r\n+  Matrix4Tween? transform;\r\n+  Tween<Offset>? origin;\r\n+  AlignmentGeometryTween? alignment;\r\n+\r\n+  @override\r\n+  Widget build(BuildContext context) {\r\n+    return Transform(\r\n+      transform: transform!.evaluate(animation),\r\n+      origin: origin?.evaluate(animation),\r\n+      alignment: alignment?.evaluate(animation),\r\n+      transformHitTests: widget.transformHitTests,\r\n+      filterQuality: widget.filterQuality,\r\n+      child: widget.child,\r\n+    );\r\n+  }\r\n+\r\n+  @override\r\n+  void forEachTween(TweenVisitor<Object?> visitor) {\r\n+    transform = visitor(\r\n+      transform,\r\n+      widget.transform,\r\n+      (value) => Matrix4Tween(begin: value as Matrix4?),\r\n+    ) as Matrix4Tween?;\r\n+\r\n+    origin = visitor(\r\n+      origin,\r\n+      widget.origin,\r\n+      (value) => Tween<Offset>(begin: value as Offset?),\r\n+    ) as Tween<Offset>?;\r\n+\r\n+    alignment = visitor(\r\n+      alignment,\r\n+      widget.alignment,\r\n+      (value) => AlignmentGeometryTween(begin: value as AlignmentGeometry?),\r\n+    ) as AlignmentGeometryTween?;\r\n+  }\r\n+}\r\n"
                },
                {
                    "date": 1699285947016,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,8 +1,10 @@\n import \"package:flutter/material.dart\";\r\n+import \"package:flutter/src/rendering/proxy_box.dart\";\r\n import \"package:fridgital/widgets/shared/helper/listenable_animated_widget/listenable_animated_widget.dart\";\r\n \r\n-class ListenableAnimatedTransform extends ListenableImplicitlyAnimatedWidget {\r\n+class ListenableAnimatedTransform extends ListenableImplicitlyAnimatedWidget implements Transform {\r\n+  // ignore: unreachable_from_main\r\n   const ListenableAnimatedTransform({\r\n     required this.transform,\r\n     required this.child,\r\n     required super.duration,\r\n@@ -33,103 +35,39 @@\n   })  : transform = Matrix4.translationValues(offset.dx, offset.dy, 0.0),\r\n         origin = null,\r\n         alignment = null;\r\n \r\n+  @override\r\n   final Matrix4 transform;\r\n+  @override\r\n   final Offset? origin;\r\n+  @override\r\n   final AlignmentGeometry? alignment;\r\n+  @override\r\n   final bool transformHitTests;\r\n+  @override\r\n   final FilterQuality? filterQuality;\r\n+  @override\r\n   final Widget? child;\r\n \r\n   @override\r\n   AnimatedTransformState createState() => AnimatedTransformState();\r\n-}\r\n \r\n-final class AnimatedTransformState extends ListenableAnimatedWidgetBaseState<ListenableAnimatedTransform> {\r\n-  Matrix4Tween? transform;\r\n-  Tween<Offset>? origin;\r\n-  AlignmentGeometryTween? alignment;\r\n-\r\n   @override\r\n-  Widget build(BuildContext context) {\r\n-    return Transform(\r\n-      transform: transform!.evaluate(animation),\r\n-      origin: origin?.evaluate(animation),\r\n-      alignment: alignment?.evaluate(animation),\r\n-      transformHitTests: widget.transformHitTests,\r\n-      filterQuality: widget.filterQuality,\r\n-      child: widget.child,\r\n-    );\r\n+  RenderTransform createRenderObject(BuildContext context) {\r\n+    // TODO: implement createRenderObject\r\n+    throw UnimplementedError();\r\n   }\r\n \r\n   @override\r\n-  void forEachTween(TweenVisitor<Object?> visitor) {\r\n-    transform = visitor(\r\n-      transform,\r\n-      widget.transform,\r\n-      (value) => Matrix4Tween(begin: value as Matrix4?),\r\n-    ) as Matrix4Tween?;\r\n-\r\n-    origin = visitor(\r\n-      origin,\r\n-      widget.origin,\r\n-      (value) => Tween<Offset>(begin: value as Offset?),\r\n-    ) as Tween<Offset>?;\r\n-\r\n-    alignment = visitor(\r\n-      alignment,\r\n-      widget.alignment,\r\n-      (value) => AlignmentGeometryTween(begin: value as AlignmentGeometry?),\r\n-    ) as AlignmentGeometryTween?;\r\n+  void didUnmountRenderObject(covariant RenderObject renderObject) {\r\n+    // TODO: implement didUnmountRenderObject\r\n   }\r\n-}\r\n-import \"package:flutter/material.dart\";\r\n-import \"package:fridgital/widgets/shared/helper/listenable_animated_widget/listenable_animated_widget.dart\";\r\n \r\n-class ListenableAnimatedTransform extends ListenableImplicitlyAnimatedWidget {\r\n-  // ignore: unreachable_from_main\r\n-  const ListenableAnimatedTransform({\r\n-    required this.transform,\r\n-    required this.child,\r\n-    required super.duration,\r\n-    super.curve,\r\n-    super.key,\r\n-    super.onForward,\r\n-    super.onReverse,\r\n-    super.onDismiss,\r\n-    super.onEnd,\r\n-    this.origin,\r\n-    this.alignment,\r\n-    this.transformHitTests = true,\r\n-    this.filterQuality,\r\n-  });\r\n-\r\n-  ListenableAnimatedTransform.translate({\r\n-    required Offset offset,\r\n-    required super.duration,\r\n-    super.curve,\r\n-    super.key,\r\n-    super.onForward,\r\n-    super.onReverse,\r\n-    super.onDismiss,\r\n-    super.onEnd,\r\n-    this.transformHitTests = true,\r\n-    this.filterQuality,\r\n-    this.child,\r\n-  })  : transform = Matrix4.translationValues(offset.dx, offset.dy, 0.0),\r\n-        origin = null,\r\n-        alignment = null;\r\n-\r\n-  final Matrix4 transform;\r\n-  final Offset? origin;\r\n-  final AlignmentGeometry? alignment;\r\n-  final bool transformHitTests;\r\n-  final FilterQuality? filterQuality;\r\n-  final Widget? child;\r\n-\r\n   @override\r\n-  AnimatedTransformState createState() => AnimatedTransformState();\r\n+  void updateRenderObject(BuildContext context, covariant RenderTransform renderObject) {\r\n+    // TODO: implement updateRenderObject\r\n+  }\r\n }\r\n \r\n final class AnimatedTransformState extends ListenableAnimatedWidgetBaseState<ListenableAnimatedTransform> {\r\n   Matrix4Tween? transform;\r\n@@ -137,9 +75,8 @@\n   AlignmentGeometryTween? alignment;\r\n \r\n   @override\r\n   Widget build(BuildContext context) {\r\n-\r\n     return Transform(\r\n       transform: transform!.evaluate(animation),\r\n       origin: origin?.evaluate(animation),\r\n       alignment: alignment?.evaluate(animation),\r\n"
                },
                {
                    "date": 1699285977065,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,10 +1,9 @@\n import \"package:flutter/material.dart\";\r\n-import \"package:flutter/src/rendering/proxy_box.dart\";\r\n import \"package:fridgital/widgets/shared/helper/listenable_animated_widget/listenable_animated_widget.dart\";\r\n \r\n-class ListenableAnimatedTransform extends ListenableImplicitlyAnimatedWidget implements Transform {\r\n-  // ignore: unreachable_from_main\r\n+class ListenableAnimatedTransform extends ListenableImplicitlyAnimatedWidget {\r\n+  /// Creates a widget that transforms its child.\r\n   const ListenableAnimatedTransform({\r\n     required this.transform,\r\n     required this.child,\r\n     required super.duration,\r\n@@ -35,39 +34,17 @@\n   })  : transform = Matrix4.translationValues(offset.dx, offset.dy, 0.0),\r\n         origin = null,\r\n         alignment = null;\r\n \r\n-  @override\r\n   final Matrix4 transform;\r\n-  @override\r\n   final Offset? origin;\r\n-  @override\r\n   final AlignmentGeometry? alignment;\r\n-  @override\r\n   final bool transformHitTests;\r\n-  @override\r\n   final FilterQuality? filterQuality;\r\n-  @override\r\n   final Widget? child;\r\n \r\n   @override\r\n   AnimatedTransformState createState() => AnimatedTransformState();\r\n-\r\n-  @override\r\n-  RenderTransform createRenderObject(BuildContext context) {\r\n-    // TODO: implement createRenderObject\r\n-    throw UnimplementedError();\r\n-  }\r\n-\r\n-  @override\r\n-  void didUnmountRenderObject(covariant RenderObject renderObject) {\r\n-    // TODO: implement didUnmountRenderObject\r\n-  }\r\n-\r\n-  @override\r\n-  void updateRenderObject(BuildContext context, covariant RenderTransform renderObject) {\r\n-    // TODO: implement updateRenderObject\r\n-  }\r\n }\r\n \r\n final class AnimatedTransformState extends ListenableAnimatedWidgetBaseState<ListenableAnimatedTransform> {\r\n   Matrix4Tween? transform;\r\n"
                },
                {
                    "date": 1699286008533,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,105 @@\n+import \"package:flutter/material.dart\";\r\n+import \"package:fridgital/widgets/shared/helper/listenable_animated_widget/listenable_animated_widget.dart\";\r\n+\r\n+class ListenableAnimatedTransform extends ListenableImplicitlyAnimatedWidget {\r\n+  /// Creates a widget that transforms its child.\r\n+  const ListenableAnimatedTransform({\r\n+    required this.transform,\r\n+    required this.child,\r\n+    required super.duration,\r\n+    super.curve,\r\n+    super.key,\r\n+    super.onForward,\r\n+    super.onReverse,\r\n+    super.onDismiss,\r\n+    super.onEnd,\r\n+    this.origin,\r\n+    this.alignment,\r\n+    this.transformHitTests = true,\r\n+    this.filterQuality,\r\n+  });\r\n+\r\n+  /// Creates a widget that transforms its child using a translation.\r\n+  ///\r\n+  /// The `offset` argument specifies the translation.\r\n+  ///\r\n+  /// {@tool snippet}\r\n+  ///\r\n+  /// This example shifts the silver-colored child down by fifteen pixels.\r\n+  ///\r\n+  /// ```dart\r\n+  /// A.translate(\r\n+  ///   offset: const Offset(0.0, 15.0),\r\n+  ///   child: Container(\r\n+  ///     padding: const EdgeInsets.all(8.0),\r\n+  ///     color: const Color(0xFF7F7F7F),\r\n+  ///     child: const Text('Quarter'),\r\n+  ///   ),\r\n+  /// )\r\n+  /// ```\r\n+  /// {@end-tool}\r\n+  ListenableAnimatedTransform.translate({\r\n+    required Offset offset,\r\n+    required super.duration,\r\n+    super.curve,\r\n+    super.key,\r\n+    super.onForward,\r\n+    super.onReverse,\r\n+    super.onDismiss,\r\n+    super.onEnd,\r\n+    this.transformHitTests = true,\r\n+    this.filterQuality,\r\n+    this.child,\r\n+  })  : transform = Matrix4.translationValues(offset.dx, offset.dy, 0.0),\r\n+        origin = null,\r\n+        alignment = null;\r\n+\r\n+  final Matrix4 transform;\r\n+  final Offset? origin;\r\n+  final AlignmentGeometry? alignment;\r\n+  final bool transformHitTests;\r\n+  final FilterQuality? filterQuality;\r\n+  final Widget? child;\r\n+\r\n+  @override\r\n+  AnimatedTransformState createState() => AnimatedTransformState();\r\n+}\r\n+\r\n+final class AnimatedTransformState extends ListenableAnimatedWidgetBaseState<ListenableAnimatedTransform> {\r\n+  Matrix4Tween? transform;\r\n+  Tween<Offset>? origin;\r\n+  AlignmentGeometryTween? alignment;\r\n+\r\n+  @override\r\n+  Widget build(BuildContext context) {\r\n+    return Transform(\r\n+      transform: transform!.evaluate(animation),\r\n+      origin: origin?.evaluate(animation),\r\n+      alignment: alignment?.evaluate(animation),\r\n+      transformHitTests: widget.transformHitTests,\r\n+      filterQuality: widget.filterQuality,\r\n+      child: widget.child,\r\n+    );\r\n+  }\r\n+\r\n+  @override\r\n+  void forEachTween(TweenVisitor<Object?> visitor) {\r\n+    transform = visitor(\r\n+      transform,\r\n+      widget.transform,\r\n+      (value) => Matrix4Tween(begin: value as Matrix4?),\r\n+    ) as Matrix4Tween?;\r\n+\r\n+    origin = visitor(\r\n+      origin,\r\n+      widget.origin,\r\n+      (value) => Tween<Offset>(begin: value as Offset?),\r\n+    ) as Tween<Offset>?;\r\n+\r\n+    alignment = visitor(\r\n+      alignment,\r\n+      widget.alignment,\r\n+      (value) => AlignmentGeometryTween(begin: value as AlignmentGeometry?),\r\n+    ) as AlignmentGeometryTween?;\r\n+  }\r\n+}\r\n"
                },
                {
                    "date": 1699286040257,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -27,9 +27,9 @@\n   ///\r\n   /// This example shifts the silver-colored child down by fifteen pixels.\r\n   ///\r\n   /// ```dart\r\n-  /// A.translate(\r\n+  /// ListenableAnimatedTransform.translate(\r\n   ///   offset: const Offset(0.0, 15.0),\r\n   ///   child: Container(\r\n   ///     padding: const EdgeInsets.all(8.0),\r\n   ///     color: const Color(0xFF7F7F7F),\r\n@@ -53,94 +53,60 @@\n   })  : transform = Matrix4.translationValues(offset.dx, offset.dy, 0.0),\r\n         origin = null,\r\n         alignment = null;\r\n \r\n-  final Matrix4 transform;\r\n-  final Offset? origin;\r\n-  final AlignmentGeometry? alignment;\r\n-  final bool transformHitTests;\r\n-  final FilterQuality? filterQuality;\r\n-  final Widget? child;\r\n-\r\n-  @override\r\n-  AnimatedTransformState createState() => AnimatedTransformState();\r\n-}\r\n-\r\n-final class AnimatedTransformState extends ListenableAnimatedWidgetBaseState<ListenableAnimatedTransform> {\r\n-  Matrix4Tween? transform;\r\n-  Tween<Offset>? origin;\r\n-  AlignmentGeometryTween? alignment;\r\n-\r\n-  @override\r\n-  Widget build(BuildContext context) {\r\n-    return Transform(\r\n-      transform: transform!.evaluate(animation),\r\n-      origin: origin?.evaluate(animation),\r\n-      alignment: alignment?.evaluate(animation),\r\n-      transformHitTests: widget.transformHitTests,\r\n-      filterQuality: widget.filterQuality,\r\n-      child: widget.child,\r\n-    );\r\n-  }\r\n-\r\n-  @override\r\n-  void forEachTween(TweenVisitor<Object?> visitor) {\r\n-    transform = visitor(\r\n-      transform,\r\n-      widget.transform,\r\n-      (value) => Matrix4Tween(begin: value as Matrix4?),\r\n-    ) as Matrix4Tween?;\r\n-\r\n-    origin = visitor(\r\n-      origin,\r\n-      widget.origin,\r\n-      (value) => Tween<Offset>(begin: value as Offset?),\r\n-    ) as Tween<Offset>?;\r\n-\r\n-    alignment = visitor(\r\n-      alignment,\r\n-      widget.alignment,\r\n-      (value) => AlignmentGeometryTween(begin: value as AlignmentGeometry?),\r\n-    ) as AlignmentGeometryTween?;\r\n-  }\r\n-}\r\n-import \"package:flutter/material.dart\";\r\n-import \"package:fridgital/widgets/shared/helper/listenable_animated_widget/listenable_animated_widget.dart\";\r\n-\r\n-class ListenableAnimatedTransform extends ListenableImplicitlyAnimatedWidget {\r\n-  /// Creates a widget that transforms its child.\r\n-  const ListenableAnimatedTransform({\r\n-    required this.transform,\r\n-    required this.child,\r\n-    required super.duration,\r\n-    super.curve,\r\n+  /// Creates a widget that scales its child along the 2D plane.\r\n+  ///\r\n+  /// The `scaleX` argument provides the scalar by which to multiply the `x`\r\n+  /// axis, and the `scaleY` argument provides the scalar by which to multiply\r\n+  /// the `y` axis. Either may be omitted, in which case the scaling factor for\r\n+  /// that axis defaults to 1.0.\r\n+  ///\r\n+  /// For convenience, to scale the child uniformly, instead of providing\r\n+  /// `scaleX` and `scaleY`, the `scale` parameter may be used.\r\n+  ///\r\n+  /// At least one of `scale`, `scaleX`, and `scaleY` must be non-null. If\r\n+  /// `scale` is provided, the other two must be null; similarly, if it is not\r\n+  /// provided, one of the other two must be provided.\r\n+  ///\r\n+  /// The [alignment] controls the origin of the scale; by default, this is the\r\n+  /// center of the box.\r\n+  ///\r\n+  /// {@tool snippet}\r\n+  ///\r\n+  /// This example shrinks an orange box containing text such that each\r\n+  /// dimension is half the size it would otherwise be.\r\n+  ///\r\n+  /// ```dart\r\n+  /// Transform.scale(\r\n+  ///   scale: 0.5,\r\n+  ///   child: Container(\r\n+  ///     padding: const EdgeInsets.all(8.0),\r\n+  ///     color: const Color(0xFFE8581C),\r\n+  ///     child: const Text('Bad Idea Bears'),\r\n+  ///   ),\r\n+  /// )\r\n+  /// ```\r\n+  /// {@end-tool}\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  /// * [ScaleTransition], which animates changes in scale smoothly over a given\r\n+  ///   duration.\r\n+  Transform.scale({\r\n     super.key,\r\n-    super.onForward,\r\n-    super.onReverse,\r\n-    super.onDismiss,\r\n-    super.onEnd,\r\n+    double? scale,\r\n+    double? scaleX,\r\n+    double? scaleY,\r\n     this.origin,\r\n-    this.alignment,\r\n+    this.alignment = Alignment.center,\r\n     this.transformHitTests = true,\r\n     this.filterQuality,\r\n-  });\r\n+    super.child,\r\n+  })  : assert(!(scale == null && scaleX == null && scaleY == null), \"At least one of 'scale', 'scaleX' and 'scaleY' is required to be non-null\"),\r\n+        assert(scale == null || (scaleX == null && scaleY == null), \"If 'scale' is non-null then 'scaleX' and 'scaleY' must be left null\"),\r\n+        transform = Matrix4.diagonal3Values(scale ?? scaleX ?? 1.0, scale ?? scaleY ?? 1.0, 1.0);\r\n \r\n-  ListenableAnimatedTransform.translate({\r\n-    required Offset offset,\r\n-    required super.duration,\r\n-    super.curve,\r\n-    super.key,\r\n-    super.onForward,\r\n-    super.onReverse,\r\n-    super.onDismiss,\r\n-    super.onEnd,\r\n-    this.transformHitTests = true,\r\n-    this.filterQuality,\r\n-    this.child,\r\n-  })  : transform = Matrix4.translationValues(offset.dx, offset.dy, 0.0),\r\n-        origin = null,\r\n-        alignment = null;\r\n-\r\n   final Matrix4 transform;\r\n   final Offset? origin;\r\n   final AlignmentGeometry? alignment;\r\n   final bool transformHitTests;\r\n"
                },
                {
                    "date": 1699286070771,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -91,20 +91,30 @@\n   /// See also:\r\n   ///\r\n   /// * [ScaleTransition], which animates changes in scale smoothly over a given\r\n   ///   duration.\r\n-  Transform.scale({\r\n+  ListenableAnimatedTransform.scale({\r\n+    super.onForward,\r\n+    super.onReverse,\r\n+    super.onDismiss,\r\n+    super.onEnd,\r\n     super.key,\r\n     double? scale,\r\n     double? scaleX,\r\n     double? scaleY,\r\n     this.origin,\r\n     this.alignment = Alignment.center,\r\n     this.transformHitTests = true,\r\n     this.filterQuality,\r\n-    super.child,\r\n-  })  : assert(!(scale == null && scaleX == null && scaleY == null), \"At least one of 'scale', 'scaleX' and 'scaleY' is required to be non-null\"),\r\n-        assert(scale == null || (scaleX == null && scaleY == null), \"If 'scale' is non-null then 'scaleX' and 'scaleY' must be left null\"),\r\n+    this.child,\r\n+  })  : assert(\r\n+          !(scale == null && scaleX == null && scaleY == null),\r\n+          \"At least one of 'scale', 'scaleX' and 'scaleY' is required to be non-null\",\r\n+        ),\r\n+        assert(\r\n+          scale == null || (scaleX == null && scaleY == null),\r\n+          \"If 'scale' is non-null then 'scaleX' and 'scaleY' must be left null\",\r\n+        ),\r\n         transform = Matrix4.diagonal3Values(scale ?? scaleX ?? 1.0, scale ?? scaleY ?? 1.0, 1.0);\r\n \r\n   final Matrix4 transform;\r\n   final Offset? origin;\r\n"
                },
                {
                    "date": 1699286103553,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -92,8 +92,9 @@\n   ///\r\n   /// * [ScaleTransition], which animates changes in scale smoothly over a given\r\n   ///   duration.\r\n   ListenableAnimatedTransform.scale({\r\n+    required super.duration,\r\n     super.onForward,\r\n     super.onReverse,\r\n     super.onDismiss,\r\n     super.onEnd,\r\n@@ -115,8 +116,37 @@\n           \"If 'scale' is non-null then 'scaleX' and 'scaleY' must be left null\",\r\n         ),\r\n         transform = Matrix4.diagonal3Values(scale ?? scaleX ?? 1.0, scale ?? scaleY ?? 1.0, 1.0);\r\n \r\n+  /// Creates a widget that mirrors its child about the widget's center point.\r\n+  ///\r\n+  /// If `flipX` is true, the child widget will be flipped horizontally. Defaults to false.\r\n+  ///\r\n+  /// If `flipY` is true, the child widget will be flipped vertically. Defaults to false.\r\n+  ///\r\n+  /// If both are true, the child widget will be flipped both vertically and horizontally, equivalent to a 180 degree rotation.\r\n+  ///\r\n+  /// {@tool snippet}\r\n+  ///\r\n+  /// This example flips the text horizontally.\r\n+  ///\r\n+  /// ```dart\r\n+  /// Transform.flip(\r\n+  ///   flipX: true,\r\n+  ///   child: const Text('Horizontal Flip'),\r\n+  /// )\r\n+  /// ```\r\n+  /// {@end-tool}\r\n+  Transform.flip({\r\n+      super.key,\r\n+      bool flipX = false,\r\n+      bool flipY = false,\r\n+      this.origin,\r\n+      this.transformHitTests = true,\r\n+      this.filterQuality,\r\n+      super.child,\r\n+  })  : alignment = Alignment.center,\r\n+        transform = Matrix4.diagonal3Values(flipX ? -1.0 : 1.0, flipY ? -1.0 : 1.0, 1.0);\r\n   final Matrix4 transform;\r\n   final Offset? origin;\r\n   final AlignmentGeometry? alignment;\r\n   final bool transformHitTests;\r\n"
                },
                {
                    "date": 1699286152345,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -76,9 +76,9 @@\n   /// This example shrinks an orange box containing text such that each\r\n   /// dimension is half the size it would otherwise be.\r\n   ///\r\n   /// ```dart\r\n-  /// Transform.scale(\r\n+  /// LTransform.scale(\r\n   ///   scale: 0.5,\r\n   ///   child: Container(\r\n   ///     padding: const EdgeInsets.all(8.0),\r\n   ///     color: const Color(0xFFE8581C),\r\n@@ -129,24 +129,25 @@\n   ///\r\n   /// This example flips the text horizontally.\r\n   ///\r\n   /// ```dart\r\n-  /// Transform.flip(\r\n+  /// LTransform.flip(\r\n   ///   flipX: true,\r\n   ///   child: const Text('Horizontal Flip'),\r\n   /// )\r\n   /// ```\r\n   /// {@end-tool}\r\n-  Transform.flip({\r\n+  ListenableAnimatedTransform.flip({\r\n       super.key,\r\n       bool flipX = false,\r\n       bool flipY = false,\r\n       this.origin,\r\n       this.transformHitTests = true,\r\n       this.filterQuality,\r\n-      super.child,\r\n+      this.child,\r\n   })  : alignment = Alignment.center,\r\n         transform = Matrix4.diagonal3Values(flipX ? -1.0 : 1.0, flipY ? -1.0 : 1.0, 1.0);\r\n+\r\n   final Matrix4 transform;\r\n   final Offset? origin;\r\n   final AlignmentGeometry? alignment;\r\n   final bool transformHitTests;\r\n"
                },
                {
                    "date": 1699286183531,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -41,10 +41,10 @@\n   ListenableAnimatedTransform.translate({\r\n     required Offset offset,\r\n     required super.duration,\r\n     super.curve,\r\n+    super.onForward,\r\n     super.key,\r\n-    super.onForward,\r\n     super.onReverse,\r\n     super.onDismiss,\r\n     super.onEnd,\r\n     this.transformHitTests = true,\r\n@@ -76,9 +76,9 @@\n   /// This example shrinks an orange box containing text such that each\r\n   /// dimension is half the size it would otherwise be.\r\n   ///\r\n   /// ```dart\r\n-  /// LTransform.scale(\r\n+  /// ListenableAnimatedTransform.scale(\r\n   ///   scale: 0.5,\r\n   ///   child: Container(\r\n   ///     padding: const EdgeInsets.all(8.0),\r\n   ///     color: const Color(0xFFE8581C),\r\n@@ -97,8 +97,9 @@\n     super.onForward,\r\n     super.onReverse,\r\n     super.onDismiss,\r\n     super.onEnd,\r\n+    super.curve,\r\n     super.key,\r\n     double? scale,\r\n     double? scaleX,\r\n     double? scaleY,\r\n@@ -129,22 +130,28 @@\n   ///\r\n   /// This example flips the text horizontally.\r\n   ///\r\n   /// ```dart\r\n-  /// LTransform.flip(\r\n+  /// ListenableAnimatedTransform.flip(\r\n   ///   flipX: true,\r\n   ///   child: const Text('Horizontal Flip'),\r\n   /// )\r\n   /// ```\r\n   /// {@end-tool}\r\n   ListenableAnimatedTransform.flip({\r\n-      super.key,\r\n-      bool flipX = false,\r\n-      bool flipY = false,\r\n-      this.origin,\r\n-      this.transformHitTests = true,\r\n-      this.filterQuality,\r\n-      this.child,\r\n+    required super.duration,\r\n+    super.onForward,\r\n+    super.onReverse,\r\n+    super.onDismiss,\r\n+    super.onEnd,\r\n+    super.curve,\r\n+    super.key,\r\n+    bool flipX = false,\r\n+    bool flipY = false,\r\n+    this.origin,\r\n+    this.transformHitTests = true,\r\n+    this.filterQuality,\r\n+    this.child,\r\n   })  : alignment = Alignment.center,\r\n         transform = Matrix4.diagonal3Values(flipX ? -1.0 : 1.0, flipY ? -1.0 : 1.0, 1.0);\r\n \r\n   final Matrix4 transform;\r\n"
                },
                {
                    "date": 1699286218624,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -18,8 +18,44 @@\n     this.transformHitTests = true,\r\n     this.filterQuality,\r\n   });\r\n \r\n+\r\n+  /// Creates a widget that transforms its child using a rotation around the\r\n+  /// center.\r\n+  ///\r\n+  /// The `angle` argument gives the rotation in clockwise radians.\r\n+  ///\r\n+  /// {@tool snippet}\r\n+  ///\r\n+  /// This example rotates an orange box containing text around its center by\r\n+  /// fifteen degrees.\r\n+  ///\r\n+  /// ```dart\r\n+  /// Transform.rotate(\r\n+  ///   angle: -math.pi / 12.0,\r\n+  ///   child: Container(\r\n+  ///     padding: const EdgeInsets.all(8.0),\r\n+  ///     color: const Color(0xFFE8581C),\r\n+  ///     child: const Text('Apartment for rent!'),\r\n+  ///   ),\r\n+  /// )\r\n+  /// ```\r\n+  /// {@end-tool}\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [RotationTransition], which animates changes in rotation smoothly\r\n+  ///    over a given duration.\r\n+  Transform.rotate({\r\n+    super.key,\r\n+    required double angle,\r\n+    this.origin,\r\n+    this.alignment = Alignment.center,\r\n+    this.transformHitTests = true,\r\n+    this.filterQuality,\r\n+    super.child,\r\n+  }) : transform = _computeRotation(angle);\r\n   /// Creates a widget that transforms its child using a translation.\r\n   ///\r\n   /// The `offset` argument specifies the translation.\r\n   ///\r\n@@ -40,13 +76,13 @@\n   /// {@end-tool}\r\n   ListenableAnimatedTransform.translate({\r\n     required Offset offset,\r\n     required super.duration,\r\n-    super.curve,\r\n     super.onForward,\r\n-    super.key,\r\n     super.onReverse,\r\n     super.onDismiss,\r\n+    super.curve,\r\n+    super.key,\r\n     super.onEnd,\r\n     this.transformHitTests = true,\r\n     this.filterQuality,\r\n     this.child,\r\n"
                },
                {
                    "date": 1699286253493,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -45,17 +45,23 @@\n   /// See also:\r\n   ///\r\n   ///  * [RotationTransition], which animates changes in rotation smoothly\r\n   ///    over a given duration.\r\n-  Transform.rotate({\r\n+  ListenableAnimatedTransform.rotate({\r\n+    required double angle,\r\n+    required super.duration,\r\n+    super.onForward,\r\n+    super.onReverse,\r\n+    super.onDismiss,\r\n+    super.curve,\r\n     super.key,\r\n-    required double angle,\r\n     this.origin,\r\n     this.alignment = Alignment.center,\r\n     this.transformHitTests = true,\r\n     this.filterQuality,\r\n-    super.child,\r\n+    this.child,\r\n   }) : transform = _computeRotation(angle);\r\n+\r\n   /// Creates a widget that transforms its child using a translation.\r\n   ///\r\n   /// The `offset` argument specifies the translation.\r\n   ///\r\n@@ -195,8 +201,9 @@\n   final AlignmentGeometry? alignment;\r\n   final bool transformHitTests;\r\n   final FilterQuality? filterQuality;\r\n   final Widget? child;\r\n+  \r\n \r\n   @override\r\n   AnimatedTransformState createState() => AnimatedTransformState();\r\n }\r\n"
                },
                {
                    "date": 1699286284636,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,4 +1,6 @@\n+import \"dart:math\" as math;\r\n+\r\n import \"package:flutter/material.dart\";\r\n import \"package:fridgital/widgets/shared/helper/listenable_animated_widget/listenable_animated_widget.dart\";\r\n \r\n class ListenableAnimatedTransform extends ListenableImplicitlyAnimatedWidget {\r\n@@ -18,9 +20,8 @@\n     this.transformHitTests = true,\r\n     this.filterQuality,\r\n   });\r\n \r\n-\r\n   /// Creates a widget that transforms its child using a rotation around the\r\n   /// center.\r\n   ///\r\n   /// The `angle` argument gives the rotation in clockwise radians.\r\n@@ -195,16 +196,55 @@\n     this.child,\r\n   })  : alignment = Alignment.center,\r\n         transform = Matrix4.diagonal3Values(flipX ? -1.0 : 1.0, flipY ? -1.0 : 1.0, 1.0);\r\n \r\n+  /// The matrix to transform the child by during painting.\r\n   final Matrix4 transform;\r\n+\r\n+  \r\n+  /// The origin of the coordinate system (relative to the upper left corner of\r\n+  /// this render object) in which to apply the matrix.\r\n+  ///\r\n+  /// Setting an origin is equivalent to conjugating the transform matrix by a\r\n+  /// translation. This property is provided just for convenience.\r\n   final Offset? origin;\r\n   final AlignmentGeometry? alignment;\r\n   final bool transformHitTests;\r\n   final FilterQuality? filterQuality;\r\n   final Widget? child;\r\n-  \r\n \r\n+  // Computes a rotation matrix for an angle in radians, attempting to keep rotations\r\n+  // at integral values for angles of 0, π/2, π, 3π/2.\r\n+  static Matrix4 _computeRotation(double radians) {\r\n+    assert(radians.isFinite, \"Cannot compute the rotation matrix for a non-finite angle: $radians\");\r\n+    if (radians == 0.0) {\r\n+      return Matrix4.identity();\r\n+    }\r\n+    var sin = math.sin(radians);\r\n+    if (sin == 1.0) {\r\n+      return _createZRotation(1.0, 0.0);\r\n+    }\r\n+    if (sin == -1.0) {\r\n+      return _createZRotation(-1.0, 0.0);\r\n+    }\r\n+    var cos = math.cos(radians);\r\n+    if (cos == -1.0) {\r\n+      return _createZRotation(0.0, -1.0);\r\n+    }\r\n+    return _createZRotation(sin, cos);\r\n+  }\r\n+\r\n+  static Matrix4 _createZRotation(double sin, double cos) {\r\n+    var result = Matrix4.zero();\r\n+    result.storage[0] = cos;\r\n+    result.storage[1] = sin;\r\n+    result.storage[4] = -sin;\r\n+    result.storage[5] = cos;\r\n+    result.storage[10] = 1.0;\r\n+    result.storage[15] = 1.0;\r\n+    return result;\r\n+  }\r\n+\r\n   @override\r\n   AnimatedTransformState createState() => AnimatedTransformState();\r\n }\r\n \r\n"
                },
                {
                    "date": 1699286331649,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -199,18 +199,44 @@\n \r\n   /// The matrix to transform the child by during painting.\r\n   final Matrix4 transform;\r\n \r\n-  \r\n   /// The origin of the coordinate system (relative to the upper left corner of\r\n   /// this render object) in which to apply the matrix.\r\n   ///\r\n   /// Setting an origin is equivalent to conjugating the transform matrix by a\r\n   /// translation. This property is provided just for convenience.\r\n   final Offset? origin;\r\n+\r\n+  /// The alignment of the origin, relative to the size of the box.\r\n+  ///\r\n+  /// This is equivalent to setting an origin based on the size of the box.\r\n+  /// If it is specified at the same time as the [origin], both are applied.\r\n+  ///\r\n+  /// An [AlignmentDirectional.centerStart] value is the same as an [Alignment]\r\n+  /// whose [Alignment.x] value is `-1.0` if [Directionality.of] returns\r\n+  /// [TextDirection.ltr], and `1.0` if [Directionality.of] returns\r\n+  /// [TextDirection.rtl].\t Similarly [AlignmentDirectional.centerEnd] is the\r\n+  /// same as an [Alignment] whose [Alignment.x] value is `1.0` if\r\n+  /// [Directionality.of] returns\t [TextDirection.ltr], and `-1.0` if\r\n+  /// [Directionality.of] returns [TextDirection.rtl].\r\n   final AlignmentGeometry? alignment;\r\n+\r\n+  /// Whether to apply the transformation when performing hit tests.\r\n   final bool transformHitTests;\r\n+\r\n+  /// The filter quality with which to apply the transform as a bitmap operation.\r\n+  ///\r\n+  /// {@template flutter.widgets.Transform.optional.FilterQuality}\r\n+  /// The transform will be applied by re-rendering the child if [filterQuality] is null,\r\n+  /// otherwise it controls the quality of an [ImageFilter.matrix] applied to a bitmap\r\n+  /// rendering of the child.\r\n+  /// {@endtemplate}\r\n   final FilterQuality? filterQuality;\r\n+\r\n+  /// The widget below this widget in the tree.\r\n+  ///\r\n+  /// {@macro flutter.widgets.ProxyWidget.child}\r\n   final Widget? child;\r\n \r\n   // Computes a rotation matrix for an angle in radians, attempting to keep rotations\r\n   // at integral values for angles of 0, π/2, π, 3π/2.\r\n"
                }
            ],
            "date": 1698818298689,
            "name": "Commit-0",
            "content": "import \"package:flutter/material.dart\";\r\nimport \"package:fridgital/widgets/shared/helper/listenable_animated_widget/listenable_animated_widget.dart\";\r\n\r\nclass ListenableAnimatedTransform extends ListenableImplicitlyAnimatedWidget {\r\n  // ignore: unreachable_from_main\r\n  const ListenableAnimatedTransform({\r\n    required this.transform,\r\n    required this.child,\r\n    required super.duration,\r\n    super.curve,\r\n    super.key,\r\n    super.onForward,\r\n    super.onReverse,\r\n    super.onDismiss,\r\n    super.onEnd,\r\n    this.origin,\r\n    this.alignment,\r\n    this.transformHitTests = true,\r\n    this.filterQuality,\r\n  });\r\n\r\n  ListenableAnimatedTransform.translate({\r\n    required Offset offset,\r\n    required super.duration,\r\n    super.curve,\r\n    super.key,\r\n    super.onForward,\r\n    super.onReverse,\r\n    super.onDismiss,\r\n    super.onEnd,\r\n    this.transformHitTests = true,\r\n    this.filterQuality,\r\n    this.child,\r\n  })  : transform = Matrix4.translationValues(offset.dx, offset.dy, 0.0),\r\n        origin = null,\r\n        alignment = null;\r\n\r\n  final Matrix4 transform;\r\n  final Offset? origin;\r\n  final AlignmentGeometry? alignment;\r\n  final bool transformHitTests;\r\n  final FilterQuality? filterQuality;\r\n  final Widget? child;\r\n\r\n  @override\r\n  AnimatedTransformState createState() => AnimatedTransformState();\r\n}\r\n\r\nfinal class AnimatedTransformState extends ListenableAnimatedWidgetBaseState<ListenableAnimatedTransform> {\r\n  Matrix4Tween? transform;\r\n  Tween<Offset>? origin;\r\n  AlignmentGeometryTween? alignment;\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    var animation = this.animation;\r\n\r\n    return Transform(\r\n      transform: transform!.evaluate(animation),\r\n      origin: origin?.evaluate(animation),\r\n      alignment: alignment?.evaluate(animation),\r\n      transformHitTests: widget.transformHitTests,\r\n      filterQuality: widget.filterQuality,\r\n      child: widget.child,\r\n    );\r\n  }\r\n\r\n  @override\r\n  void forEachTween(TweenVisitor<Object?> visitor) {\r\n    transform = visitor(\r\n      transform,\r\n      widget.transform,\r\n      (value) => Matrix4Tween(begin: value as Matrix4?),\r\n    ) as Matrix4Tween?;\r\n\r\n    origin = visitor(\r\n      origin,\r\n      widget.origin,\r\n      (value) => Tween<Offset>(begin: value as Offset?),\r\n    ) as Tween<Offset>?;\r\n\r\n    alignment = visitor(\r\n      alignment,\r\n      widget.alignment,\r\n      (value) => AlignmentGeometryTween(begin: value as AlignmentGeometry?),\r\n    ) as AlignmentGeometryTween?;\r\n  }\r\n}\r\n"
        }
    ]
}