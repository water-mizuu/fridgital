{
    "sourceFile": "lib/widgets/shared/helper/listenable_animated_widget.dart",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 13,
            "patches": [
                {
                    "date": 1698817377416,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1698817409298,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,11 +1,166 @@\n+import \"package:flutter/material.dart\";\r\n+ion = widget.duration;\r\n+    if (_constructTweens()) {\r\n+      forEachTween((Tween<dynamic>? tween, dynamic targetValue, TweenConstructor<dynamic> constructor) {\r\n+        _updateTween(tween, targetValue);\r\n+        return tween;\r\n+      });\r\n+      _controller\r\n+        ..value = 0.0\r\n+        ..forward();\r\n+      didUpdateTweens();\r\n+    }\r\n+  }\r\n+\r\n+  CurvedAnimation _createCurve() {\r\n+    return CurvedAnimation(parent: _controller, curve: widget.curve);\r\n+  }\r\n+\r\n+  @override\r\n+  void dispose() {\r\n+    _animation.dispose();\r\n+    _controller.dispose();\r\n+    super.dispose();\r\n+  }\r\n+\r\n+  bool _shouldAnimateTween(Tween<dynamic> tween, dynamic targetValue) {\r\n+    return targetValue != (tween.end ?? tween.begin);\r\n+  }\r\n+\r\n+  void _updateTween(Tween<dynamic>? tween, dynamic targetValue) {\r\n+    if (tween == null) {\r\n+      return;\r\n+    }\r\n+    tween\r\n+      ..begin = tween.evaluate(_animation)\r\n+      ..end = targetValue;\r\n+  }\r\n+\r\n+  bool _constructTweens() {\r\n+    bool shouldStartAnimation = false;\r\n+    forEachTween((Tween<dynamic>? tween, dynamic targetValue, TweenConstructor<dynamic> constructor) {\r\n+      if (targetValue != null) {\r\n+        tween ??= constructor(targetValue);\r\n+        if (_shouldAnimateTween(tween, targetValue)) {\r\n+          shouldStartAnimation = true;\r\n+        } else {\r\n+          tween.end ??= tween.begin;\r\n+        }\r\n+      } else {\r\n+        tween = null;\r\n+      }\r\n+      return tween;\r\n+    });\r\n+    return shouldStartAnimation;\r\n+  }\r\n+\r\n+  /// Visits each tween controlled by this state with the specified `visitor`\r\n+  /// function.\r\n+  ///\r\n+  /// ### Subclass responsibility\r\n+  ///\r\n+  /// Properties to be animated are represented by [Tween] member variables in\r\n+  /// the state. For each such tween, [forEachTween] implementations are\r\n+  /// expected to call `visitor` with the appropriate arguments and store the\r\n+  /// result back into the member variable. The arguments to `visitor` are as\r\n+  /// follows:\r\n+  ///\r\n+  /// {@macro flutter.widgets.TweenVisitor.arguments}\r\n+  ///\r\n+  /// ### When this method will be called\r\n+  ///\r\n+  /// [forEachTween] is initially called during [initState]. It is expected that\r\n+  /// the visitor's `tween` argument will be set to null, causing the visitor to\r\n+  /// call its `constructor` argument to construct the tween for the first time.\r\n+  /// The resulting tween will have its `begin` value set to the target value\r\n+  /// and will have its `end` value set to null. The animation will not be\r\n+  /// started.\r\n+  ///\r\n+  /// When this state's [widget] is updated (thus triggering the\r\n+  /// [didUpdateWidget] method to be called), [forEachTween] will be called\r\n+  /// again to check if the target value has changed. If the target value has\r\n+  /// changed, signaling that the [animation] should start, then the visitor\r\n+  /// will update the tween's `start` and `end` values accordingly, and the\r\n+  /// animation will be started.\r\n+  ///\r\n+  /// ### Other member variables\r\n+  ///\r\n+  /// Subclasses that contain properties based on tweens created by\r\n+  /// [forEachTween] should override [didUpdateTweens] to update those\r\n+  /// properties. Dependent properties should not be updated within\r\n+  /// [forEachTween].\r\n+  ///\r\n+  /// {@tool snippet}\r\n+  ///\r\n+  /// This sample implements an implicitly animated widget's `State`.\r\n+  /// The widget animates between colors whenever `widget.targetColor`\r\n+  /// changes.\r\n+  ///\r\n+  /// ```dart\r\n+  /// class MyWidgetState extends AnimatedWidgetBaseState<MyWidget> {\r\n+  ///   ColorTween? _colorTween;\r\n+  ///\r\n+  ///   @override\r\n+  ///   Widget build(BuildContext context) {\r\n+  ///     return Text(\r\n+  ///       'Hello World',\r\n+  ///       // Computes the value of the text color at any given time.\r\n+  ///       style: TextStyle(color: _colorTween?.evaluate(animation)),\r\n+  ///     );\r\n+  ///   }\r\n+  ///\r\n+  ///   @override\r\n+  ///   void forEachTween(TweenVisitor<dynamic> visitor) {\r\n+  ///     // Update the tween using the provided visitor function.\r\n+  ///     _colorTween = visitor(\r\n+  ///       // The latest tween value. Can be `null`.\r\n+  ///       _colorTween,\r\n+  ///       // The color value toward which we are animating.\r\n+  ///       widget.targetColor,\r\n+  ///       // A function that takes a color value and returns a tween\r\n+  ///       // beginning at that value.\r\n+  ///       (dynamic value) => ColorTween(begin: value as Color?),\r\n+  ///     ) as ColorTween?;\r\n+  ///\r\n+  ///     // We could have more tweens than one by using the visitor\r\n+  ///     // multiple times.\r\n+  ///   }\r\n+  /// }\r\n+  /// ```\r\n+  /// {@end-tool}\r\n+  @protected\r\n+  void forEachTween(TweenVisitor<dynamic> visitor);\r\n+\r\n+  /// Optional hook for subclasses that runs after all tweens have been updated\r\n+  /// via [forEachTween].\r\n+  ///\r\n+  /// Any properties that depend upon tweens created by [forEachTween] should be\r\n+  /// updated within [didUpdateTweens], not within [forEachTween].\r\n+  ///\r\n+  /// This method will be called both:\r\n+  ///\r\n+  ///  1. After the tweens are _initially_ constructed (by\r\n+  ///     the `constructor` argument to the [TweenVisitor] that's passed to\r\n+  ///     [forEachTween]). In this case, the tweens are likely to contain only\r\n+  ///     a [Tween.begin] value and not a [Tween.end].\r\n+  ///\r\n+  ///  2. When the state's [widget] is updated, and one or more of the tweens\r\n+  ///     visited by [forEachTween] specifies a target value that's different\r\n+  ///     than the widget's current value, thus signaling that the [animation]\r\n+  ///     should run. In this case, the [Tween.begin] value for each tween will\r\n+  ///     an evaluation of the tween against the current [animation], and the\r\n+  ///     [Tween.end] value for each tween will be the target value.\r\n+  @protected\r\n+  void didUpdateTweens() { }\r\n+}\r\n abstract class AnimatedWidgetBaseState<T extends ImplicitlyAnimatedWidget> extends ImplicitlyAnimatedWidgetState<T> {\r\n   @override\r\n   void initState() {\r\n     super.initState();\r\n     controller.addListener(_handleAnimationChanged);\r\n   }\r\n \r\n   void _handleAnimationChanged() {\r\n-    setState(() { /* The animation ticked. Rebuild with new animation value */ });\r\n+    setState(() {/* The animation ticked. Rebuild with new animation value */});\r\n   }\r\n }\r\n"
                },
                {
                    "date": 1698817621928,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,8 +1,58 @@\n+import \"package:flutter/foundation.dart\";\r\n import \"package:flutter/material.dart\";\r\n-ion = widget.duration;\r\n+\r\n+/// A base class for the `State` of widgets with implicit animations.\r\n+///\r\n+/// [ListenableImplicitlyAnimatedWidgetState] requires that subclasses respond to the\r\n+/// animation themselves. If you would like `setState()` to be called\r\n+/// automatically as the animation changes, use [ListenableAnimatedWidgetBaseState].\r\n+///\r\n+/// Properties that subclasses choose to animate are represented by [Tween]\r\n+/// instances. Subclasses must implement the [forEachTween] method to allow\r\n+/// [ListenableImplicitlyAnimatedWidgetState] to iterate through the widget's fields and\r\n+/// animate them.\r\n+abstract class ListenableImplicitlyAnimatedWidgetState<T extends ImplicitlyAnimatedWidget> extends State<T>\r\n+    with SingleTickerProviderStateMixin<T> {\r\n+  /// The animation controller driving this widget's implicit animations.\r\n+  @protected\r\n+  AnimationController get controller => _controller;\r\n+  late final AnimationController _controller = AnimationController(\r\n+    duration: widget.duration,\r\n+    debugLabel: kDebugMode ? widget.toStringShort() : null,\r\n+    vsync: this,\r\n+  );\r\n+\r\n+  /// The animation driving this widget's implicit animations.\r\n+  Animation<double> get animation => _animation;\r\n+  late CurvedAnimation _animation = _createCurve();\r\n+\r\n+  @override\r\n+  void initState() {\r\n+    super.initState();\r\n+    _controller.addStatusListener((status) {\r\n+      switch (status) {\r\n+        case AnimationStatus.completed:\r\n+          widget.onEnd?.call();\r\n+        case AnimationStatus.dismissed:\r\n+        case AnimationStatus.forward:\r\n+        case AnimationStatus.reverse:\r\n+      }\r\n+    });\r\n+    _constructTweens();\r\n+    didUpdateTweens();\r\n+  }\r\n+\r\n+  @override\r\n+  void didUpdateWidget(T oldWidget) {\r\n+    super.didUpdateWidget(oldWidget);\r\n+    if (widget.curve != oldWidget.curve) {\r\n+      _animation.dispose();\r\n+      _animation = _createCurve();\r\n+    }\r\n+    _controller.duration = widget.duration;\r\n     if (_constructTweens()) {\r\n-      forEachTween((Tween<dynamic>? tween, dynamic targetValue, TweenConstructor<dynamic> constructor) {\r\n+      forEachTween((tween, dynamic targetValue, constructor) {\r\n         _updateTween(tween, targetValue);\r\n         return tween;\r\n       });\r\n       _controller\r\n@@ -36,10 +86,10 @@\n       ..end = targetValue;\r\n   }\r\n \r\n   bool _constructTweens() {\r\n-    bool shouldStartAnimation = false;\r\n-    forEachTween((Tween<dynamic>? tween, dynamic targetValue, TweenConstructor<dynamic> constructor) {\r\n+    var shouldStartAnimation = false;\r\n+    forEachTween((tween, dynamic targetValue, constructor) {\r\n       if (targetValue != null) {\r\n         tween ??= constructor(targetValue);\r\n         if (_shouldAnimateTween(tween, targetValue)) {\r\n           shouldStartAnimation = true;\r\n@@ -150,11 +200,13 @@\n   ///     should run. In this case, the [Tween.begin] value for each tween will\r\n   ///     an evaluation of the tween against the current [animation], and the\r\n   ///     [Tween.end] value for each tween will be the target value.\r\n   @protected\r\n-  void didUpdateTweens() { }\r\n+  void didUpdateTweens() {}\r\n }\r\n-abstract class AnimatedWidgetBaseState<T extends ImplicitlyAnimatedWidget> extends ImplicitlyAnimatedWidgetState<T> {\r\n+\r\n+abstract class ListenableAnimatedWidgetBaseState<T extends ImplicitlyAnimatedWidget>\r\n+    extends ListenableImplicitlyAnimatedWidgetState<T> {\r\n   @override\r\n   void initState() {\r\n     super.initState();\r\n     controller.addListener(_handleAnimationChanged);\r\n"
                },
                {
                    "date": 1698817669760,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,7 +1,95 @@\n import \"package:flutter/foundation.dart\";\r\n import \"package:flutter/material.dart\";\r\n \r\n+/// An abstract class for building widgets that animate changes to their\r\n+/// properties.\r\n+///\r\n+/// Widgets of this type will not animate when they are first added to the\r\n+/// widget tree. Rather, when they are rebuilt with different values, they will\r\n+/// respond to those _changes_ by animating the changes over a specified\r\n+/// [duration].\r\n+///\r\n+/// Which properties are animated is left up to the subclass. Subclasses' [State]s\r\n+/// must extend [ImplicitlyAnimatedWidgetState] and provide a way to visit the\r\n+/// relevant fields to animate.\r\n+///\r\n+/// ## Relationship to [AnimatedWidget]s\r\n+///\r\n+/// [ImplicitlyAnimatedWidget]s (and their subclasses) automatically animate\r\n+/// changes in their properties whenever they change. For this,\r\n+/// they create and manage their own internal [AnimationController]s to power\r\n+/// the animation. While these widgets are simple to use and don't require you\r\n+/// to manually manage the lifecycle of an [AnimationController], they\r\n+/// are also somewhat limited: Besides the target value for the animated\r\n+/// property, developers can only choose a [duration] and [curve] for the\r\n+/// animation. If you require more control over the animation (e.g. you want\r\n+/// to stop it somewhere in the middle), consider using an\r\n+/// [AnimatedWidget] or one of its subclasses. These widgets take an [Animation]\r\n+/// as an argument to power the animation. This gives the developer full control\r\n+/// over the animation at the cost of requiring you to manually manage the\r\n+/// underlying [AnimationController].\r\n+///\r\n+/// ## Common implicitly animated widgets\r\n+///\r\n+/// A number of implicitly animated widgets ship with the framework. They are\r\n+/// usually named `AnimatedFoo`, where `Foo` is the name of the non-animated\r\n+/// version of that widget. Commonly used implicitly animated widgets include:\r\n+///\r\n+///  * [TweenAnimationBuilder], which animates any property expressed by\r\n+///    a [Tween] to a specified target value.\r\n+///  * [AnimatedAlign], which is an implicitly animated version of [Align].\r\n+///  * [AnimatedContainer], which is an implicitly animated version of\r\n+///    [Container].\r\n+///  * [AnimatedDefaultTextStyle], which is an implicitly animated version of\r\n+///    [DefaultTextStyle].\r\n+///  * [AnimatedScale], which is an implicitly animated version of [Transform.scale].\r\n+///  * [AnimatedRotation], which is an implicitly animated version of [Transform.rotate].\r\n+///  * [AnimatedSlide], which implicitly animates the position of a widget relative to its normal position.\r\n+///  * [AnimatedOpacity], which is an implicitly animated version of [Opacity].\r\n+///  * [AnimatedPadding], which is an implicitly animated version of [Padding].\r\n+///  * [AnimatedPhysicalModel], which is an implicitly animated version of\r\n+///    [PhysicalModel].\r\n+///  * [AnimatedPositioned], which is an implicitly animated version of\r\n+///    [Positioned].\r\n+///  * [AnimatedPositionedDirectional], which is an implicitly animated version\r\n+///    of [PositionedDirectional].\r\n+///  * [AnimatedTheme], which is an implicitly animated version of [Theme].\r\n+///  * [AnimatedCrossFade], which cross-fades between two given children and\r\n+///    animates itself between their sizes.\r\n+///  * [AnimatedSize], which automatically transitions its size over a given\r\n+///    duration.\r\n+///  * [AnimatedSwitcher], which fades from one widget to another.\r\n+abstract class ImplicitlyAnimatedWidget extends StatefulWidget {\r\n+  /// Initializes fields for subclasses.\r\n+  const ImplicitlyAnimatedWidget({\r\n+    super.key,\r\n+    this.curve = Curves.linear,\r\n+    required this.duration,\r\n+    this.onEnd,\r\n+  });\r\n+\r\n+  /// The curve to apply when animating the parameters of this container.\r\n+  final Curve curve;\r\n+\r\n+  /// The duration over which to animate the parameters of this container.\r\n+  final Duration duration;\r\n+\r\n+  /// Called every time an animation completes.\r\n+  ///\r\n+  /// This can be useful to trigger additional actions (e.g. another animation)\r\n+  /// at the end of the current animation.\r\n+  final VoidCallback? onEnd;\r\n+\r\n+  @override\r\n+  ImplicitlyAnimatedWidgetState<ImplicitlyAnimatedWidget> createState();\r\n+\r\n+  @override\r\n+  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\r\n+    super.debugFillProperties(properties);\r\n+    properties.add(IntProperty('duration', duration.inMilliseconds, unit: 'ms'));\r\n+  }\r\n+}\r\n /// A base class for the `State` of widgets with implicit animations.\r\n ///\r\n /// [ListenableImplicitlyAnimatedWidgetState] requires that subclasses respond to the\r\n /// animation themselves. If you would like `setState()` to be called\r\n"
                },
                {
                    "date": 1698817699818,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,313 @@\n+import \"package:flutter/foundation.dart\";\r\n+import \"package:flutter/material.dart\";\r\n+\r\n+/// An abstract class for building widgets that animate changes to their\r\n+/// properties.\r\n+///\r\n+/// Widgets of this type will not animate when they are first added to the\r\n+/// widget tree. Rather, when they are rebuilt with different values, they will\r\n+/// respond to those _changes_ by animating the changes over a specified\r\n+/// [duration].\r\n+///\r\n+/// Which properties are animated is left up to the subclass. Subclasses' [State]s\r\n+/// must extend [ImplicitlyAnimatedWidgetState] and provide a way to visit the\r\n+/// relevant fields to animate.\r\n+///\r\n+/// ## Relationship to [AnimatedWidget]s\r\n+///\r\n+/// [ImplicitlyAnimatedWidget]s (and their subclasses) automatically animate\r\n+/// changes in their properties whenever they change. For this,\r\n+/// they create and manage their own internal [AnimationController]s to power\r\n+/// the animation. While these widgets are simple to use and don't require you\r\n+/// to manually manage the lifecycle of an [AnimationController], they\r\n+/// are also somewhat limited: Besides the target value for the animated\r\n+/// property, developers can only choose a [duration] and [curve] for the\r\n+/// animation. If you require more control over the animation (e.g. you want\r\n+/// to stop it somewhere in the middle), consider using an\r\n+/// [AnimatedWidget] or one of its subclasses. These widgets take an [Animation]\r\n+/// as an argument to power the animation. This gives the developer full control\r\n+/// over the animation at the cost of requiring you to manually manage the\r\n+/// underlying [AnimationController].\r\n+///\r\n+/// ## Common implicitly animated widgets\r\n+///\r\n+/// A number of implicitly animated widgets ship with the framework. They are\r\n+/// usually named `AnimatedFoo`, where `Foo` is the name of the non-animated\r\n+/// version of that widget. Commonly used implicitly animated widgets include:\r\n+///\r\n+///  * [TweenAnimationBuilder], which animates any property expressed by\r\n+///    a [Tween] to a specified target value.\r\n+///  * [AnimatedAlign], which is an implicitly animated version of [Align].\r\n+///  * [AnimatedContainer], which is an implicitly animated version of\r\n+///    [Container].\r\n+///  * [AnimatedDefaultTextStyle], which is an implicitly animated version of\r\n+///    [DefaultTextStyle].\r\n+///  * [AnimatedScale], which is an implicitly animated version of [Transform.scale].\r\n+///  * [AnimatedRotation], which is an implicitly animated version of [Transform.rotate].\r\n+///  * [AnimatedSlide], which implicitly animates the position of a widget relative to its normal position.\r\n+///  * [AnimatedOpacity], which is an implicitly animated version of [Opacity].\r\n+///  * [AnimatedPadding], which is an implicitly animated version of [Padding].\r\n+///  * [AnimatedPhysicalModel], which is an implicitly animated version of\r\n+///    [PhysicalModel].\r\n+///  * [AnimatedPositioned], which is an implicitly animated version of\r\n+///    [Positioned].\r\n+///  * [AnimatedPositionedDirectional], which is an implicitly animated version\r\n+///    of [PositionedDirectional].\r\n+///  * [AnimatedTheme], which is an implicitly animated version of [Theme].\r\n+///  * [AnimatedCrossFade], which cross-fades between two given children and\r\n+///    animates itself between their sizes.\r\n+///  * [AnimatedSize], which automatically transitions its size over a given\r\n+///    duration.\r\n+///  * [AnimatedSwitcher], which fades from one widget to another.\r\n+abstract class ListenableImplicitlyAnimatedWidget extends StatefulWidget {\r\n+  /// Initializes fields for subclasses.\r\n+  const ListenableImplicitlyAnimatedWidget({\r\n+    required this.duration,\r\n+    super.key,\r\n+    this.curve = Curves.linear,\r\n+    this.onEnd,\r\n+  });\r\n+\r\n+  /// The curve to apply when animating the parameters of this container.\r\n+  final Curve curve;\r\n+\r\n+  /// The duration over which to animate the parameters of this container.\r\n+  final Duration duration;\r\n+\r\n+  /// Called every time an animation completes.\r\n+  ///\r\n+  /// This can be useful to trigger additional actions (e.g. another animation)\r\n+  /// at the end of the current animation.\r\n+  final VoidCallback? onEnd;\r\n+\r\n+  /// Called every time an animation .\r\n+  ///\r\n+  /// This can be useful to trigger additional actions (e.g. another animation)\r\n+  /// at the end of the current animation.\r\n+  final VoidCallback? onEnd;\r\n+\r\n+  @override\r\n+  ListenableImplicitlyAnimatedWidgetState<ListenableImplicitlyAnimatedWidget> createState();\r\n+\r\n+  @override\r\n+  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\r\n+    super.debugFillProperties(properties);\r\n+    properties.add(IntProperty(\"duration\", duration.inMilliseconds, unit: \"ms\"));\r\n+  }\r\n+}\r\n+\r\n+/// A base class for the `State` of widgets with implicit animations.\r\n+///\r\n+/// [ListenableImplicitlyAnimatedWidgetState] requires that subclasses respond to the\r\n+/// animation themselves. If you would like `setState()` to be called\r\n+/// automatically as the animation changes, use [ListenableAnimatedWidgetBaseState].\r\n+///\r\n+/// Properties that subclasses choose to animate are represented by [Tween]\r\n+/// instances. Subclasses must implement the [forEachTween] method to allow\r\n+/// [ListenableImplicitlyAnimatedWidgetState] to iterate through the widget's fields and\r\n+/// animate them.\r\n+abstract class ListenableImplicitlyAnimatedWidgetState<T extends ListenableImplicitlyAnimatedWidget> extends State<T>\r\n+    with SingleTickerProviderStateMixin<T> {\r\n+  /// The animation controller driving this widget's implicit animations.\r\n+  @protected\r\n+  AnimationController get controller => _controller;\r\n+  late final AnimationController _controller = AnimationController(\r\n+    duration: widget.duration,\r\n+    debugLabel: kDebugMode ? widget.toStringShort() : null,\r\n+    vsync: this,\r\n+  );\r\n+\r\n+  /// The animation driving this widget's implicit animations.\r\n+  Animation<double> get animation => _animation;\r\n+  late CurvedAnimation _animation = _createCurve();\r\n+\r\n+  @override\r\n+  void initState() {\r\n+    super.initState();\r\n+    _controller.addStatusListener((status) {\r\n+      switch (status) {\r\n+        case AnimationStatus.completed:\r\n+          widget.onEnd?.call();\r\n+        case AnimationStatus.dismissed:\r\n+        case AnimationStatus.forward:\r\n+        case AnimationStatus.reverse:\r\n+      }\r\n+    });\r\n+    _constructTweens();\r\n+    didUpdateTweens();\r\n+  }\r\n+\r\n+  @override\r\n+  void didUpdateWidget(T oldWidget) {\r\n+    super.didUpdateWidget(oldWidget);\r\n+    if (widget.curve != oldWidget.curve) {\r\n+      _animation.dispose();\r\n+      _animation = _createCurve();\r\n+    }\r\n+    _controller.duration = widget.duration;\r\n+    if (_constructTweens()) {\r\n+      forEachTween((tween, dynamic targetValue, constructor) {\r\n+        _updateTween(tween, targetValue);\r\n+        return tween;\r\n+      });\r\n+      _controller\r\n+        ..value = 0.0\r\n+        ..forward();\r\n+      didUpdateTweens();\r\n+    }\r\n+  }\r\n+\r\n+  CurvedAnimation _createCurve() {\r\n+    return CurvedAnimation(parent: _controller, curve: widget.curve);\r\n+  }\r\n+\r\n+  @override\r\n+  void dispose() {\r\n+    _animation.dispose();\r\n+    _controller.dispose();\r\n+    super.dispose();\r\n+  }\r\n+\r\n+  bool _shouldAnimateTween(Tween<dynamic> tween, dynamic targetValue) {\r\n+    return targetValue != (tween.end ?? tween.begin);\r\n+  }\r\n+\r\n+  void _updateTween(Tween<dynamic>? tween, dynamic targetValue) {\r\n+    if (tween == null) {\r\n+      return;\r\n+    }\r\n+    tween\r\n+      ..begin = tween.evaluate(_animation)\r\n+      ..end = targetValue;\r\n+  }\r\n+\r\n+  bool _constructTweens() {\r\n+    var shouldStartAnimation = false;\r\n+    forEachTween((tween, dynamic targetValue, constructor) {\r\n+      if (targetValue != null) {\r\n+        tween ??= constructor(targetValue);\r\n+        if (_shouldAnimateTween(tween, targetValue)) {\r\n+          shouldStartAnimation = true;\r\n+        } else {\r\n+          tween.end ??= tween.begin;\r\n+        }\r\n+      } else {\r\n+        tween = null;\r\n+      }\r\n+      return tween;\r\n+    });\r\n+    return shouldStartAnimation;\r\n+  }\r\n+\r\n+  /// Visits each tween controlled by this state with the specified `visitor`\r\n+  /// function.\r\n+  ///\r\n+  /// ### Subclass responsibility\r\n+  ///\r\n+  /// Properties to be animated are represented by [Tween] member variables in\r\n+  /// the state. For each such tween, [forEachTween] implementations are\r\n+  /// expected to call `visitor` with the appropriate arguments and store the\r\n+  /// result back into the member variable. The arguments to `visitor` are as\r\n+  /// follows:\r\n+  ///\r\n+  /// {@macro flutter.widgets.TweenVisitor.arguments}\r\n+  ///\r\n+  /// ### When this method will be called\r\n+  ///\r\n+  /// [forEachTween] is initially called during [initState]. It is expected that\r\n+  /// the visitor's `tween` argument will be set to null, causing the visitor to\r\n+  /// call its `constructor` argument to construct the tween for the first time.\r\n+  /// The resulting tween will have its `begin` value set to the target value\r\n+  /// and will have its `end` value set to null. The animation will not be\r\n+  /// started.\r\n+  ///\r\n+  /// When this state's [widget] is updated (thus triggering the\r\n+  /// [didUpdateWidget] method to be called), [forEachTween] will be called\r\n+  /// again to check if the target value has changed. If the target value has\r\n+  /// changed, signaling that the [animation] should start, then the visitor\r\n+  /// will update the tween's `start` and `end` values accordingly, and the\r\n+  /// animation will be started.\r\n+  ///\r\n+  /// ### Other member variables\r\n+  ///\r\n+  /// Subclasses that contain properties based on tweens created by\r\n+  /// [forEachTween] should override [didUpdateTweens] to update those\r\n+  /// properties. Dependent properties should not be updated within\r\n+  /// [forEachTween].\r\n+  ///\r\n+  /// {@tool snippet}\r\n+  ///\r\n+  /// This sample implements an implicitly animated widget's `State`.\r\n+  /// The widget animates between colors whenever `widget.targetColor`\r\n+  /// changes.\r\n+  ///\r\n+  /// ```dart\r\n+  /// class MyWidgetState extends AnimatedWidgetBaseState<MyWidget> {\r\n+  ///   ColorTween? _colorTween;\r\n+  ///\r\n+  ///   @override\r\n+  ///   Widget build(BuildContext context) {\r\n+  ///     return Text(\r\n+  ///       'Hello World',\r\n+  ///       // Computes the value of the text color at any given time.\r\n+  ///       style: TextStyle(color: _colorTween?.evaluate(animation)),\r\n+  ///     );\r\n+  ///   }\r\n+  ///\r\n+  ///   @override\r\n+  ///   void forEachTween(TweenVisitor<dynamic> visitor) {\r\n+  ///     // Update the tween using the provided visitor function.\r\n+  ///     _colorTween = visitor(\r\n+  ///       // The latest tween value. Can be `null`.\r\n+  ///       _colorTween,\r\n+  ///       // The color value toward which we are animating.\r\n+  ///       widget.targetColor,\r\n+  ///       // A function that takes a color value and returns a tween\r\n+  ///       // beginning at that value.\r\n+  ///       (dynamic value) => ColorTween(begin: value as Color?),\r\n+  ///     ) as ColorTween?;\r\n+  ///\r\n+  ///     // We could have more tweens than one by using the visitor\r\n+  ///     // multiple times.\r\n+  ///   }\r\n+  /// }\r\n+  /// ```\r\n+  /// {@end-tool}\r\n+  @protected\r\n+  void forEachTween(TweenVisitor<dynamic> visitor);\r\n+\r\n+  /// Optional hook for subclasses that runs after all tweens have been updated\r\n+  /// via [forEachTween].\r\n+  ///\r\n+  /// Any properties that depend upon tweens created by [forEachTween] should be\r\n+  /// updated within [didUpdateTweens], not within [forEachTween].\r\n+  ///\r\n+  /// This method will be called both:\r\n+  ///\r\n+  ///  1. After the tweens are _initially_ constructed (by\r\n+  ///     the `constructor` argument to the [TweenVisitor] that's passed to\r\n+  ///     [forEachTween]). In this case, the tweens are likely to contain only\r\n+  ///     a [Tween.begin] value and not a [Tween.end].\r\n+  ///\r\n+  ///  2. When the state's [widget] is updated, and one or more of the tweens\r\n+  ///     visited by [forEachTween] specifies a target value that's different\r\n+  ///     than the widget's current value, thus signaling that the [animation]\r\n+  ///     should run. In this case, the [Tween.begin] value for each tween will\r\n+  ///     an evaluation of the tween against the current [animation], and the\r\n+  ///     [Tween.end] value for each tween will be the target value.\r\n+  @protected\r\n+  void didUpdateTweens() {}\r\n+}\r\n+\r\n+abstract class ListenableAnimatedWidgetBaseState<T extends ListenableImplicitlyAnimatedWidget>\r\n+    extends ListenableImplicitlyAnimatedWidgetState<T> {\r\n+  @override\r\n+  void initState() {\r\n+    super.initState();\r\n+    controller.addListener(_handleAnimationChanged);\r\n+  }\r\n+\r\n+  void _handleAnimationChanged() {\r\n+    setState(() {/* The animation ticked. Rebuild with new animation value */});\r\n+  }\r\n+}\r\n"
                },
                {
                    "date": 1698817730242,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -64,8 +64,9 @@\n   const ListenableImplicitlyAnimatedWidget({\r\n     required this.duration,\r\n     super.key,\r\n     this.curve = Curves.linear,\r\n+    this.onForward,\r\n     this.onEnd,\r\n   });\r\n \r\n   /// The curve to apply when animating the parameters of this container.\r\n@@ -79,13 +80,10 @@\n   /// This can be useful to trigger additional actions (e.g. another animation)\r\n   /// at the end of the current animation.\r\n   final VoidCallback? onEnd;\r\n \r\n-  /// Called every time an animation .\r\n-  ///\r\n-  /// This can be useful to trigger additional actions (e.g. another animation)\r\n-  /// at the end of the current animation.\r\n-  final VoidCallback? onEnd;\r\n+  /// Called every time an animation starts.\r\n+  final VoidCallback? onForward;\r\n \r\n   @override\r\n   ListenableImplicitlyAnimatedWidgetState<ListenableImplicitlyAnimatedWidget> createState();\r\n \r\n@@ -310,310 +308,4 @@\n   void _handleAnimationChanged() {\r\n     setState(() {/* The animation ticked. Rebuild with new animation value */});\r\n   }\r\n }\r\n-import \"package:flutter/foundation.dart\";\r\n-import \"package:flutter/material.dart\";\r\n-\r\n-/// An abstract class for building widgets that animate changes to their\r\n-/// properties.\r\n-///\r\n-/// Widgets of this type will not animate when they are first added to the\r\n-/// widget tree. Rather, when they are rebuilt with different values, they will\r\n-/// respond to those _changes_ by animating the changes over a specified\r\n-/// [duration].\r\n-///\r\n-/// Which properties are animated is left up to the subclass. Subclasses' [State]s\r\n-/// must extend [ImplicitlyAnimatedWidgetState] and provide a way to visit the\r\n-/// relevant fields to animate.\r\n-///\r\n-/// ## Relationship to [AnimatedWidget]s\r\n-///\r\n-/// [ImplicitlyAnimatedWidget]s (and their subclasses) automatically animate\r\n-/// changes in their properties whenever they change. For this,\r\n-/// they create and manage their own internal [AnimationController]s to power\r\n-/// the animation. While these widgets are simple to use and don't require you\r\n-/// to manually manage the lifecycle of an [AnimationController], they\r\n-/// are also somewhat limited: Besides the target value for the animated\r\n-/// property, developers can only choose a [duration] and [curve] for the\r\n-/// animation. If you require more control over the animation (e.g. you want\r\n-/// to stop it somewhere in the middle), consider using an\r\n-/// [AnimatedWidget] or one of its subclasses. These widgets take an [Animation]\r\n-/// as an argument to power the animation. This gives the developer full control\r\n-/// over the animation at the cost of requiring you to manually manage the\r\n-/// underlying [AnimationController].\r\n-///\r\n-/// ## Common implicitly animated widgets\r\n-///\r\n-/// A number of implicitly animated widgets ship with the framework. They are\r\n-/// usually named `AnimatedFoo`, where `Foo` is the name of the non-animated\r\n-/// version of that widget. Commonly used implicitly animated widgets include:\r\n-///\r\n-///  * [TweenAnimationBuilder], which animates any property expressed by\r\n-///    a [Tween] to a specified target value.\r\n-///  * [AnimatedAlign], which is an implicitly animated version of [Align].\r\n-///  * [AnimatedContainer], which is an implicitly animated version of\r\n-///    [Container].\r\n-///  * [AnimatedDefaultTextStyle], which is an implicitly animated version of\r\n-///    [DefaultTextStyle].\r\n-///  * [AnimatedScale], which is an implicitly animated version of [Transform.scale].\r\n-///  * [AnimatedRotation], which is an implicitly animated version of [Transform.rotate].\r\n-///  * [AnimatedSlide], which implicitly animates the position of a widget relative to its normal position.\r\n-///  * [AnimatedOpacity], which is an implicitly animated version of [Opacity].\r\n-///  * [AnimatedPadding], which is an implicitly animated version of [Padding].\r\n-///  * [AnimatedPhysicalModel], which is an implicitly animated version of\r\n-///    [PhysicalModel].\r\n-///  * [AnimatedPositioned], which is an implicitly animated version of\r\n-///    [Positioned].\r\n-///  * [AnimatedPositionedDirectional], which is an implicitly animated version\r\n-///    of [PositionedDirectional].\r\n-///  * [AnimatedTheme], which is an implicitly animated version of [Theme].\r\n-///  * [AnimatedCrossFade], which cross-fades between two given children and\r\n-///    animates itself between their sizes.\r\n-///  * [AnimatedSize], which automatically transitions its size over a given\r\n-///    duration.\r\n-///  * [AnimatedSwitcher], which fades from one widget to another.\r\n-abstract class ImplicitlyAnimatedWidget extends StatefulWidget {\r\n-  /// Initializes fields for subclasses.\r\n-  const ImplicitlyAnimatedWidget({\r\n-    super.key,\r\n-    this.curve = Curves.linear,\r\n-    required this.duration,\r\n-    this.onEnd,\r\n-  });\r\n-\r\n-  /// The curve to apply when animating the parameters of this container.\r\n-  final Curve curve;\r\n-\r\n-  /// The duration over which to animate the parameters of this container.\r\n-  final Duration duration;\r\n-\r\n-  /// Called every time an animation completes.\r\n-  ///\r\n-  /// This can be useful to trigger additional actions (e.g. another animation)\r\n-  /// at the end of the current animation.\r\n-  final VoidCallback? onEnd;\r\n-\r\n-  @override\r\n-  ImplicitlyAnimatedWidgetState<ImplicitlyAnimatedWidget> createState();\r\n-\r\n-  @override\r\n-  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\r\n-    super.debugFillProperties(properties);\r\n-    properties.add(IntProperty('duration', duration.inMilliseconds, unit: 'ms'));\r\n-  }\r\n-}\r\n-/// A base class for the `State` of widgets with implicit animations.\r\n-///\r\n-/// [ListenableImplicitlyAnimatedWidgetState] requires that subclasses respond to the\r\n-/// animation themselves. If you would like `setState()` to be called\r\n-/// automatically as the animation changes, use [ListenableAnimatedWidgetBaseState].\r\n-///\r\n-/// Properties that subclasses choose to animate are represented by [Tween]\r\n-/// instances. Subclasses must implement the [forEachTween] method to allow\r\n-/// [ListenableImplicitlyAnimatedWidgetState] to iterate through the widget's fields and\r\n-/// animate them.\r\n-abstract class ListenableImplicitlyAnimatedWidgetState<T extends ImplicitlyAnimatedWidget> extends State<T>\r\n-    with SingleTickerProviderStateMixin<T> {\r\n-  /// The animation controller driving this widget's implicit animations.\r\n-  @protected\r\n-  AnimationController get controller => _controller;\r\n-  late final AnimationController _controller = AnimationController(\r\n-    duration: widget.duration,\r\n-    debugLabel: kDebugMode ? widget.toStringShort() : null,\r\n-    vsync: this,\r\n-  );\r\n-\r\n-  /// The animation driving this widget's implicit animations.\r\n-  Animation<double> get animation => _animation;\r\n-  late CurvedAnimation _animation = _createCurve();\r\n-\r\n-  @override\r\n-  void initState() {\r\n-    super.initState();\r\n-    _controller.addStatusListener((status) {\r\n-      switch (status) {\r\n-        case AnimationStatus.completed:\r\n-          widget.onEnd?.call();\r\n-        case AnimationStatus.dismissed:\r\n-        case AnimationStatus.forward:\r\n-        case AnimationStatus.reverse:\r\n-      }\r\n-    });\r\n-    _constructTweens();\r\n-    didUpdateTweens();\r\n-  }\r\n-\r\n-  @override\r\n-  void didUpdateWidget(T oldWidget) {\r\n-    super.didUpdateWidget(oldWidget);\r\n-    if (widget.curve != oldWidget.curve) {\r\n-      _animation.dispose();\r\n-      _animation = _createCurve();\r\n-    }\r\n-    _controller.duration = widget.duration;\r\n-    if (_constructTweens()) {\r\n-      forEachTween((tween, dynamic targetValue, constructor) {\r\n-        _updateTween(tween, targetValue);\r\n-        return tween;\r\n-      });\r\n-      _controller\r\n-        ..value = 0.0\r\n-        ..forward();\r\n-      didUpdateTweens();\r\n-    }\r\n-  }\r\n-\r\n-  CurvedAnimation _createCurve() {\r\n-    return CurvedAnimation(parent: _controller, curve: widget.curve);\r\n-  }\r\n-\r\n-  @override\r\n-  void dispose() {\r\n-    _animation.dispose();\r\n-    _controller.dispose();\r\n-    super.dispose();\r\n-  }\r\n-\r\n-  bool _shouldAnimateTween(Tween<dynamic> tween, dynamic targetValue) {\r\n-    return targetValue != (tween.end ?? tween.begin);\r\n-  }\r\n-\r\n-  void _updateTween(Tween<dynamic>? tween, dynamic targetValue) {\r\n-    if (tween == null) {\r\n-      return;\r\n-    }\r\n-    tween\r\n-      ..begin = tween.evaluate(_animation)\r\n-      ..end = targetValue;\r\n-  }\r\n-\r\n-  bool _constructTweens() {\r\n-    var shouldStartAnimation = false;\r\n-    forEachTween((tween, dynamic targetValue, constructor) {\r\n-      if (targetValue != null) {\r\n-        tween ??= constructor(targetValue);\r\n-        if (_shouldAnimateTween(tween, targetValue)) {\r\n-          shouldStartAnimation = true;\r\n-        } else {\r\n-          tween.end ??= tween.begin;\r\n-        }\r\n-      } else {\r\n-        tween = null;\r\n-      }\r\n-      return tween;\r\n-    });\r\n-    return shouldStartAnimation;\r\n-  }\r\n-\r\n-  /// Visits each tween controlled by this state with the specified `visitor`\r\n-  /// function.\r\n-  ///\r\n-  /// ### Subclass responsibility\r\n-  ///\r\n-  /// Properties to be animated are represented by [Tween] member variables in\r\n-  /// the state. For each such tween, [forEachTween] implementations are\r\n-  /// expected to call `visitor` with the appropriate arguments and store the\r\n-  /// result back into the member variable. The arguments to `visitor` are as\r\n-  /// follows:\r\n-  ///\r\n-  /// {@macro flutter.widgets.TweenVisitor.arguments}\r\n-  ///\r\n-  /// ### When this method will be called\r\n-  ///\r\n-  /// [forEachTween] is initially called during [initState]. It is expected that\r\n-  /// the visitor's `tween` argument will be set to null, causing the visitor to\r\n-  /// call its `constructor` argument to construct the tween for the first time.\r\n-  /// The resulting tween will have its `begin` value set to the target value\r\n-  /// and will have its `end` value set to null. The animation will not be\r\n-  /// started.\r\n-  ///\r\n-  /// When this state's [widget] is updated (thus triggering the\r\n-  /// [didUpdateWidget] method to be called), [forEachTween] will be called\r\n-  /// again to check if the target value has changed. If the target value has\r\n-  /// changed, signaling that the [animation] should start, then the visitor\r\n-  /// will update the tween's `start` and `end` values accordingly, and the\r\n-  /// animation will be started.\r\n-  ///\r\n-  /// ### Other member variables\r\n-  ///\r\n-  /// Subclasses that contain properties based on tweens created by\r\n-  /// [forEachTween] should override [didUpdateTweens] to update those\r\n-  /// properties. Dependent properties should not be updated within\r\n-  /// [forEachTween].\r\n-  ///\r\n-  /// {@tool snippet}\r\n-  ///\r\n-  /// This sample implements an implicitly animated widget's `State`.\r\n-  /// The widget animates between colors whenever `widget.targetColor`\r\n-  /// changes.\r\n-  ///\r\n-  /// ```dart\r\n-  /// class MyWidgetState extends AnimatedWidgetBaseState<MyWidget> {\r\n-  ///   ColorTween? _colorTween;\r\n-  ///\r\n-  ///   @override\r\n-  ///   Widget build(BuildContext context) {\r\n-  ///     return Text(\r\n-  ///       'Hello World',\r\n-  ///       // Computes the value of the text color at any given time.\r\n-  ///       style: TextStyle(color: _colorTween?.evaluate(animation)),\r\n-  ///     );\r\n-  ///   }\r\n-  ///\r\n-  ///   @override\r\n-  ///   void forEachTween(TweenVisitor<dynamic> visitor) {\r\n-  ///     // Update the tween using the provided visitor function.\r\n-  ///     _colorTween = visitor(\r\n-  ///       // The latest tween value. Can be `null`.\r\n-  ///       _colorTween,\r\n-  ///       // The color value toward which we are animating.\r\n-  ///       widget.targetColor,\r\n-  ///       // A function that takes a color value and returns a tween\r\n-  ///       // beginning at that value.\r\n-  ///       (dynamic value) => ColorTween(begin: value as Color?),\r\n-  ///     ) as ColorTween?;\r\n-  ///\r\n-  ///     // We could have more tweens than one by using the visitor\r\n-  ///     // multiple times.\r\n-  ///   }\r\n-  /// }\r\n-  /// ```\r\n-  /// {@end-tool}\r\n-  @protected\r\n-  void forEachTween(TweenVisitor<dynamic> visitor);\r\n-\r\n-  /// Optional hook for subclasses that runs after all tweens have been updated\r\n-  /// via [forEachTween].\r\n-  ///\r\n-  /// Any properties that depend upon tweens created by [forEachTween] should be\r\n-  /// updated within [didUpdateTweens], not within [forEachTween].\r\n-  ///\r\n-  /// This method will be called both:\r\n-  ///\r\n-  ///  1. After the tweens are _initially_ constructed (by\r\n-  ///     the `constructor` argument to the [TweenVisitor] that's passed to\r\n-  ///     [forEachTween]). In this case, the tweens are likely to contain only\r\n-  ///     a [Tween.begin] value and not a [Tween.end].\r\n-  ///\r\n-  ///  2. When the state's [widget] is updated, and one or more of the tweens\r\n-  ///     visited by [forEachTween] specifies a target value that's different\r\n-  ///     than the widget's current value, thus signaling that the [animation]\r\n-  ///     should run. In this case, the [Tween.begin] value for each tween will\r\n-  ///     an evaluation of the tween against the current [animation], and the\r\n-  ///     [Tween.end] value for each tween will be the target value.\r\n-  @protected\r\n-  void didUpdateTweens() {}\r\n-}\r\n-\r\n-abstract class ListenableAnimatedWidgetBaseState<T extends ImplicitlyAnimatedWidget>\r\n-    extends ListenableImplicitlyAnimatedWidgetState<T> {\r\n-  @override\r\n-  void initState() {\r\n-    super.initState();\r\n-    controller.addListener(_handleAnimationChanged);\r\n-  }\r\n-\r\n-  void _handleAnimationChanged() {\r\n-    setState(() {/* The animation ticked. Rebuild with new animation value */});\r\n-  }\r\n-}\r\n"
                },
                {
                    "date": 1698817760792,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -65,8 +65,9 @@\n     required this.duration,\r\n     super.key,\r\n     this.curve = Curves.linear,\r\n     this.onForward,\r\n+    this.onReverse,\r\n     this.onEnd,\r\n   });\r\n \r\n   /// The curve to apply when animating the parameters of this container.\r\n@@ -83,8 +84,14 @@\n \r\n   /// Called every time an animation starts.\r\n   final VoidCallback? onForward;\r\n \r\n+  /// Called every time an animation reverses.\r\n+  final VoidCallback? onReverse;\r\n+\r\n+  /// Called every time an animation dismisses.\r\n+  final VoidCallback? onDismiss;\r\n+\r\n   @override\r\n   ListenableImplicitlyAnimatedWidgetState<ListenableImplicitlyAnimatedWidget> createState();\r\n \r\n   @override\r\n"
                },
                {
                    "date": 1698817801014,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -66,8 +66,9 @@\n     super.key,\r\n     this.curve = Curves.linear,\r\n     this.onForward,\r\n     this.onReverse,\r\n+    this.onDismiss,\r\n     this.onEnd,\r\n   });\r\n \r\n   /// The curve to apply when animating the parameters of this container.\r\n@@ -110,9 +111,9 @@\n /// Properties that subclasses choose to animate are represented by [Tween]\r\n /// instances. Subclasses must implement the [forEachTween] method to allow\r\n /// [ListenableImplicitlyAnimatedWidgetState] to iterate through the widget's fields and\r\n /// animate them.\r\n-abstract class ListenableImplicitlyAnimatedWidgetState<T extends ListenableImplicitlyAnimatedWidget> extends State<T>\r\n+ class ListenableImplicitlyAnimatedWidgetState<T extends ListenableImplicitlyAnimatedWidget> extends State<T>\r\n     with SingleTickerProviderStateMixin<T> {\r\n   /// The animation controller driving this widget's implicit animations.\r\n   @protected\r\n   AnimationController get controller => _controller;\r\n@@ -133,10 +134,13 @@\n       switch (status) {\r\n         case AnimationStatus.completed:\r\n           widget.onEnd?.call();\r\n         case AnimationStatus.dismissed:\r\n+          widget.onDismiss?.call();\r\n         case AnimationStatus.forward:\r\n+          widget.onForward?.call();\r\n         case AnimationStatus.reverse:\r\n+          widget.onReverse?.call();\r\n       }\r\n     });\r\n     _constructTweens();\r\n     didUpdateTweens();\r\n"
                },
                {
                    "date": 1698817895555,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,322 @@\n+import \"package:flutter/foundation.dart\";\r\n+import \"package:flutter/material.dart\";\r\n+\r\n+/// An abstract class for building widgets that animate changes to their\r\n+/// properties.\r\n+///\r\n+/// Widgets of this type will not animate when they are first added to the\r\n+/// widget tree. Rather, when they are rebuilt with different values, they will\r\n+/// respond to those _changes_ by animating the changes over a specified\r\n+/// [duration].\r\n+///\r\n+/// Which properties are animated is left up to the subclass. Subclasses' [State]s\r\n+/// must extend [ImplicitlyAnimatedWidgetState] and provide a way to visit the\r\n+/// relevant fields to animate.\r\n+///\r\n+/// ## Relationship to [AnimatedWidget]s\r\n+///\r\n+/// [ImplicitlyAnimatedWidget]s (and their subclasses) automatically animate\r\n+/// changes in their properties whenever they change. For this,\r\n+/// they create and manage their own internal [AnimationController]s to power\r\n+/// the animation. While these widgets are simple to use and don't require you\r\n+/// to manually manage the lifecycle of an [AnimationController], they\r\n+/// are also somewhat limited: Besides the target value for the animated\r\n+/// property, developers can only choose a [duration] and [curve] for the\r\n+/// animation. If you require more control over the animation (e.g. you want\r\n+/// to stop it somewhere in the middle), consider using an\r\n+/// [AnimatedWidget] or one of its subclasses. These widgets take an [Animation]\r\n+/// as an argument to power the animation. This gives the developer full control\r\n+/// over the animation at the cost of requiring you to manually manage the\r\n+/// underlying [AnimationController].\r\n+///\r\n+/// ## Common implicitly animated widgets\r\n+///\r\n+/// A number of implicitly animated widgets ship with the framework. They are\r\n+/// usually named `AnimatedFoo`, where `Foo` is the name of the non-animated\r\n+/// version of that widget. Commonly used implicitly animated widgets include:\r\n+///\r\n+///  * [TweenAnimationBuilder], which animates any property expressed by\r\n+///    a [Tween] to a specified target value.\r\n+///  * [AnimatedAlign], which is an implicitly animated version of [Align].\r\n+///  * [AnimatedContainer], which is an implicitly animated version of\r\n+///    [Container].\r\n+///  * [AnimatedDefaultTextStyle], which is an implicitly animated version of\r\n+///    [DefaultTextStyle].\r\n+///  * [AnimatedScale], which is an implicitly animated version of [Transform.scale].\r\n+///  * [AnimatedRotation], which is an implicitly animated version of [Transform.rotate].\r\n+///  * [AnimatedSlide], which implicitly animates the position of a widget relative to its normal position.\r\n+///  * [AnimatedOpacity], which is an implicitly animated version of [Opacity].\r\n+///  * [AnimatedPadding], which is an implicitly animated version of [Padding].\r\n+///  * [AnimatedPhysicalModel], which is an implicitly animated version of\r\n+///    [PhysicalModel].\r\n+///  * [AnimatedPositioned], which is an implicitly animated version of\r\n+///    [Positioned].\r\n+///  * [AnimatedPositionedDirectional], which is an implicitly animated version\r\n+///    of [PositionedDirectional].\r\n+///  * [AnimatedTheme], which is an implicitly animated version of [Theme].\r\n+///  * [AnimatedCrossFade], which cross-fades between two given children and\r\n+///    animates itself between their sizes.\r\n+///  * [AnimatedSize], which automatically transitions its size over a given\r\n+///    duration.\r\n+///  * [AnimatedSwitcher], which fades from one widget to another.\r\n+abstract class ListenableImplicitlyAnimatedWidget extends ImplicitlyAnimatedWidget {\r\n+  /// Initializes fields for subclasses.\r\n+  const ListenableImplicitlyAnimatedWidget({\r\n+    required this.duration,\r\n+    super.key,\r\n+    this.curve = Curves.linear,\r\n+    this.onForward,\r\n+    this.onReverse,\r\n+    this.onDismiss,\r\n+    this.onEnd,\r\n+  });\r\n+\r\n+  /// The curve to apply when animating the parameters of this container.\r\n+  final Curve curve;\r\n+\r\n+  /// The duration over which to animate the parameters of this container.\r\n+  final Duration duration;\r\n+\r\n+  /// Called every time an animation completes.\r\n+  ///\r\n+  /// This can be useful to trigger additional actions (e.g. another animation)\r\n+  /// at the end of the current animation.\r\n+  final VoidCallback? onEnd;\r\n+\r\n+  /// Called every time an animation starts.\r\n+  final VoidCallback? onForward;\r\n+\r\n+  /// Called every time an animation reverses.\r\n+  final VoidCallback? onReverse;\r\n+\r\n+  /// Called every time an animation dismisses.\r\n+  final VoidCallback? onDismiss;\r\n+\r\n+  @override\r\n+  ListenableImplicitlyAnimatedWidgetState<ListenableImplicitlyAnimatedWidget> createState();\r\n+\r\n+  @override\r\n+  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\r\n+    super.debugFillProperties(properties);\r\n+    properties.add(IntProperty(\"duration\", duration.inMilliseconds, unit: \"ms\"));\r\n+  }\r\n+}\r\n+\r\n+/// A base class for the `State` of widgets with implicit animations.\r\n+///\r\n+/// [ListenableImplicitlyAnimatedWidgetState] requires that subclasses respond to the\r\n+/// animation themselves. If you would like `setState()` to be called\r\n+/// automatically as the animation changes, use [ListenableAnimatedWidgetBaseState].\r\n+///\r\n+/// Properties that subclasses choose to animate are represented by [Tween]\r\n+/// instances. Subclasses must implement the [forEachTween] method to allow\r\n+/// [ListenableImplicitlyAnimatedWidgetState] to iterate through the widget's fields and\r\n+/// animate them.\r\n+abstract base class ListenableImplicitlyAnimatedWidgetState<T extends ListenableImplicitlyAnimatedWidget>\r\n+    extends State<T> with SingleTickerProviderStateMixin<T> {\r\n+  /// The animation controller driving this widget's implicit animations.\r\n+  @protected\r\n+  AnimationController get controller => _controller;\r\n+  late final AnimationController _controller = AnimationController(\r\n+    duration: widget.duration,\r\n+    debugLabel: kDebugMode ? widget.toStringShort() : null,\r\n+    vsync: this,\r\n+  );\r\n+\r\n+  /// The animation driving this widget's implicit animations.\r\n+  Animation<double> get animation => _animation;\r\n+  late CurvedAnimation _animation = _createCurve();\r\n+\r\n+  @override\r\n+  void initState() {\r\n+    super.initState();\r\n+    _controller.addStatusListener((status) {\r\n+      switch (status) {\r\n+        case AnimationStatus.completed:\r\n+          widget.onEnd?.call();\r\n+        case AnimationStatus.dismissed:\r\n+          widget.onDismiss?.call();\r\n+        case AnimationStatus.forward:\r\n+          widget.onForward?.call();\r\n+        case AnimationStatus.reverse:\r\n+          widget.onReverse?.call();\r\n+      }\r\n+    });\r\n+    _constructTweens();\r\n+    didUpdateTweens();\r\n+  }\r\n+\r\n+  @override\r\n+  void didUpdateWidget(T oldWidget) {\r\n+    super.didUpdateWidget(oldWidget);\r\n+    if (widget.curve != oldWidget.curve) {\r\n+      _animation.dispose();\r\n+      _animation = _createCurve();\r\n+    }\r\n+    _controller.duration = widget.duration;\r\n+    if (_constructTweens()) {\r\n+      forEachTween((tween, dynamic targetValue, constructor) {\r\n+        _updateTween(tween, targetValue);\r\n+        return tween;\r\n+      });\r\n+      _controller\r\n+        ..value = 0.0\r\n+        ..forward();\r\n+      didUpdateTweens();\r\n+    }\r\n+  }\r\n+\r\n+  CurvedAnimation _createCurve() {\r\n+    return CurvedAnimation(parent: _controller, curve: widget.curve);\r\n+  }\r\n+\r\n+  @override\r\n+  void dispose() {\r\n+    _animation.dispose();\r\n+    _controller.dispose();\r\n+    super.dispose();\r\n+  }\r\n+\r\n+  bool _shouldAnimateTween(Tween<dynamic> tween, dynamic targetValue) {\r\n+    return targetValue != (tween.end ?? tween.begin);\r\n+  }\r\n+\r\n+  void _updateTween(Tween<dynamic>? tween, dynamic targetValue) {\r\n+    if (tween == null) {\r\n+      return;\r\n+    }\r\n+    tween\r\n+      ..begin = tween.evaluate(_animation)\r\n+      ..end = targetValue;\r\n+  }\r\n+\r\n+  bool _constructTweens() {\r\n+    var shouldStartAnimation = false;\r\n+    forEachTween((tween, dynamic targetValue, constructor) {\r\n+      if (targetValue != null) {\r\n+        tween ??= constructor(targetValue);\r\n+        if (_shouldAnimateTween(tween, targetValue)) {\r\n+          shouldStartAnimation = true;\r\n+        } else {\r\n+          tween.end ??= tween.begin;\r\n+        }\r\n+      } else {\r\n+        tween = null;\r\n+      }\r\n+      return tween;\r\n+    });\r\n+    return shouldStartAnimation;\r\n+  }\r\n+\r\n+  /// Visits each tween controlled by this state with the specified `visitor`\r\n+  /// function.\r\n+  ///\r\n+  /// ### Subclass responsibility\r\n+  ///\r\n+  /// Properties to be animated are represented by [Tween] member variables in\r\n+  /// the state. For each such tween, [forEachTween] implementations are\r\n+  /// expected to call `visitor` with the appropriate arguments and store the\r\n+  /// result back into the member variable. The arguments to `visitor` are as\r\n+  /// follows:\r\n+  ///\r\n+  /// {@macro flutter.widgets.TweenVisitor.arguments}\r\n+  ///\r\n+  /// ### When this method will be called\r\n+  ///\r\n+  /// [forEachTween] is initially called during [initState]. It is expected that\r\n+  /// the visitor's `tween` argument will be set to null, causing the visitor to\r\n+  /// call its `constructor` argument to construct the tween for the first time.\r\n+  /// The resulting tween will have its `begin` value set to the target value\r\n+  /// and will have its `end` value set to null. The animation will not be\r\n+  /// started.\r\n+  ///\r\n+  /// When this state's [widget] is updated (thus triggering the\r\n+  /// [didUpdateWidget] method to be called), [forEachTween] will be called\r\n+  /// again to check if the target value has changed. If the target value has\r\n+  /// changed, signaling that the [animation] should start, then the visitor\r\n+  /// will update the tween's `start` and `end` values accordingly, and the\r\n+  /// animation will be started.\r\n+  ///\r\n+  /// ### Other member variables\r\n+  ///\r\n+  /// Subclasses that contain properties based on tweens created by\r\n+  /// [forEachTween] should override [didUpdateTweens] to update those\r\n+  /// properties. Dependent properties should not be updated within\r\n+  /// [forEachTween].\r\n+  ///\r\n+  /// {@tool snippet}\r\n+  ///\r\n+  /// This sample implements an implicitly animated widget's `State`.\r\n+  /// The widget animates between colors whenever `widget.targetColor`\r\n+  /// changes.\r\n+  ///\r\n+  /// ```dart\r\n+  /// class MyWidgetState extends AnimatedWidgetBaseState<MyWidget> {\r\n+  ///   ColorTween? _colorTween;\r\n+  ///\r\n+  ///   @override\r\n+  ///   Widget build(BuildContext context) {\r\n+  ///     return Text(\r\n+  ///       'Hello World',\r\n+  ///       // Computes the value of the text color at any given time.\r\n+  ///       style: TextStyle(color: _colorTween?.evaluate(animation)),\r\n+  ///     );\r\n+  ///   }\r\n+  ///\r\n+  ///   @override\r\n+  ///   void forEachTween(TweenVisitor<dynamic> visitor) {\r\n+  ///     // Update the tween using the provided visitor function.\r\n+  ///     _colorTween = visitor(\r\n+  ///       // The latest tween value. Can be `null`.\r\n+  ///       _colorTween,\r\n+  ///       // The color value toward which we are animating.\r\n+  ///       widget.targetColor,\r\n+  ///       // A function that takes a color value and returns a tween\r\n+  ///       // beginning at that value.\r\n+  ///       (dynamic value) => ColorTween(begin: value as Color?),\r\n+  ///     ) as ColorTween?;\r\n+  ///\r\n+  ///     // We could have more tweens than one by using the visitor\r\n+  ///     // multiple times.\r\n+  ///   }\r\n+  /// }\r\n+  /// ```\r\n+  /// {@end-tool}\r\n+  @protected\r\n+  void forEachTween(TweenVisitor<dynamic> visitor);\r\n+\r\n+  /// Optional hook for subclasses that runs after all tweens have been updated\r\n+  /// via [forEachTween].\r\n+  ///\r\n+  /// Any properties that depend upon tweens created by [forEachTween] should be\r\n+  /// updated within [didUpdateTweens], not within [forEachTween].\r\n+  ///\r\n+  /// This method will be called both:\r\n+  ///\r\n+  ///  1. After the tweens are _initially_ constructed (by\r\n+  ///     the `constructor` argument to the [TweenVisitor] that's passed to\r\n+  ///     [forEachTween]). In this case, the tweens are likely to contain only\r\n+  ///     a [Tween.begin] value and not a [Tween.end].\r\n+  ///\r\n+  ///  2. When the state's [widget] is updated, and one or more of the tweens\r\n+  ///     visited by [forEachTween] specifies a target value that's different\r\n+  ///     than the widget's current value, thus signaling that the [animation]\r\n+  ///     should run. In this case, the [Tween.begin] value for each tween will\r\n+  ///     an evaluation of the tween against the current [animation], and the\r\n+  ///     [Tween.end] value for each tween will be the target value.\r\n+  @protected\r\n+  void didUpdateTweens() {}\r\n+}\r\n+\r\n+abstract base class ListenableAnimatedWidgetBaseState<T extends ListenableImplicitlyAnimatedWidget>\r\n+    extends ListenableImplicitlyAnimatedWidgetState<T> {\r\n+  @override\r\n+  void initState() {\r\n+    super.initState();\r\n+    controller.addListener(_handleAnimationChanged);\r\n+  }\r\n+\r\n+  void _handleAnimationChanged() {\r\n+    setState(() {/* The animation ticked. Rebuild with new animation value */});\r\n+  }\r\n+}\r\n"
                },
                {
                    "date": 1698817944950,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -61,29 +61,17 @@\n ///  * [AnimatedSwitcher], which fades from one widget to another.\r\n abstract class ListenableImplicitlyAnimatedWidget extends ImplicitlyAnimatedWidget {\r\n   /// Initializes fields for subclasses.\r\n   const ListenableImplicitlyAnimatedWidget({\r\n-    required this.duration,\r\n+    required super.duration,\r\n     super.key,\r\n-    this.curve = Curves.linear,\r\n+    super.curve = Curves.linear,\r\n     this.onForward,\r\n     this.onReverse,\r\n     this.onDismiss,\r\n-    this.onEnd,\r\n-  });\r\n+    super.onEnd,\r\n+  }) : super();\r\n \r\n-  /// The curve to apply when animating the parameters of this container.\r\n-  final Curve curve;\r\n-\r\n-  /// The duration over which to animate the parameters of this container.\r\n-  final Duration duration;\r\n-\r\n-  /// Called every time an animation completes.\r\n-  ///\r\n-  /// This can be useful to trigger additional actions (e.g. another animation)\r\n-  /// at the end of the current animation.\r\n-  final VoidCallback? onEnd;\r\n-\r\n   /// Called every time an animation starts.\r\n   final VoidCallback? onForward;\r\n \r\n   /// Called every time an animation reverses.\r\n@@ -112,9 +100,9 @@\n /// instances. Subclasses must implement the [forEachTween] method to allow\r\n /// [ListenableImplicitlyAnimatedWidgetState] to iterate through the widget's fields and\r\n /// animate them.\r\n abstract base class ListenableImplicitlyAnimatedWidgetState<T extends ListenableImplicitlyAnimatedWidget>\r\n-    extends State<T> with SingleTickerProviderStateMixin<T> {\r\n+    extends ListenableImplicitlyAnimatedWidgetState<T> with SingleTickerProviderStateMixin<T> {\r\n   /// The animation controller driving this widget's implicit animations.\r\n   @protected\r\n   AnimationController get controller => _controller;\r\n   late final AnimationController _controller = AnimationController(\r\n@@ -319,326 +307,4 @@\n   void _handleAnimationChanged() {\r\n     setState(() {/* The animation ticked. Rebuild with new animation value */});\r\n   }\r\n }\r\n-import \"package:flutter/foundation.dart\";\r\n-import \"package:flutter/material.dart\";\r\n-\r\n-/// An abstract class for building widgets that animate changes to their\r\n-/// properties.\r\n-///\r\n-/// Widgets of this type will not animate when they are first added to the\r\n-/// widget tree. Rather, when they are rebuilt with different values, they will\r\n-/// respond to those _changes_ by animating the changes over a specified\r\n-/// [duration].\r\n-///\r\n-/// Which properties are animated is left up to the subclass. Subclasses' [State]s\r\n-/// must extend [ImplicitlyAnimatedWidgetState] and provide a way to visit the\r\n-/// relevant fields to animate.\r\n-///\r\n-/// ## Relationship to [AnimatedWidget]s\r\n-///\r\n-/// [ImplicitlyAnimatedWidget]s (and their subclasses) automatically animate\r\n-/// changes in their properties whenever they change. For this,\r\n-/// they create and manage their own internal [AnimationController]s to power\r\n-/// the animation. While these widgets are simple to use and don't require you\r\n-/// to manually manage the lifecycle of an [AnimationController], they\r\n-/// are also somewhat limited: Besides the target value for the animated\r\n-/// property, developers can only choose a [duration] and [curve] for the\r\n-/// animation. If you require more control over the animation (e.g. you want\r\n-/// to stop it somewhere in the middle), consider using an\r\n-/// [AnimatedWidget] or one of its subclasses. These widgets take an [Animation]\r\n-/// as an argument to power the animation. This gives the developer full control\r\n-/// over the animation at the cost of requiring you to manually manage the\r\n-/// underlying [AnimationController].\r\n-///\r\n-/// ## Common implicitly animated widgets\r\n-///\r\n-/// A number of implicitly animated widgets ship with the framework. They are\r\n-/// usually named `AnimatedFoo`, where `Foo` is the name of the non-animated\r\n-/// version of that widget. Commonly used implicitly animated widgets include:\r\n-///\r\n-///  * [TweenAnimationBuilder], which animates any property expressed by\r\n-///    a [Tween] to a specified target value.\r\n-///  * [AnimatedAlign], which is an implicitly animated version of [Align].\r\n-///  * [AnimatedContainer], which is an implicitly animated version of\r\n-///    [Container].\r\n-///  * [AnimatedDefaultTextStyle], which is an implicitly animated version of\r\n-///    [DefaultTextStyle].\r\n-///  * [AnimatedScale], which is an implicitly animated version of [Transform.scale].\r\n-///  * [AnimatedRotation], which is an implicitly animated version of [Transform.rotate].\r\n-///  * [AnimatedSlide], which implicitly animates the position of a widget relative to its normal position.\r\n-///  * [AnimatedOpacity], which is an implicitly animated version of [Opacity].\r\n-///  * [AnimatedPadding], which is an implicitly animated version of [Padding].\r\n-///  * [AnimatedPhysicalModel], which is an implicitly animated version of\r\n-///    [PhysicalModel].\r\n-///  * [AnimatedPositioned], which is an implicitly animated version of\r\n-///    [Positioned].\r\n-///  * [AnimatedPositionedDirectional], which is an implicitly animated version\r\n-///    of [PositionedDirectional].\r\n-///  * [AnimatedTheme], which is an implicitly animated version of [Theme].\r\n-///  * [AnimatedCrossFade], which cross-fades between two given children and\r\n-///    animates itself between their sizes.\r\n-///  * [AnimatedSize], which automatically transitions its size over a given\r\n-///    duration.\r\n-///  * [AnimatedSwitcher], which fades from one widget to another.\r\n-abstract class ListenableImplicitlyAnimatedWidget extends StatefulWidget {\r\n-  /// Initializes fields for subclasses.\r\n-  const ListenableImplicitlyAnimatedWidget({\r\n-    required this.duration,\r\n-    super.key,\r\n-    this.curve = Curves.linear,\r\n-    this.onForward,\r\n-    this.onReverse,\r\n-    this.onDismiss,\r\n-    this.onEnd,\r\n-  });\r\n-\r\n-  /// The curve to apply when animating the parameters of this container.\r\n-  final Curve curve;\r\n-\r\n-  /// The duration over which to animate the parameters of this container.\r\n-  final Duration duration;\r\n-\r\n-  /// Called every time an animation completes.\r\n-  ///\r\n-  /// This can be useful to trigger additional actions (e.g. another animation)\r\n-  /// at the end of the current animation.\r\n-  final VoidCallback? onEnd;\r\n-\r\n-  /// Called every time an animation starts.\r\n-  final VoidCallback? onForward;\r\n-\r\n-  /// Called every time an animation reverses.\r\n-  final VoidCallback? onReverse;\r\n-\r\n-  /// Called every time an animation dismisses.\r\n-  final VoidCallback? onDismiss;\r\n-\r\n-  @override\r\n-  ListenableImplicitlyAnimatedWidgetState<ListenableImplicitlyAnimatedWidget> createState();\r\n-\r\n-  @override\r\n-  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\r\n-    super.debugFillProperties(properties);\r\n-    properties.add(IntProperty(\"duration\", duration.inMilliseconds, unit: \"ms\"));\r\n-  }\r\n-}\r\n-\r\n-/// A base class for the `State` of widgets with implicit animations.\r\n-///\r\n-/// [ListenableImplicitlyAnimatedWidgetState] requires that subclasses respond to the\r\n-/// animation themselves. If you would like `setState()` to be called\r\n-/// automatically as the animation changes, use [ListenableAnimatedWidgetBaseState].\r\n-///\r\n-/// Properties that subclasses choose to animate are represented by [Tween]\r\n-/// instances. Subclasses must implement the [forEachTween] method to allow\r\n-/// [ListenableImplicitlyAnimatedWidgetState] to iterate through the widget's fields and\r\n-/// animate them.\r\n- class ListenableImplicitlyAnimatedWidgetState<T extends ListenableImplicitlyAnimatedWidget> extends State<T>\r\n-    with SingleTickerProviderStateMixin<T> {\r\n-  /// The animation controller driving this widget's implicit animations.\r\n-  @protected\r\n-  AnimationController get controller => _controller;\r\n-  late final AnimationController _controller = AnimationController(\r\n-    duration: widget.duration,\r\n-    debugLabel: kDebugMode ? widget.toStringShort() : null,\r\n-    vsync: this,\r\n-  );\r\n-\r\n-  /// The animation driving this widget's implicit animations.\r\n-  Animation<double> get animation => _animation;\r\n-  late CurvedAnimation _animation = _createCurve();\r\n-\r\n-  @override\r\n-  void initState() {\r\n-    super.initState();\r\n-    _controller.addStatusListener((status) {\r\n-      switch (status) {\r\n-        case AnimationStatus.completed:\r\n-          widget.onEnd?.call();\r\n-        case AnimationStatus.dismissed:\r\n-          widget.onDismiss?.call();\r\n-        case AnimationStatus.forward:\r\n-          widget.onForward?.call();\r\n-        case AnimationStatus.reverse:\r\n-          widget.onReverse?.call();\r\n-      }\r\n-    });\r\n-    _constructTweens();\r\n-    didUpdateTweens();\r\n-  }\r\n-\r\n-  @override\r\n-  void didUpdateWidget(T oldWidget) {\r\n-    super.didUpdateWidget(oldWidget);\r\n-    if (widget.curve != oldWidget.curve) {\r\n-      _animation.dispose();\r\n-      _animation = _createCurve();\r\n-    }\r\n-    _controller.duration = widget.duration;\r\n-    if (_constructTweens()) {\r\n-      forEachTween((tween, dynamic targetValue, constructor) {\r\n-        _updateTween(tween, targetValue);\r\n-        return tween;\r\n-      });\r\n-      _controller\r\n-        ..value = 0.0\r\n-        ..forward();\r\n-      didUpdateTweens();\r\n-    }\r\n-  }\r\n-\r\n-  CurvedAnimation _createCurve() {\r\n-    return CurvedAnimation(parent: _controller, curve: widget.curve);\r\n-  }\r\n-\r\n-  @override\r\n-  void dispose() {\r\n-    _animation.dispose();\r\n-    _controller.dispose();\r\n-    super.dispose();\r\n-  }\r\n-\r\n-  bool _shouldAnimateTween(Tween<dynamic> tween, dynamic targetValue) {\r\n-    return targetValue != (tween.end ?? tween.begin);\r\n-  }\r\n-\r\n-  void _updateTween(Tween<dynamic>? tween, dynamic targetValue) {\r\n-    if (tween == null) {\r\n-      return;\r\n-    }\r\n-    tween\r\n-      ..begin = tween.evaluate(_animation)\r\n-      ..end = targetValue;\r\n-  }\r\n-\r\n-  bool _constructTweens() {\r\n-    var shouldStartAnimation = false;\r\n-    forEachTween((tween, dynamic targetValue, constructor) {\r\n-      if (targetValue != null) {\r\n-        tween ??= constructor(targetValue);\r\n-        if (_shouldAnimateTween(tween, targetValue)) {\r\n-          shouldStartAnimation = true;\r\n-        } else {\r\n-          tween.end ??= tween.begin;\r\n-        }\r\n-      } else {\r\n-        tween = null;\r\n-      }\r\n-      return tween;\r\n-    });\r\n-    return shouldStartAnimation;\r\n-  }\r\n-\r\n-  /// Visits each tween controlled by this state with the specified `visitor`\r\n-  /// function.\r\n-  ///\r\n-  /// ### Subclass responsibility\r\n-  ///\r\n-  /// Properties to be animated are represented by [Tween] member variables in\r\n-  /// the state. For each such tween, [forEachTween] implementations are\r\n-  /// expected to call `visitor` with the appropriate arguments and store the\r\n-  /// result back into the member variable. The arguments to `visitor` are as\r\n-  /// follows:\r\n-  ///\r\n-  /// {@macro flutter.widgets.TweenVisitor.arguments}\r\n-  ///\r\n-  /// ### When this method will be called\r\n-  ///\r\n-  /// [forEachTween] is initially called during [initState]. It is expected that\r\n-  /// the visitor's `tween` argument will be set to null, causing the visitor to\r\n-  /// call its `constructor` argument to construct the tween for the first time.\r\n-  /// The resulting tween will have its `begin` value set to the target value\r\n-  /// and will have its `end` value set to null. The animation will not be\r\n-  /// started.\r\n-  ///\r\n-  /// When this state's [widget] is updated (thus triggering the\r\n-  /// [didUpdateWidget] method to be called), [forEachTween] will be called\r\n-  /// again to check if the target value has changed. If the target value has\r\n-  /// changed, signaling that the [animation] should start, then the visitor\r\n-  /// will update the tween's `start` and `end` values accordingly, and the\r\n-  /// animation will be started.\r\n-  ///\r\n-  /// ### Other member variables\r\n-  ///\r\n-  /// Subclasses that contain properties based on tweens created by\r\n-  /// [forEachTween] should override [didUpdateTweens] to update those\r\n-  /// properties. Dependent properties should not be updated within\r\n-  /// [forEachTween].\r\n-  ///\r\n-  /// {@tool snippet}\r\n-  ///\r\n-  /// This sample implements an implicitly animated widget's `State`.\r\n-  /// The widget animates between colors whenever `widget.targetColor`\r\n-  /// changes.\r\n-  ///\r\n-  /// ```dart\r\n-  /// class MyWidgetState extends AnimatedWidgetBaseState<MyWidget> {\r\n-  ///   ColorTween? _colorTween;\r\n-  ///\r\n-  ///   @override\r\n-  ///   Widget build(BuildContext context) {\r\n-  ///     return Text(\r\n-  ///       'Hello World',\r\n-  ///       // Computes the value of the text color at any given time.\r\n-  ///       style: TextStyle(color: _colorTween?.evaluate(animation)),\r\n-  ///     );\r\n-  ///   }\r\n-  ///\r\n-  ///   @override\r\n-  ///   void forEachTween(TweenVisitor<dynamic> visitor) {\r\n-  ///     // Update the tween using the provided visitor function.\r\n-  ///     _colorTween = visitor(\r\n-  ///       // The latest tween value. Can be `null`.\r\n-  ///       _colorTween,\r\n-  ///       // The color value toward which we are animating.\r\n-  ///       widget.targetColor,\r\n-  ///       // A function that takes a color value and returns a tween\r\n-  ///       // beginning at that value.\r\n-  ///       (dynamic value) => ColorTween(begin: value as Color?),\r\n-  ///     ) as ColorTween?;\r\n-  ///\r\n-  ///     // We could have more tweens than one by using the visitor\r\n-  ///     // multiple times.\r\n-  ///   }\r\n-  /// }\r\n-  /// ```\r\n-  /// {@end-tool}\r\n-  @protected\r\n-  void forEachTween(TweenVisitor<dynamic> visitor);\r\n-\r\n-  /// Optional hook for subclasses that runs after all tweens have been updated\r\n-  /// via [forEachTween].\r\n-  ///\r\n-  /// Any properties that depend upon tweens created by [forEachTween] should be\r\n-  /// updated within [didUpdateTweens], not within [forEachTween].\r\n-  ///\r\n-  /// This method will be called both:\r\n-  ///\r\n-  ///  1. After the tweens are _initially_ constructed (by\r\n-  ///     the `constructor` argument to the [TweenVisitor] that's passed to\r\n-  ///     [forEachTween]). In this case, the tweens are likely to contain only\r\n-  ///     a [Tween.begin] value and not a [Tween.end].\r\n-  ///\r\n-  ///  2. When the state's [widget] is updated, and one or more of the tweens\r\n-  ///     visited by [forEachTween] specifies a target value that's different\r\n-  ///     than the widget's current value, thus signaling that the [animation]\r\n-  ///     should run. In this case, the [Tween.begin] value for each tween will\r\n-  ///     an evaluation of the tween against the current [animation], and the\r\n-  ///     [Tween.end] value for each tween will be the target value.\r\n-  @protected\r\n-  void didUpdateTweens() {}\r\n-}\r\n-\r\n-abstract class ListenableAnimatedWidgetBaseState<T extends ListenableImplicitlyAnimatedWidget>\r\n-    extends ListenableImplicitlyAnimatedWidgetState<T> {\r\n-  @override\r\n-  void initState() {\r\n-    super.initState();\r\n-    controller.addListener(_handleAnimationChanged);\r\n-  }\r\n-\r\n-  void _handleAnimationChanged() {\r\n-    setState(() {/* The animation ticked. Rebuild with new animation value */});\r\n-  }\r\n-}\r\n"
                },
                {
                    "date": 1698817980886,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -100,10 +100,11 @@\n /// instances. Subclasses must implement the [forEachTween] method to allow\r\n /// [ListenableImplicitlyAnimatedWidgetState] to iterate through the widget's fields and\r\n /// animate them.\r\n abstract base class ListenableImplicitlyAnimatedWidgetState<T extends ListenableImplicitlyAnimatedWidget>\r\n-    extends ListenableImplicitlyAnimatedWidgetState<T> with SingleTickerProviderStateMixin<T> {\r\n+    extends ImplicitlyAnimatedWidgetState<T> {\r\n   /// The animation controller driving this widget's implicit animations.\r\n+  @override\r\n   @protected\r\n   AnimationController get controller => _controller;\r\n   late final AnimationController _controller = AnimationController(\r\n     duration: widget.duration,\r\n@@ -111,15 +112,16 @@\n     vsync: this,\r\n   );\r\n \r\n   /// The animation driving this widget's implicit animations.\r\n+  @override\r\n   Animation<double> get animation => _animation;\r\n   late CurvedAnimation _animation = _createCurve();\r\n \r\n   @override\r\n   void initState() {\r\n     super.initState();\r\n-    _controller.addStatusListener((status) {\r\n+    super.controller.addStatusListener((status) {\r\n       switch (status) {\r\n         case AnimationStatus.completed:\r\n           widget.onEnd?.call();\r\n         case AnimationStatus.dismissed:\r\n@@ -269,8 +271,9 @@\n   ///   }\r\n   /// }\r\n   /// ```\r\n   /// {@end-tool}\r\n+  @override\r\n   @protected\r\n   void forEachTween(TweenVisitor<dynamic> visitor);\r\n \r\n   /// Optional hook for subclasses that runs after all tweens have been updated\r\n@@ -291,8 +294,9 @@\n   ///     than the widget's current value, thus signaling that the [animation]\r\n   ///     should run. In this case, the [Tween.begin] value for each tween will\r\n   ///     an evaluation of the tween against the current [animation], and the\r\n   ///     [Tween.end] value for each tween will be the target value.\r\n+  @override\r\n   @protected\r\n   void didUpdateTweens() {}\r\n }\r\n \r\n"
                },
                {
                    "date": 1698818011320,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -101,27 +101,14 @@\n /// [ListenableImplicitlyAnimatedWidgetState] to iterate through the widget's fields and\r\n /// animate them.\r\n abstract base class ListenableImplicitlyAnimatedWidgetState<T extends ListenableImplicitlyAnimatedWidget>\r\n     extends ImplicitlyAnimatedWidgetState<T> {\r\n-  /// The animation controller driving this widget's implicit animations.\r\n   @override\r\n-  @protected\r\n-  AnimationController get controller => _controller;\r\n-  late final AnimationController _controller = AnimationController(\r\n-    duration: widget.duration,\r\n-    debugLabel: kDebugMode ? widget.toStringShort() : null,\r\n-    vsync: this,\r\n-  );\r\n-\r\n-  /// The animation driving this widget's implicit animations.\r\n-  @override\r\n-  Animation<double> get animation => _animation;\r\n-  late CurvedAnimation _animation = _createCurve();\r\n-\r\n-  @override\r\n   void initState() {\r\n     super.initState();\r\n+\r\n     super.controller.addStatusListener((status) {\r\n+      \r\n       switch (status) {\r\n         case AnimationStatus.completed:\r\n           widget.onEnd?.call();\r\n         case AnimationStatus.dismissed:\r\n@@ -131,174 +118,9 @@\n         case AnimationStatus.reverse:\r\n           widget.onReverse?.call();\r\n       }\r\n     });\r\n-    _constructTweens();\r\n-    didUpdateTweens();\r\n   }\r\n-\r\n-  @override\r\n-  void didUpdateWidget(T oldWidget) {\r\n-    super.didUpdateWidget(oldWidget);\r\n-    if (widget.curve != oldWidget.curve) {\r\n-      _animation.dispose();\r\n-      _animation = _createCurve();\r\n-    }\r\n-    _controller.duration = widget.duration;\r\n-    if (_constructTweens()) {\r\n-      forEachTween((tween, dynamic targetValue, constructor) {\r\n-        _updateTween(tween, targetValue);\r\n-        return tween;\r\n-      });\r\n-      _controller\r\n-        ..value = 0.0\r\n-        ..forward();\r\n-      didUpdateTweens();\r\n-    }\r\n-  }\r\n-\r\n-  CurvedAnimation _createCurve() {\r\n-    return CurvedAnimation(parent: _controller, curve: widget.curve);\r\n-  }\r\n-\r\n-  @override\r\n-  void dispose() {\r\n-    _animation.dispose();\r\n-    _controller.dispose();\r\n-    super.dispose();\r\n-  }\r\n-\r\n-  bool _shouldAnimateTween(Tween<dynamic> tween, dynamic targetValue) {\r\n-    return targetValue != (tween.end ?? tween.begin);\r\n-  }\r\n-\r\n-  void _updateTween(Tween<dynamic>? tween, dynamic targetValue) {\r\n-    if (tween == null) {\r\n-      return;\r\n-    }\r\n-    tween\r\n-      ..begin = tween.evaluate(_animation)\r\n-      ..end = targetValue;\r\n-  }\r\n-\r\n-  bool _constructTweens() {\r\n-    var shouldStartAnimation = false;\r\n-    forEachTween((tween, dynamic targetValue, constructor) {\r\n-      if (targetValue != null) {\r\n-        tween ??= constructor(targetValue);\r\n-        if (_shouldAnimateTween(tween, targetValue)) {\r\n-          shouldStartAnimation = true;\r\n-        } else {\r\n-          tween.end ??= tween.begin;\r\n-        }\r\n-      } else {\r\n-        tween = null;\r\n-      }\r\n-      return tween;\r\n-    });\r\n-    return shouldStartAnimation;\r\n-  }\r\n-\r\n-  /// Visits each tween controlled by this state with the specified `visitor`\r\n-  /// function.\r\n-  ///\r\n-  /// ### Subclass responsibility\r\n-  ///\r\n-  /// Properties to be animated are represented by [Tween] member variables in\r\n-  /// the state. For each such tween, [forEachTween] implementations are\r\n-  /// expected to call `visitor` with the appropriate arguments and store the\r\n-  /// result back into the member variable. The arguments to `visitor` are as\r\n-  /// follows:\r\n-  ///\r\n-  /// {@macro flutter.widgets.TweenVisitor.arguments}\r\n-  ///\r\n-  /// ### When this method will be called\r\n-  ///\r\n-  /// [forEachTween] is initially called during [initState]. It is expected that\r\n-  /// the visitor's `tween` argument will be set to null, causing the visitor to\r\n-  /// call its `constructor` argument to construct the tween for the first time.\r\n-  /// The resulting tween will have its `begin` value set to the target value\r\n-  /// and will have its `end` value set to null. The animation will not be\r\n-  /// started.\r\n-  ///\r\n-  /// When this state's [widget] is updated (thus triggering the\r\n-  /// [didUpdateWidget] method to be called), [forEachTween] will be called\r\n-  /// again to check if the target value has changed. If the target value has\r\n-  /// changed, signaling that the [animation] should start, then the visitor\r\n-  /// will update the tween's `start` and `end` values accordingly, and the\r\n-  /// animation will be started.\r\n-  ///\r\n-  /// ### Other member variables\r\n-  ///\r\n-  /// Subclasses that contain properties based on tweens created by\r\n-  /// [forEachTween] should override [didUpdateTweens] to update those\r\n-  /// properties. Dependent properties should not be updated within\r\n-  /// [forEachTween].\r\n-  ///\r\n-  /// {@tool snippet}\r\n-  ///\r\n-  /// This sample implements an implicitly animated widget's `State`.\r\n-  /// The widget animates between colors whenever `widget.targetColor`\r\n-  /// changes.\r\n-  ///\r\n-  /// ```dart\r\n-  /// class MyWidgetState extends AnimatedWidgetBaseState<MyWidget> {\r\n-  ///   ColorTween? _colorTween;\r\n-  ///\r\n-  ///   @override\r\n-  ///   Widget build(BuildContext context) {\r\n-  ///     return Text(\r\n-  ///       'Hello World',\r\n-  ///       // Computes the value of the text color at any given time.\r\n-  ///       style: TextStyle(color: _colorTween?.evaluate(animation)),\r\n-  ///     );\r\n-  ///   }\r\n-  ///\r\n-  ///   @override\r\n-  ///   void forEachTween(TweenVisitor<dynamic> visitor) {\r\n-  ///     // Update the tween using the provided visitor function.\r\n-  ///     _colorTween = visitor(\r\n-  ///       // The latest tween value. Can be `null`.\r\n-  ///       _colorTween,\r\n-  ///       // The color value toward which we are animating.\r\n-  ///       widget.targetColor,\r\n-  ///       // A function that takes a color value and returns a tween\r\n-  ///       // beginning at that value.\r\n-  ///       (dynamic value) => ColorTween(begin: value as Color?),\r\n-  ///     ) as ColorTween?;\r\n-  ///\r\n-  ///     // We could have more tweens than one by using the visitor\r\n-  ///     // multiple times.\r\n-  ///   }\r\n-  /// }\r\n-  /// ```\r\n-  /// {@end-tool}\r\n-  @override\r\n-  @protected\r\n-  void forEachTween(TweenVisitor<dynamic> visitor);\r\n-\r\n-  /// Optional hook for subclasses that runs after all tweens have been updated\r\n-  /// via [forEachTween].\r\n-  ///\r\n-  /// Any properties that depend upon tweens created by [forEachTween] should be\r\n-  /// updated within [didUpdateTweens], not within [forEachTween].\r\n-  ///\r\n-  /// This method will be called both:\r\n-  ///\r\n-  ///  1. After the tweens are _initially_ constructed (by\r\n-  ///     the `constructor` argument to the [TweenVisitor] that's passed to\r\n-  ///     [forEachTween]). In this case, the tweens are likely to contain only\r\n-  ///     a [Tween.begin] value and not a [Tween.end].\r\n-  ///\r\n-  ///  2. When the state's [widget] is updated, and one or more of the tweens\r\n-  ///     visited by [forEachTween] specifies a target value that's different\r\n-  ///     than the widget's current value, thus signaling that the [animation]\r\n-  ///     should run. In this case, the [Tween.begin] value for each tween will\r\n-  ///     an evaluation of the tween against the current [animation], and the\r\n-  ///     [Tween.end] value for each tween will be the target value.\r\n-  @override\r\n-  @protected\r\n-  void didUpdateTweens() {}\r\n }\r\n \r\n abstract base class ListenableAnimatedWidgetBaseState<T extends ListenableImplicitlyAnimatedWidget>\r\n     extends ListenableImplicitlyAnimatedWidgetState<T> {\r\n"
                },
                {
                    "date": 1698818041369,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -106,9 +106,13 @@\n   void initState() {\r\n     super.initState();\r\n \r\n     super.controller.addStatusListener((status) {\r\n-      \r\n+      if (status case AnimationStatus.dismissed) {\r\n+        widget.onDismiss?.call();\r\n+      } else if (status case AnimationStatus.forward) {\r\n+        widget.onForward?.call();\r\n+      } else if (status case An)\r\n       switch (status) {\r\n         case AnimationStatus.completed:\r\n           widget.onEnd?.call();\r\n         case AnimationStatus.dismissed:\r\n"
                },
                {
                    "date": 1698818086939,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,65 +1,7 @@\n import \"package:flutter/foundation.dart\";\r\n import \"package:flutter/material.dart\";\r\n \r\n-/// An abstract class for building widgets that animate changes to their\r\n-/// properties.\r\n-///\r\n-/// Widgets of this type will not animate when they are first added to the\r\n-/// widget tree. Rather, when they are rebuilt with different values, they will\r\n-/// respond to those _changes_ by animating the changes over a specified\r\n-/// [duration].\r\n-///\r\n-/// Which properties are animated is left up to the subclass. Subclasses' [State]s\r\n-/// must extend [ImplicitlyAnimatedWidgetState] and provide a way to visit the\r\n-/// relevant fields to animate.\r\n-///\r\n-/// ## Relationship to [AnimatedWidget]s\r\n-///\r\n-/// [ImplicitlyAnimatedWidget]s (and their subclasses) automatically animate\r\n-/// changes in their properties whenever they change. For this,\r\n-/// they create and manage their own internal [AnimationController]s to power\r\n-/// the animation. While these widgets are simple to use and don't require you\r\n-/// to manually manage the lifecycle of an [AnimationController], they\r\n-/// are also somewhat limited: Besides the target value for the animated\r\n-/// property, developers can only choose a [duration] and [curve] for the\r\n-/// animation. If you require more control over the animation (e.g. you want\r\n-/// to stop it somewhere in the middle), consider using an\r\n-/// [AnimatedWidget] or one of its subclasses. These widgets take an [Animation]\r\n-/// as an argument to power the animation. This gives the developer full control\r\n-/// over the animation at the cost of requiring you to manually manage the\r\n-/// underlying [AnimationController].\r\n-///\r\n-/// ## Common implicitly animated widgets\r\n-///\r\n-/// A number of implicitly animated widgets ship with the framework. They are\r\n-/// usually named `AnimatedFoo`, where `Foo` is the name of the non-animated\r\n-/// version of that widget. Commonly used implicitly animated widgets include:\r\n-///\r\n-///  * [TweenAnimationBuilder], which animates any property expressed by\r\n-///    a [Tween] to a specified target value.\r\n-///  * [AnimatedAlign], which is an implicitly animated version of [Align].\r\n-///  * [AnimatedContainer], which is an implicitly animated version of\r\n-///    [Container].\r\n-///  * [AnimatedDefaultTextStyle], which is an implicitly animated version of\r\n-///    [DefaultTextStyle].\r\n-///  * [AnimatedScale], which is an implicitly animated version of [Transform.scale].\r\n-///  * [AnimatedRotation], which is an implicitly animated version of [Transform.rotate].\r\n-///  * [AnimatedSlide], which implicitly animates the position of a widget relative to its normal position.\r\n-///  * [AnimatedOpacity], which is an implicitly animated version of [Opacity].\r\n-///  * [AnimatedPadding], which is an implicitly animated version of [Padding].\r\n-///  * [AnimatedPhysicalModel], which is an implicitly animated version of\r\n-///    [PhysicalModel].\r\n-///  * [AnimatedPositioned], which is an implicitly animated version of\r\n-///    [Positioned].\r\n-///  * [AnimatedPositionedDirectional], which is an implicitly animated version\r\n-///    of [PositionedDirectional].\r\n-///  * [AnimatedTheme], which is an implicitly animated version of [Theme].\r\n-///  * [AnimatedCrossFade], which cross-fades between two given children and\r\n-///    animates itself between their sizes.\r\n-///  * [AnimatedSize], which automatically transitions its size over a given\r\n-///    duration.\r\n-///  * [AnimatedSwitcher], which fades from one widget to another.\r\n abstract class ListenableImplicitlyAnimatedWidget extends ImplicitlyAnimatedWidget {\r\n   /// Initializes fields for subclasses.\r\n   const ListenableImplicitlyAnimatedWidget({\r\n     required super.duration,\r\n@@ -104,24 +46,15 @@\n     extends ImplicitlyAnimatedWidgetState<T> {\r\n   @override\r\n   void initState() {\r\n     super.initState();\r\n-\r\n     super.controller.addStatusListener((status) {\r\n       if (status case AnimationStatus.dismissed) {\r\n         widget.onDismiss?.call();\r\n       } else if (status case AnimationStatus.forward) {\r\n         widget.onForward?.call();\r\n-      } else if (status case An)\r\n-      switch (status) {\r\n-        case AnimationStatus.completed:\r\n-          widget.onEnd?.call();\r\n-        case AnimationStatus.dismissed:\r\n-          widget.onDismiss?.call();\r\n-        case AnimationStatus.forward:\r\n-          widget.onForward?.call();\r\n-        case AnimationStatus.reverse:\r\n-          widget.onReverse?.call();\r\n+      } else if (status case AnimationStatus.reverse) {\r\n+        widget.onReverse?.call();\r\n       }\r\n     });\r\n   }\r\n }\r\n"
                }
            ],
            "date": 1698817377416,
            "name": "Commit-0",
            "content": "abstract class AnimatedWidgetBaseState<T extends ImplicitlyAnimatedWidget> extends ImplicitlyAnimatedWidgetState<T> {\r\n  @override\r\n  void initState() {\r\n    super.initState();\r\n    controller.addListener(_handleAnimationChanged);\r\n  }\r\n\r\n  void _handleAnimationChanged() {\r\n    setState(() { /* The animation ticked. Rebuild with new animation value */ });\r\n  }\r\n}\r\n"
        }
    ]
}