{
    "sourceFile": "lib/widgets/shared/miscellaneous/clickable_widget.dart",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 5,
            "patches": [
                {
                    "date": 1698748058137,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1698748091732,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,1 +1,5 @@\n+import \"package:flutter/material.dart\";\r\n \r\n+class ClickableWidget extends StatelessWidget {\r\n+  \r\n+}\r\n"
                },
                {
                    "date": 1698748124077,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,72 @@\n import \"package:flutter/material.dart\";\r\n \r\n class ClickableWidget extends StatelessWidget {\r\n+  const ClickableWidget({\r\n+    super.key,\r\n+    this.child,\r\n+    this.onTapDown,\r\n+    this.onTapUp,\r\n+    this.onTap,\r\n+    this.onTapCancel,\r\n+    this.onSecondaryTap,\r\n+    this.onSecondaryTapDown,\r\n+    this.onSecondaryTapUp,\r\n+    this.onSecondaryTapCancel,\r\n+    this.onTertiaryTapDown,\r\n+    this.onTertiaryTapUp,\r\n+    this.onTertiaryTapCancel,\r\n+    this.onDoubleTapDown,\r\n+    this.onDoubleTap,\r\n+    this.onDoubleTapCancel,\r\n+    this.onLongPressDown,\r\n+    this.onLongPressCancel,\r\n+    this.onLongPress,\r\n+    this.onLongPressStart,\r\n+    this.onLongPressMoveUpdate,\r\n+    this.onLongPressUp,\r\n+    this.onLongPressEnd,\r\n+    this.onSecondaryLongPressDown,\r\n+    this.onSecondaryLongPressCancel,\r\n+    this.onSecondaryLongPress,\r\n+    this.onSecondaryLongPressStart,\r\n+    this.onSecondaryLongPressMoveUpdate,\r\n+    this.onSecondaryLongPressUp,\r\n+    this.onSecondaryLongPressEnd,\r\n+    this.onTertiaryLongPressDown,\r\n+    this.onTertiaryLongPressCancel,\r\n+    this.onTertiaryLongPress,\r\n+    this.onTertiaryLongPressStart,\r\n+    this.onTertiaryLongPressMoveUpdate,\r\n+    this.onTertiaryLongPressUp,\r\n+    this.onTertiaryLongPressEnd,\r\n+    this.onVerticalDragDown,\r\n+    this.onVerticalDragStart,\r\n+    this.onVerticalDragUpdate,\r\n+    this.onVerticalDragEnd,\r\n+    this.onVerticalDragCancel,\r\n+    this.onHorizontalDragDown,\r\n+    this.onHorizontalDragStart,\r\n+    this.onHorizontalDragUpdate,\r\n+    this.onHorizontalDragEnd,\r\n+    this.onHorizontalDragCancel,\r\n+    this.onForcePressStart,\r\n+    this.onForcePressPeak,\r\n+    this.onForcePressUpdate,\r\n+    this.onForcePressEnd,\r\n+    this.onPanDown,\r\n+    this.onPanStart,\r\n+    this.onPanUpdate,\r\n+    this.onPanEnd,\r\n+    this.onPanCancel,\r\n+    this.onScaleStart,\r\n+    this.onScaleUpdate,\r\n+    this.onScaleEnd,\r\n+    this.behavior,\r\n+    this.excludeFromSemantics = false,\r\n+    this.dragStartBehavior = DragStartBehavior.start,\r\n+    this.trackpadScrollCausesScale = false,\r\n+    this.trackpadScrollToScaleFactor = kDefaultTrackpadScrollToScaleFactor,\r\n+    this.supportedDevices,\r\n+  });\r\n   \r\n }\r\n"
                },
                {
                    "date": 1698748262280,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,4 +1,5 @@\n+import \"package:flutter/gestures.dart\";\r\n import \"package:flutter/material.dart\";\r\n \r\n class ClickableWidget extends StatelessWidget {\r\n   const ClickableWidget({\r\n@@ -67,6 +68,708 @@\n     this.trackpadScrollCausesScale = false,\r\n     this.trackpadScrollToScaleFactor = kDefaultTrackpadScrollToScaleFactor,\r\n     this.supportedDevices,\r\n   });\r\n+\r\n+  /// The widget below this widget in the tree.\r\n+  ///\r\n+  /// {@macro flutter.widgets.ProxyWidget.child}\r\n+  final Widget? child;\r\n+\r\n+  /// A pointer that might cause a tap with a primary button has contacted the\r\n+  /// screen at a particular location.\r\n+  ///\r\n+  /// This is called after a short timeout, even if the winning gesture has not\r\n+  /// yet been selected. If the tap gesture wins, [onTapUp] will be called,\r\n+  /// otherwise [onTapCancel] will be called.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kPrimaryButton], the button this callback responds to.\r\n+  final GestureTapDownCallback? onTapDown;\r\n+\r\n+  /// A pointer that will trigger a tap with a primary button has stopped\r\n+  /// contacting the screen at a particular location.\r\n+  ///\r\n+  /// This triggers immediately before [onTap] in the case of the tap gesture\r\n+  /// winning. If the tap gesture did not win, [onTapCancel] is called instead.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kPrimaryButton], the button this callback responds to.\r\n+  final GestureTapUpCallback? onTapUp;\r\n+\r\n+  /// A tap with a primary button has occurred.\r\n+  ///\r\n+  /// This triggers when the tap gesture wins. If the tap gesture did not win,\r\n+  /// [onTapCancel] is called instead.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kPrimaryButton], the button this callback responds to.\r\n+  ///  * [onTapUp], which is called at the same time but includes details\r\n+  ///    regarding the pointer position.\r\n+  final GestureTapCallback? onTap;\r\n+\r\n+  /// The pointer that previously triggered [onTapDown] will not end up causing\r\n+  /// a tap.\r\n+  ///\r\n+  /// This is called after [onTapDown], and instead of [onTapUp] and [onTap], if\r\n+  /// the tap gesture did not win.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kPrimaryButton], the button this callback responds to.\r\n+  final GestureTapCancelCallback? onTapCancel;\r\n+\r\n+  /// A tap with a secondary button has occurred.\r\n+  ///\r\n+  /// This triggers when the tap gesture wins. If the tap gesture did not win,\r\n+  /// [onSecondaryTapCancel] is called instead.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kSecondaryButton], the button this callback responds to.\r\n+  ///  * [onSecondaryTapUp], which is called at the same time but includes details\r\n+  ///    regarding the pointer position.\r\n+  final GestureTapCallback? onSecondaryTap;\r\n+\r\n+  /// A pointer that might cause a tap with a secondary button has contacted the\r\n+  /// screen at a particular location.\r\n+  ///\r\n+  /// This is called after a short timeout, even if the winning gesture has not\r\n+  /// yet been selected. If the tap gesture wins, [onSecondaryTapUp] will be\r\n+  /// called, otherwise [onSecondaryTapCancel] will be called.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kSecondaryButton], the button this callback responds to.\r\n+  final GestureTapDownCallback? onSecondaryTapDown;\r\n+\r\n+  /// A pointer that will trigger a tap with a secondary button has stopped\r\n+  /// contacting the screen at a particular location.\r\n+  ///\r\n+  /// This triggers in the case of the tap gesture winning. If the tap gesture\r\n+  /// did not win, [onSecondaryTapCancel] is called instead.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [onSecondaryTap], a handler triggered right after this one that doesn't\r\n+  ///    pass any details about the tap.\r\n+  ///  * [kSecondaryButton], the button this callback responds to.\r\n+  final GestureTapUpCallback? onSecondaryTapUp;\r\n+\r\n+  /// The pointer that previously triggered [onSecondaryTapDown] will not end up\r\n+  /// causing a tap.\r\n+  ///\r\n+  /// This is called after [onSecondaryTapDown], and instead of\r\n+  /// [onSecondaryTapUp], if the tap gesture did not win.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kSecondaryButton], the button this callback responds to.\r\n+  final GestureTapCancelCallback? onSecondaryTapCancel;\r\n+\r\n+  /// A pointer that might cause a tap with a tertiary button has contacted the\r\n+  /// screen at a particular location.\r\n+  ///\r\n+  /// This is called after a short timeout, even if the winning gesture has not\r\n+  /// yet been selected. If the tap gesture wins, [onTertiaryTapUp] will be\r\n+  /// called, otherwise [onTertiaryTapCancel] will be called.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kTertiaryButton], the button this callback responds to.\r\n+  final GestureTapDownCallback? onTertiaryTapDown;\r\n+\r\n+  /// A pointer that will trigger a tap with a tertiary button has stopped\r\n+  /// contacting the screen at a particular location.\r\n+  ///\r\n+  /// This triggers in the case of the tap gesture winning. If the tap gesture\r\n+  /// did not win, [onTertiaryTapCancel] is called instead.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kTertiaryButton], the button this callback responds to.\r\n+  final GestureTapUpCallback? onTertiaryTapUp;\r\n+\r\n+  /// The pointer that previously triggered [onTertiaryTapDown] will not end up\r\n+  /// causing a tap.\r\n+  ///\r\n+  /// This is called after [onTertiaryTapDown], and instead of\r\n+  /// [onTertiaryTapUp], if the tap gesture did not win.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kTertiaryButton], the button this callback responds to.\r\n+  final GestureTapCancelCallback? onTertiaryTapCancel;\r\n+\r\n+  /// A pointer that might cause a double tap has contacted the screen at a\r\n+  /// particular location.\r\n+  ///\r\n+  /// Triggered immediately after the down event of the second tap.\r\n+  ///\r\n+  /// If the user completes the double tap and the gesture wins, [onDoubleTap]\r\n+  /// will be called after this callback. Otherwise, [onDoubleTapCancel] will\r\n+  /// be called after this callback.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kPrimaryButton], the button this callback responds to.\r\n+  final GestureTapDownCallback? onDoubleTapDown;\r\n+\r\n+  /// The user has tapped the screen with a primary button at the same location\r\n+  /// twice in quick succession.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kPrimaryButton], the button this callback responds to.\r\n+  final GestureTapCallback? onDoubleTap;\r\n+\r\n+  /// The pointer that previously triggered [onDoubleTapDown] will not end up\r\n+  /// causing a double tap.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kPrimaryButton], the button this callback responds to.\r\n+  final GestureTapCancelCallback? onDoubleTapCancel;\r\n+\r\n+  /// The pointer has contacted the screen with a primary button, which might\r\n+  /// be the start of a long-press.\r\n+  ///\r\n+  /// This triggers after the pointer down event.\r\n+  ///\r\n+  /// If the user completes the long-press, and this gesture wins,\r\n+  /// [onLongPressStart] will be called after this callback. Otherwise,\r\n+  /// [onLongPressCancel] will be called after this callback.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kPrimaryButton], the button this callback responds to.\r\n+  ///  * [onSecondaryLongPressDown], a similar callback but for a secondary button.\r\n+  ///  * [onTertiaryLongPressDown], a similar callback but for a tertiary button.\r\n+  ///  * [LongPressGestureRecognizer.onLongPressDown], which exposes this\r\n+  ///    callback at the gesture layer.\r\n+  final GestureLongPressDownCallback? onLongPressDown;\r\n+\r\n+  /// A pointer that previously triggered [onLongPressDown] will not end up\r\n+  /// causing a long-press.\r\n+  ///\r\n+  /// This triggers once the gesture loses if [onLongPressDown] has previously\r\n+  /// been triggered.\r\n+  ///\r\n+  /// If the user completed the long-press, and the gesture won, then\r\n+  /// [onLongPressStart] and [onLongPress] are called instead.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kPrimaryButton], the button this callback responds to.\r\n+  ///  * [LongPressGestureRecognizer.onLongPressCancel], which exposes this\r\n+  ///    callback at the gesture layer.\r\n+  final GestureLongPressCancelCallback? onLongPressCancel;\r\n+\r\n+  /// Called when a long press gesture with a primary button has been recognized.\r\n+  ///\r\n+  /// Triggered when a pointer has remained in contact with the screen at the\r\n+  /// same location for a long period of time.\r\n+  ///\r\n+  /// This is equivalent to (and is called immediately after) [onLongPressStart].\r\n+  /// The only difference between the two is that this callback does not\r\n+  /// contain details of the position at which the pointer initially contacted\r\n+  /// the screen.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kPrimaryButton], the button this callback responds to.\r\n+  ///  * [LongPressGestureRecognizer.onLongPress], which exposes this\r\n+  ///    callback at the gesture layer.\r\n+  final GestureLongPressCallback? onLongPress;\r\n+\r\n+  /// Called when a long press gesture with a primary button has been recognized.\r\n+  ///\r\n+  /// Triggered when a pointer has remained in contact with the screen at the\r\n+  /// same location for a long period of time.\r\n+  ///\r\n+  /// This is equivalent to (and is called immediately before) [onLongPress].\r\n+  /// The only difference between the two is that this callback contains\r\n+  /// details of the position at which the pointer initially contacted the\r\n+  /// screen, whereas [onLongPress] does not.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kPrimaryButton], the button this callback responds to.\r\n+  ///  * [LongPressGestureRecognizer.onLongPressStart], which exposes this\r\n+  ///    callback at the gesture layer.\r\n+  final GestureLongPressStartCallback? onLongPressStart;\r\n+\r\n+  /// A pointer has been drag-moved after a long-press with a primary button.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kPrimaryButton], the button this callback responds to.\r\n+  ///  * [LongPressGestureRecognizer.onLongPressMoveUpdate], which exposes this\r\n+  ///    callback at the gesture layer.\r\n+  final GestureLongPressMoveUpdateCallback? onLongPressMoveUpdate;\r\n+\r\n+  /// A pointer that has triggered a long-press with a primary button has\r\n+  /// stopped contacting the screen.\r\n+  ///\r\n+  /// This is equivalent to (and is called immediately after) [onLongPressEnd].\r\n+  /// The only difference between the two is that this callback does not\r\n+  /// contain details of the state of the pointer when it stopped contacting\r\n+  /// the screen.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kPrimaryButton], the button this callback responds to.\r\n+  ///  * [LongPressGestureRecognizer.onLongPressUp], which exposes this\r\n+  ///    callback at the gesture layer.\r\n+  final GestureLongPressUpCallback? onLongPressUp;\r\n+\r\n+  /// A pointer that has triggered a long-press with a primary button has\r\n+  /// stopped contacting the screen.\r\n+  ///\r\n+  /// This is equivalent to (and is called immediately before) [onLongPressUp].\r\n+  /// The only difference between the two is that this callback contains\r\n+  /// details of the state of the pointer when it stopped contacting the\r\n+  /// screen, whereas [onLongPressUp] does not.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kPrimaryButton], the button this callback responds to.\r\n+  ///  * [LongPressGestureRecognizer.onLongPressEnd], which exposes this\r\n+  ///    callback at the gesture layer.\r\n+  final GestureLongPressEndCallback? onLongPressEnd;\r\n+\r\n+  /// The pointer has contacted the screen with a secondary button, which might\r\n+  /// be the start of a long-press.\r\n+  ///\r\n+  /// This triggers after the pointer down event.\r\n+  ///\r\n+  /// If the user completes the long-press, and this gesture wins,\r\n+  /// [onSecondaryLongPressStart] will be called after this callback. Otherwise,\r\n+  /// [onSecondaryLongPressCancel] will be called after this callback.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kSecondaryButton], the button this callback responds to.\r\n+  ///  * [onLongPressDown], a similar callback but for a secondary button.\r\n+  ///  * [onTertiaryLongPressDown], a similar callback but for a tertiary button.\r\n+  ///  * [LongPressGestureRecognizer.onSecondaryLongPressDown], which exposes\r\n+  ///    this callback at the gesture layer.\r\n+  final GestureLongPressDownCallback? onSecondaryLongPressDown;\r\n+\r\n+  /// A pointer that previously triggered [onSecondaryLongPressDown] will not\r\n+  /// end up causing a long-press.\r\n+  ///\r\n+  /// This triggers once the gesture loses if [onSecondaryLongPressDown] has\r\n+  /// previously been triggered.\r\n+  ///\r\n+  /// If the user completed the long-press, and the gesture won, then\r\n+  /// [onSecondaryLongPressStart] and [onSecondaryLongPress] are called instead.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kSecondaryButton], the button this callback responds to.\r\n+  ///  * [LongPressGestureRecognizer.onSecondaryLongPressCancel], which exposes\r\n+  ///    this callback at the gesture layer.\r\n+  final GestureLongPressCancelCallback? onSecondaryLongPressCancel;\r\n+\r\n+  /// Called when a long press gesture with a secondary button has been\r\n+  /// recognized.\r\n+  ///\r\n+  /// Triggered when a pointer has remained in contact with the screen at the\r\n+  /// same location for a long period of time.\r\n+  ///\r\n+  /// This is equivalent to (and is called immediately after)\r\n+  /// [onSecondaryLongPressStart]. The only difference between the two is that\r\n+  /// this callback does not contain details of the position at which the\r\n+  /// pointer initially contacted the screen.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kSecondaryButton], the button this callback responds to.\r\n+  ///  * [LongPressGestureRecognizer.onSecondaryLongPress], which exposes\r\n+  ///    this callback at the gesture layer.\r\n+  final GestureLongPressCallback? onSecondaryLongPress;\r\n+\r\n+  /// Called when a long press gesture with a secondary button has been\r\n+  /// recognized.\r\n+  ///\r\n+  /// Triggered when a pointer has remained in contact with the screen at the\r\n+  /// same location for a long period of time.\r\n+  ///\r\n+  /// This is equivalent to (and is called immediately before)\r\n+  /// [onSecondaryLongPress]. The only difference between the two is that this\r\n+  /// callback contains details of the position at which the pointer initially\r\n+  /// contacted the screen, whereas [onSecondaryLongPress] does not.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kSecondaryButton], the button this callback responds to.\r\n+  ///  * [LongPressGestureRecognizer.onSecondaryLongPressStart], which exposes\r\n+  ///    this callback at the gesture layer.\r\n+  final GestureLongPressStartCallback? onSecondaryLongPressStart;\r\n+\r\n+  /// A pointer has been drag-moved after a long press with a secondary button.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kSecondaryButton], the button this callback responds to.\r\n+  ///  * [LongPressGestureRecognizer.onSecondaryLongPressMoveUpdate], which exposes\r\n+  ///    this callback at the gesture layer.\r\n+  final GestureLongPressMoveUpdateCallback? onSecondaryLongPressMoveUpdate;\r\n+\r\n+  /// A pointer that has triggered a long-press with a secondary button has\r\n+  /// stopped contacting the screen.\r\n+  ///\r\n+  /// This is equivalent to (and is called immediately after)\r\n+  /// [onSecondaryLongPressEnd]. The only difference between the two is that\r\n+  /// this callback does not contain details of the state of the pointer when\r\n+  /// it stopped contacting the screen.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kSecondaryButton], the button this callback responds to.\r\n+  ///  * [LongPressGestureRecognizer.onSecondaryLongPressUp], which exposes\r\n+  ///    this callback at the gesture layer.\r\n+  final GestureLongPressUpCallback? onSecondaryLongPressUp;\r\n+\r\n+  /// A pointer that has triggered a long-press with a secondary button has\r\n+  /// stopped contacting the screen.\r\n+  ///\r\n+  /// This is equivalent to (and is called immediately before)\r\n+  /// [onSecondaryLongPressUp]. The only difference between the two is that\r\n+  /// this callback contains details of the state of the pointer when it\r\n+  /// stopped contacting the screen, whereas [onSecondaryLongPressUp] does not.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kSecondaryButton], the button this callback responds to.\r\n+  ///  * [LongPressGestureRecognizer.onSecondaryLongPressEnd], which exposes\r\n+  ///    this callback at the gesture layer.\r\n+  final GestureLongPressEndCallback? onSecondaryLongPressEnd;\r\n+\r\n+  /// The pointer has contacted the screen with a tertiary button, which might\r\n+  /// be the start of a long-press.\r\n+  ///\r\n+  /// This triggers after the pointer down event.\r\n+  ///\r\n+  /// If the user completes the long-press, and this gesture wins,\r\n+  /// [onTertiaryLongPressStart] will be called after this callback. Otherwise,\r\n+  /// [onTertiaryLongPressCancel] will be called after this callback.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kTertiaryButton], the button this callback responds to.\r\n+  ///  * [onLongPressDown], a similar callback but for a primary button.\r\n+  ///  * [onSecondaryLongPressDown], a similar callback but for a secondary button.\r\n+  ///  * [LongPressGestureRecognizer.onTertiaryLongPressDown], which exposes\r\n+  ///    this callback at the gesture layer.\r\n+  final GestureLongPressDownCallback? onTertiaryLongPressDown;\r\n+\r\n+  /// A pointer that previously triggered [onTertiaryLongPressDown] will not\r\n+  /// end up causing a long-press.\r\n+  ///\r\n+  /// This triggers once the gesture loses if [onTertiaryLongPressDown] has\r\n+  /// previously been triggered.\r\n+  ///\r\n+  /// If the user completed the long-press, and the gesture won, then\r\n+  /// [onTertiaryLongPressStart] and [onTertiaryLongPress] are called instead.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kTertiaryButton], the button this callback responds to.\r\n+  ///  * [LongPressGestureRecognizer.onTertiaryLongPressCancel], which exposes\r\n+  ///    this callback at the gesture layer.\r\n+  final GestureLongPressCancelCallback? onTertiaryLongPressCancel;\r\n+\r\n+  /// Called when a long press gesture with a tertiary button has been\r\n+  /// recognized.\r\n+  ///\r\n+  /// Triggered when a pointer has remained in contact with the screen at the\r\n+  /// same location for a long period of time.\r\n+  ///\r\n+  /// This is equivalent to (and is called immediately after)\r\n+  /// [onTertiaryLongPressStart]. The only difference between the two is that\r\n+  /// this callback does not contain details of the position at which the\r\n+  /// pointer initially contacted the screen.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kTertiaryButton], the button this callback responds to.\r\n+  ///  * [LongPressGestureRecognizer.onTertiaryLongPress], which exposes\r\n+  ///    this callback at the gesture layer.\r\n+  final GestureLongPressCallback? onTertiaryLongPress;\r\n+\r\n+  /// Called when a long press gesture with a tertiary button has been\r\n+  /// recognized.\r\n+  ///\r\n+  /// Triggered when a pointer has remained in contact with the screen at the\r\n+  /// same location for a long period of time.\r\n+  ///\r\n+  /// This is equivalent to (and is called immediately before)\r\n+  /// [onTertiaryLongPress]. The only difference between the two is that this\r\n+  /// callback contains details of the position at which the pointer initially\r\n+  /// contacted the screen, whereas [onTertiaryLongPress] does not.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kTertiaryButton], the button this callback responds to.\r\n+  ///  * [LongPressGestureRecognizer.onTertiaryLongPressStart], which exposes\r\n+  ///    this callback at the gesture layer.\r\n+  final GestureLongPressStartCallback? onTertiaryLongPressStart;\r\n+\r\n+  /// A pointer has been drag-moved after a long press with a tertiary button.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kTertiaryButton], the button this callback responds to.\r\n+  ///  * [LongPressGestureRecognizer.onTertiaryLongPressMoveUpdate], which exposes\r\n+  ///    this callback at the gesture layer.\r\n+  final GestureLongPressMoveUpdateCallback? onTertiaryLongPressMoveUpdate;\r\n+\r\n+  /// A pointer that has triggered a long-press with a tertiary button has\r\n+  /// stopped contacting the screen.\r\n+  ///\r\n+  /// This is equivalent to (and is called immediately after)\r\n+  /// [onTertiaryLongPressEnd]. The only difference between the two is that\r\n+  /// this callback does not contain details of the state of the pointer when\r\n+  /// it stopped contacting the screen.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kTertiaryButton], the button this callback responds to.\r\n+  ///  * [LongPressGestureRecognizer.onTertiaryLongPressUp], which exposes\r\n+  ///    this callback at the gesture layer.\r\n+  final GestureLongPressUpCallback? onTertiaryLongPressUp;\r\n+\r\n+  /// A pointer that has triggered a long-press with a tertiary button has\r\n+  /// stopped contacting the screen.\r\n+  ///\r\n+  /// This is equivalent to (and is called immediately before)\r\n+  /// [onTertiaryLongPressUp]. The only difference between the two is that\r\n+  /// this callback contains details of the state of the pointer when it\r\n+  /// stopped contacting the screen, whereas [onTertiaryLongPressUp] does not.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kTertiaryButton], the button this callback responds to.\r\n+  ///  * [LongPressGestureRecognizer.onTertiaryLongPressEnd], which exposes\r\n+  ///    this callback at the gesture layer.\r\n+  final GestureLongPressEndCallback? onTertiaryLongPressEnd;\r\n+\r\n+  /// A pointer has contacted the screen with a primary button and might begin\r\n+  /// to move vertically.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kPrimaryButton], the button this callback responds to.\r\n+  final GestureDragDownCallback? onVerticalDragDown;\r\n+\r\n+  /// A pointer has contacted the screen with a primary button and has begun to\r\n+  /// move vertically.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kPrimaryButton], the button this callback responds to.\r\n+  final GestureDragStartCallback? onVerticalDragStart;\r\n+\r\n+  /// A pointer that is in contact with the screen with a primary button and\r\n+  /// moving vertically has moved in the vertical direction.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kPrimaryButton], the button this callback responds to.\r\n+  final GestureDragUpdateCallback? onVerticalDragUpdate;\r\n+\r\n+  /// A pointer that was previously in contact with the screen with a primary\r\n+  /// button and moving vertically is no longer in contact with the screen and\r\n+  /// was moving at a specific velocity when it stopped contacting the screen.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kPrimaryButton], the button this callback responds to.\r\n+  final GestureDragEndCallback? onVerticalDragEnd;\r\n+\r\n+  /// The pointer that previously triggered [onVerticalDragDown] did not\r\n+  /// complete.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kPrimaryButton], the button this callback responds to.\r\n+  final GestureDragCancelCallback? onVerticalDragCancel;\r\n+\r\n+  /// A pointer has contacted the screen with a primary button and might begin\r\n+  /// to move horizontally.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kPrimaryButton], the button this callback responds to.\r\n+  final GestureDragDownCallback? onHorizontalDragDown;\r\n+\r\n+  /// A pointer has contacted the screen with a primary button and has begun to\r\n+  /// move horizontally.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kPrimaryButton], the button this callback responds to.\r\n+  final GestureDragStartCallback? onHorizontalDragStart;\r\n+\r\n+  /// A pointer that is in contact with the screen with a primary button and\r\n+  /// moving horizontally has moved in the horizontal direction.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kPrimaryButton], the button this callback responds to.\r\n+  final GestureDragUpdateCallback? onHorizontalDragUpdate;\r\n+\r\n+  /// A pointer that was previously in contact with the screen with a primary\r\n+  /// button and moving horizontally is no longer in contact with the screen and\r\n+  /// was moving at a specific velocity when it stopped contacting the screen.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kPrimaryButton], the button this callback responds to.\r\n+  final GestureDragEndCallback? onHorizontalDragEnd;\r\n+\r\n+  /// The pointer that previously triggered [onHorizontalDragDown] did not\r\n+  /// complete.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kPrimaryButton], the button this callback responds to.\r\n+  final GestureDragCancelCallback? onHorizontalDragCancel;\r\n+\r\n+  /// A pointer has contacted the screen with a primary button and might begin\r\n+  /// to move.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kPrimaryButton], the button this callback responds to.\r\n+  final GestureDragDownCallback? onPanDown;\r\n+\r\n+  /// A pointer has contacted the screen with a primary button and has begun to\r\n+  /// move.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kPrimaryButton], the button this callback responds to.\r\n+  final GestureDragStartCallback? onPanStart;\r\n+\r\n+  /// A pointer that is in contact with the screen with a primary button and\r\n+  /// moving has moved again.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kPrimaryButton], the button this callback responds to.\r\n+  final GestureDragUpdateCallback? onPanUpdate;\r\n+\r\n+  /// A pointer that was previously in contact with the screen with a primary\r\n+  /// button and moving is no longer in contact with the screen and was moving\r\n+  /// at a specific velocity when it stopped contacting the screen.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kPrimaryButton], the button this callback responds to.\r\n+  final GestureDragEndCallback? onPanEnd;\r\n+\r\n+  /// The pointer that previously triggered [onPanDown] did not complete.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kPrimaryButton], the button this callback responds to.\r\n+  final GestureDragCancelCallback? onPanCancel;\r\n+\r\n+  /// The pointers in contact with the screen have established a focal point and\r\n+  /// initial scale of 1.0.\r\n+  final GestureScaleStartCallback? onScaleStart;\r\n+\r\n+  /// The pointers in contact with the screen have indicated a new focal point\r\n+  /// and/or scale.\r\n+  final GestureScaleUpdateCallback? onScaleUpdate;\r\n+\r\n+  /// The pointers are no longer in contact with the screen.\r\n+  final GestureScaleEndCallback? onScaleEnd;\r\n+\r\n+  /// The pointer is in contact with the screen and has pressed with sufficient\r\n+  /// force to initiate a force press. The amount of force is at least\r\n+  /// [ForcePressGestureRecognizer.startPressure].\r\n+  ///\r\n+  /// This callback will only be fired on devices with pressure\r\n+  /// detecting screens.\r\n+  final GestureForcePressStartCallback? onForcePressStart;\r\n+\r\n+  /// The pointer is in contact with the screen and has pressed with the maximum\r\n+  /// force. The amount of force is at least\r\n+  /// [ForcePressGestureRecognizer.peakPressure].\r\n+  ///\r\n+  /// This callback will only be fired on devices with pressure\r\n+  /// detecting screens.\r\n+  final GestureForcePressPeakCallback? onForcePressPeak;\r\n+\r\n+  /// A pointer is in contact with the screen, has previously passed the\r\n+  /// [ForcePressGestureRecognizer.startPressure] and is either moving on the\r\n+  /// plane of the screen, pressing the screen with varying forces or both\r\n+  /// simultaneously.\r\n+  ///\r\n+  /// This callback will only be fired on devices with pressure\r\n+  /// detecting screens.\r\n+  final GestureForcePressUpdateCallback? onForcePressUpdate;\r\n+\r\n+  /// The pointer tracked by [onForcePressStart] is no longer in contact with the screen.\r\n+  ///\r\n+  /// This callback will only be fired on devices with pressure\r\n+  /// detecting screens.\r\n+  final GestureForcePressEndCallback? onForcePressEnd;\r\n+\r\n+  /// How this gesture detector should behave during hit testing when deciding\r\n+  /// how the hit test propagates to children and whether to consider targets\r\n+  /// behind this one.\r\n+  ///\r\n+  /// This defaults to [HitTestBehavior.deferToChild] if [child] is not null and\r\n+  /// [HitTestBehavior.translucent] if child is null.\r\n+  ///\r\n+  /// See [HitTestBehavior] for the allowed values and their meanings.\r\n+  final HitTestBehavior? behavior;\r\n+\r\n+  /// Whether to exclude these gestures from the semantics tree. For\r\n+  /// example, the long-press gesture for showing a tooltip is\r\n+  /// excluded because the tooltip itself is included in the semantics\r\n+  /// tree directly and so having a gesture to show it would result in\r\n+  /// duplication of information.\r\n+  final bool excludeFromSemantics;\r\n+\r\n+  /// Determines the way that drag start behavior is handled.\r\n+  ///\r\n+  /// If set to [DragStartBehavior.start], gesture drag behavior will\r\n+  /// begin at the position where the drag gesture won the arena. If set to\r\n+  /// [DragStartBehavior.down] it will begin at the position where a down event\r\n+  /// is first detected.\r\n+  ///\r\n+  /// In general, setting this to [DragStartBehavior.start] will make drag\r\n+  /// animation smoother and setting it to [DragStartBehavior.down] will make\r\n+  /// drag behavior feel slightly more reactive.\r\n+  ///\r\n+  /// By default, the drag start behavior is [DragStartBehavior.start].\r\n+  ///\r\n+  /// Only the [DragGestureRecognizer.onStart] callbacks for the\r\n+  /// [VerticalDragGestureRecognizer], [HorizontalDragGestureRecognizer] and\r\n+  /// [PanGestureRecognizer] are affected by this setting.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [DragGestureRecognizer.dragStartBehavior], which gives an example for the different behaviors.\r\n+  final DragStartBehavior dragStartBehavior;\r\n+\r\n+  /// The kind of devices that are allowed to be recognized.\r\n+  ///\r\n+  /// If set to null, events from all device types will be recognized. Defaults to null.\r\n+  final Set<PointerDeviceKind>? supportedDevices;\r\n+\r\n+  /// {@macro flutter.gestures.scale.trackpadScrollCausesScale}\r\n+  final bool trackpadScrollCausesScale;\r\n+\r\n+  /// {@macro flutter.gestures.scale.trackpadScrollToScaleFactor}\r\n+  final Offset trackpadScrollToScaleFactor;\r\n   \r\n }\r\n"
                },
                {
                    "date": 1698748305691,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -775,8 +775,9 @@\n   @override\r\n   Widget build(BuildContext context) {\r\n     return MouseRegion(\r\n       child: GestureDetector(\r\n+        \r\n         child: child,\r\n       ),\r\n     );\r\n   }\r\n"
                },
                {
                    "date": 1698748338981,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,847 @@\n+import \"package:flutter/gestures.dart\";\r\n+import \"package:flutter/material.dart\";\r\n+\r\n+class ClickableWidget extends StatelessWidget {\r\n+  const ClickableWidget({\r\n+    super.key,\r\n+    this.child,\r\n+    this.onTapDown,\r\n+    this.onTapUp,\r\n+    this.onTap,\r\n+    this.onTapCancel,\r\n+    this.onSecondaryTap,\r\n+    this.onSecondaryTapDown,\r\n+    this.onSecondaryTapUp,\r\n+    this.onSecondaryTapCancel,\r\n+    this.onTertiaryTapDown,\r\n+    this.onTertiaryTapUp,\r\n+    this.onTertiaryTapCancel,\r\n+    this.onDoubleTapDown,\r\n+    this.onDoubleTap,\r\n+    this.onDoubleTapCancel,\r\n+    this.onLongPressDown,\r\n+    this.onLongPressCancel,\r\n+    this.onLongPress,\r\n+    this.onLongPressStart,\r\n+    this.onLongPressMoveUpdate,\r\n+    this.onLongPressUp,\r\n+    this.onLongPressEnd,\r\n+    this.onSecondaryLongPressDown,\r\n+    this.onSecondaryLongPressCancel,\r\n+    this.onSecondaryLongPress,\r\n+    this.onSecondaryLongPressStart,\r\n+    this.onSecondaryLongPressMoveUpdate,\r\n+    this.onSecondaryLongPressUp,\r\n+    this.onSecondaryLongPressEnd,\r\n+    this.onTertiaryLongPressDown,\r\n+    this.onTertiaryLongPressCancel,\r\n+    this.onTertiaryLongPress,\r\n+    this.onTertiaryLongPressStart,\r\n+    this.onTertiaryLongPressMoveUpdate,\r\n+    this.onTertiaryLongPressUp,\r\n+    this.onTertiaryLongPressEnd,\r\n+    this.onVerticalDragDown,\r\n+    this.onVerticalDragStart,\r\n+    this.onVerticalDragUpdate,\r\n+    this.onVerticalDragEnd,\r\n+    this.onVerticalDragCancel,\r\n+    this.onHorizontalDragDown,\r\n+    this.onHorizontalDragStart,\r\n+    this.onHorizontalDragUpdate,\r\n+    this.onHorizontalDragEnd,\r\n+    this.onHorizontalDragCancel,\r\n+    this.onForcePressStart,\r\n+    this.onForcePressPeak,\r\n+    this.onForcePressUpdate,\r\n+    this.onForcePressEnd,\r\n+    this.onPanDown,\r\n+    this.onPanStart,\r\n+    this.onPanUpdate,\r\n+    this.onPanEnd,\r\n+    this.onPanCancel,\r\n+    this.onScaleStart,\r\n+    this.onScaleUpdate,\r\n+    this.onScaleEnd,\r\n+    this.behavior,\r\n+    this.excludeFromSemantics = false,\r\n+    this.dragStartBehavior = DragStartBehavior.start,\r\n+    this.trackpadScrollCausesScale = false,\r\n+    this.trackpadScrollToScaleFactor = kDefaultTrackpadScrollToScaleFactor,\r\n+    this.supportedDevices,\r\n+  });\r\n+\r\n+  /// The widget below this widget in the tree.\r\n+  ///\r\n+  /// {@macro flutter.widgets.ProxyWidget.child}\r\n+  final Widget? child;\r\n+\r\n+  /// A pointer that might cause a tap with a primary button has contacted the\r\n+  /// screen at a particular location.\r\n+  ///\r\n+  /// This is called after a short timeout, even if the winning gesture has not\r\n+  /// yet been selected. If the tap gesture wins, [onTapUp] will be called,\r\n+  /// otherwise [onTapCancel] will be called.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kPrimaryButton], the button this callback responds to.\r\n+  final GestureTapDownCallback? onTapDown;\r\n+\r\n+  /// A pointer that will trigger a tap with a primary button has stopped\r\n+  /// contacting the screen at a particular location.\r\n+  ///\r\n+  /// This triggers immediately before [onTap] in the case of the tap gesture\r\n+  /// winning. If the tap gesture did not win, [onTapCancel] is called instead.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kPrimaryButton], the button this callback responds to.\r\n+  final GestureTapUpCallback? onTapUp;\r\n+\r\n+  /// A tap with a primary button has occurred.\r\n+  ///\r\n+  /// This triggers when the tap gesture wins. If the tap gesture did not win,\r\n+  /// [onTapCancel] is called instead.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kPrimaryButton], the button this callback responds to.\r\n+  ///  * [onTapUp], which is called at the same time but includes details\r\n+  ///    regarding the pointer position.\r\n+  final GestureTapCallback? onTap;\r\n+\r\n+  /// The pointer that previously triggered [onTapDown] will not end up causing\r\n+  /// a tap.\r\n+  ///\r\n+  /// This is called after [onTapDown], and instead of [onTapUp] and [onTap], if\r\n+  /// the tap gesture did not win.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kPrimaryButton], the button this callback responds to.\r\n+  final GestureTapCancelCallback? onTapCancel;\r\n+\r\n+  /// A tap with a secondary button has occurred.\r\n+  ///\r\n+  /// This triggers when the tap gesture wins. If the tap gesture did not win,\r\n+  /// [onSecondaryTapCancel] is called instead.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kSecondaryButton], the button this callback responds to.\r\n+  ///  * [onSecondaryTapUp], which is called at the same time but includes details\r\n+  ///    regarding the pointer position.\r\n+  final GestureTapCallback? onSecondaryTap;\r\n+\r\n+  /// A pointer that might cause a tap with a secondary button has contacted the\r\n+  /// screen at a particular location.\r\n+  ///\r\n+  /// This is called after a short timeout, even if the winning gesture has not\r\n+  /// yet been selected. If the tap gesture wins, [onSecondaryTapUp] will be\r\n+  /// called, otherwise [onSecondaryTapCancel] will be called.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kSecondaryButton], the button this callback responds to.\r\n+  final GestureTapDownCallback? onSecondaryTapDown;\r\n+\r\n+  /// A pointer that will trigger a tap with a secondary button has stopped\r\n+  /// contacting the screen at a particular location.\r\n+  ///\r\n+  /// This triggers in the case of the tap gesture winning. If the tap gesture\r\n+  /// did not win, [onSecondaryTapCancel] is called instead.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [onSecondaryTap], a handler triggered right after this one that doesn't\r\n+  ///    pass any details about the tap.\r\n+  ///  * [kSecondaryButton], the button this callback responds to.\r\n+  final GestureTapUpCallback? onSecondaryTapUp;\r\n+\r\n+  /// The pointer that previously triggered [onSecondaryTapDown] will not end up\r\n+  /// causing a tap.\r\n+  ///\r\n+  /// This is called after [onSecondaryTapDown], and instead of\r\n+  /// [onSecondaryTapUp], if the tap gesture did not win.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kSecondaryButton], the button this callback responds to.\r\n+  final GestureTapCancelCallback? onSecondaryTapCancel;\r\n+\r\n+  /// A pointer that might cause a tap with a tertiary button has contacted the\r\n+  /// screen at a particular location.\r\n+  ///\r\n+  /// This is called after a short timeout, even if the winning gesture has not\r\n+  /// yet been selected. If the tap gesture wins, [onTertiaryTapUp] will be\r\n+  /// called, otherwise [onTertiaryTapCancel] will be called.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kTertiaryButton], the button this callback responds to.\r\n+  final GestureTapDownCallback? onTertiaryTapDown;\r\n+\r\n+  /// A pointer that will trigger a tap with a tertiary button has stopped\r\n+  /// contacting the screen at a particular location.\r\n+  ///\r\n+  /// This triggers in the case of the tap gesture winning. If the tap gesture\r\n+  /// did not win, [onTertiaryTapCancel] is called instead.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kTertiaryButton], the button this callback responds to.\r\n+  final GestureTapUpCallback? onTertiaryTapUp;\r\n+\r\n+  /// The pointer that previously triggered [onTertiaryTapDown] will not end up\r\n+  /// causing a tap.\r\n+  ///\r\n+  /// This is called after [onTertiaryTapDown], and instead of\r\n+  /// [onTertiaryTapUp], if the tap gesture did not win.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kTertiaryButton], the button this callback responds to.\r\n+  final GestureTapCancelCallback? onTertiaryTapCancel;\r\n+\r\n+  /// A pointer that might cause a double tap has contacted the screen at a\r\n+  /// particular location.\r\n+  ///\r\n+  /// Triggered immediately after the down event of the second tap.\r\n+  ///\r\n+  /// If the user completes the double tap and the gesture wins, [onDoubleTap]\r\n+  /// will be called after this callback. Otherwise, [onDoubleTapCancel] will\r\n+  /// be called after this callback.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kPrimaryButton], the button this callback responds to.\r\n+  final GestureTapDownCallback? onDoubleTapDown;\r\n+\r\n+  /// The user has tapped the screen with a primary button at the same location\r\n+  /// twice in quick succession.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kPrimaryButton], the button this callback responds to.\r\n+  final GestureTapCallback? onDoubleTap;\r\n+\r\n+  /// The pointer that previously triggered [onDoubleTapDown] will not end up\r\n+  /// causing a double tap.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kPrimaryButton], the button this callback responds to.\r\n+  final GestureTapCancelCallback? onDoubleTapCancel;\r\n+\r\n+  /// The pointer has contacted the screen with a primary button, which might\r\n+  /// be the start of a long-press.\r\n+  ///\r\n+  /// This triggers after the pointer down event.\r\n+  ///\r\n+  /// If the user completes the long-press, and this gesture wins,\r\n+  /// [onLongPressStart] will be called after this callback. Otherwise,\r\n+  /// [onLongPressCancel] will be called after this callback.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kPrimaryButton], the button this callback responds to.\r\n+  ///  * [onSecondaryLongPressDown], a similar callback but for a secondary button.\r\n+  ///  * [onTertiaryLongPressDown], a similar callback but for a tertiary button.\r\n+  ///  * [LongPressGestureRecognizer.onLongPressDown], which exposes this\r\n+  ///    callback at the gesture layer.\r\n+  final GestureLongPressDownCallback? onLongPressDown;\r\n+\r\n+  /// A pointer that previously triggered [onLongPressDown] will not end up\r\n+  /// causing a long-press.\r\n+  ///\r\n+  /// This triggers once the gesture loses if [onLongPressDown] has previously\r\n+  /// been triggered.\r\n+  ///\r\n+  /// If the user completed the long-press, and the gesture won, then\r\n+  /// [onLongPressStart] and [onLongPress] are called instead.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kPrimaryButton], the button this callback responds to.\r\n+  ///  * [LongPressGestureRecognizer.onLongPressCancel], which exposes this\r\n+  ///    callback at the gesture layer.\r\n+  final GestureLongPressCancelCallback? onLongPressCancel;\r\n+\r\n+  /// Called when a long press gesture with a primary button has been recognized.\r\n+  ///\r\n+  /// Triggered when a pointer has remained in contact with the screen at the\r\n+  /// same location for a long period of time.\r\n+  ///\r\n+  /// This is equivalent to (and is called immediately after) [onLongPressStart].\r\n+  /// The only difference between the two is that this callback does not\r\n+  /// contain details of the position at which the pointer initially contacted\r\n+  /// the screen.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kPrimaryButton], the button this callback responds to.\r\n+  ///  * [LongPressGestureRecognizer.onLongPress], which exposes this\r\n+  ///    callback at the gesture layer.\r\n+  final GestureLongPressCallback? onLongPress;\r\n+\r\n+  /// Called when a long press gesture with a primary button has been recognized.\r\n+  ///\r\n+  /// Triggered when a pointer has remained in contact with the screen at the\r\n+  /// same location for a long period of time.\r\n+  ///\r\n+  /// This is equivalent to (and is called immediately before) [onLongPress].\r\n+  /// The only difference between the two is that this callback contains\r\n+  /// details of the position at which the pointer initially contacted the\r\n+  /// screen, whereas [onLongPress] does not.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kPrimaryButton], the button this callback responds to.\r\n+  ///  * [LongPressGestureRecognizer.onLongPressStart], which exposes this\r\n+  ///    callback at the gesture layer.\r\n+  final GestureLongPressStartCallback? onLongPressStart;\r\n+\r\n+  /// A pointer has been drag-moved after a long-press with a primary button.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kPrimaryButton], the button this callback responds to.\r\n+  ///  * [LongPressGestureRecognizer.onLongPressMoveUpdate], which exposes this\r\n+  ///    callback at the gesture layer.\r\n+  final GestureLongPressMoveUpdateCallback? onLongPressMoveUpdate;\r\n+\r\n+  /// A pointer that has triggered a long-press with a primary button has\r\n+  /// stopped contacting the screen.\r\n+  ///\r\n+  /// This is equivalent to (and is called immediately after) [onLongPressEnd].\r\n+  /// The only difference between the two is that this callback does not\r\n+  /// contain details of the state of the pointer when it stopped contacting\r\n+  /// the screen.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kPrimaryButton], the button this callback responds to.\r\n+  ///  * [LongPressGestureRecognizer.onLongPressUp], which exposes this\r\n+  ///    callback at the gesture layer.\r\n+  final GestureLongPressUpCallback? onLongPressUp;\r\n+\r\n+  /// A pointer that has triggered a long-press with a primary button has\r\n+  /// stopped contacting the screen.\r\n+  ///\r\n+  /// This is equivalent to (and is called immediately before) [onLongPressUp].\r\n+  /// The only difference between the two is that this callback contains\r\n+  /// details of the state of the pointer when it stopped contacting the\r\n+  /// screen, whereas [onLongPressUp] does not.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kPrimaryButton], the button this callback responds to.\r\n+  ///  * [LongPressGestureRecognizer.onLongPressEnd], which exposes this\r\n+  ///    callback at the gesture layer.\r\n+  final GestureLongPressEndCallback? onLongPressEnd;\r\n+\r\n+  /// The pointer has contacted the screen with a secondary button, which might\r\n+  /// be the start of a long-press.\r\n+  ///\r\n+  /// This triggers after the pointer down event.\r\n+  ///\r\n+  /// If the user completes the long-press, and this gesture wins,\r\n+  /// [onSecondaryLongPressStart] will be called after this callback. Otherwise,\r\n+  /// [onSecondaryLongPressCancel] will be called after this callback.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kSecondaryButton], the button this callback responds to.\r\n+  ///  * [onLongPressDown], a similar callback but for a secondary button.\r\n+  ///  * [onTertiaryLongPressDown], a similar callback but for a tertiary button.\r\n+  ///  * [LongPressGestureRecognizer.onSecondaryLongPressDown], which exposes\r\n+  ///    this callback at the gesture layer.\r\n+  final GestureLongPressDownCallback? onSecondaryLongPressDown;\r\n+\r\n+  /// A pointer that previously triggered [onSecondaryLongPressDown] will not\r\n+  /// end up causing a long-press.\r\n+  ///\r\n+  /// This triggers once the gesture loses if [onSecondaryLongPressDown] has\r\n+  /// previously been triggered.\r\n+  ///\r\n+  /// If the user completed the long-press, and the gesture won, then\r\n+  /// [onSecondaryLongPressStart] and [onSecondaryLongPress] are called instead.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kSecondaryButton], the button this callback responds to.\r\n+  ///  * [LongPressGestureRecognizer.onSecondaryLongPressCancel], which exposes\r\n+  ///    this callback at the gesture layer.\r\n+  final GestureLongPressCancelCallback? onSecondaryLongPressCancel;\r\n+\r\n+  /// Called when a long press gesture with a secondary button has been\r\n+  /// recognized.\r\n+  ///\r\n+  /// Triggered when a pointer has remained in contact with the screen at the\r\n+  /// same location for a long period of time.\r\n+  ///\r\n+  /// This is equivalent to (and is called immediately after)\r\n+  /// [onSecondaryLongPressStart]. The only difference between the two is that\r\n+  /// this callback does not contain details of the position at which the\r\n+  /// pointer initially contacted the screen.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kSecondaryButton], the button this callback responds to.\r\n+  ///  * [LongPressGestureRecognizer.onSecondaryLongPress], which exposes\r\n+  ///    this callback at the gesture layer.\r\n+  final GestureLongPressCallback? onSecondaryLongPress;\r\n+\r\n+  /// Called when a long press gesture with a secondary button has been\r\n+  /// recognized.\r\n+  ///\r\n+  /// Triggered when a pointer has remained in contact with the screen at the\r\n+  /// same location for a long period of time.\r\n+  ///\r\n+  /// This is equivalent to (and is called immediately before)\r\n+  /// [onSecondaryLongPress]. The only difference between the two is that this\r\n+  /// callback contains details of the position at which the pointer initially\r\n+  /// contacted the screen, whereas [onSecondaryLongPress] does not.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kSecondaryButton], the button this callback responds to.\r\n+  ///  * [LongPressGestureRecognizer.onSecondaryLongPressStart], which exposes\r\n+  ///    this callback at the gesture layer.\r\n+  final GestureLongPressStartCallback? onSecondaryLongPressStart;\r\n+\r\n+  /// A pointer has been drag-moved after a long press with a secondary button.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kSecondaryButton], the button this callback responds to.\r\n+  ///  * [LongPressGestureRecognizer.onSecondaryLongPressMoveUpdate], which exposes\r\n+  ///    this callback at the gesture layer.\r\n+  final GestureLongPressMoveUpdateCallback? onSecondaryLongPressMoveUpdate;\r\n+\r\n+  /// A pointer that has triggered a long-press with a secondary button has\r\n+  /// stopped contacting the screen.\r\n+  ///\r\n+  /// This is equivalent to (and is called immediately after)\r\n+  /// [onSecondaryLongPressEnd]. The only difference between the two is that\r\n+  /// this callback does not contain details of the state of the pointer when\r\n+  /// it stopped contacting the screen.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kSecondaryButton], the button this callback responds to.\r\n+  ///  * [LongPressGestureRecognizer.onSecondaryLongPressUp], which exposes\r\n+  ///    this callback at the gesture layer.\r\n+  final GestureLongPressUpCallback? onSecondaryLongPressUp;\r\n+\r\n+  /// A pointer that has triggered a long-press with a secondary button has\r\n+  /// stopped contacting the screen.\r\n+  ///\r\n+  /// This is equivalent to (and is called immediately before)\r\n+  /// [onSecondaryLongPressUp]. The only difference between the two is that\r\n+  /// this callback contains details of the state of the pointer when it\r\n+  /// stopped contacting the screen, whereas [onSecondaryLongPressUp] does not.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kSecondaryButton], the button this callback responds to.\r\n+  ///  * [LongPressGestureRecognizer.onSecondaryLongPressEnd], which exposes\r\n+  ///    this callback at the gesture layer.\r\n+  final GestureLongPressEndCallback? onSecondaryLongPressEnd;\r\n+\r\n+  /// The pointer has contacted the screen with a tertiary button, which might\r\n+  /// be the start of a long-press.\r\n+  ///\r\n+  /// This triggers after the pointer down event.\r\n+  ///\r\n+  /// If the user completes the long-press, and this gesture wins,\r\n+  /// [onTertiaryLongPressStart] will be called after this callback. Otherwise,\r\n+  /// [onTertiaryLongPressCancel] will be called after this callback.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kTertiaryButton], the button this callback responds to.\r\n+  ///  * [onLongPressDown], a similar callback but for a primary button.\r\n+  ///  * [onSecondaryLongPressDown], a similar callback but for a secondary button.\r\n+  ///  * [LongPressGestureRecognizer.onTertiaryLongPressDown], which exposes\r\n+  ///    this callback at the gesture layer.\r\n+  final GestureLongPressDownCallback? onTertiaryLongPressDown;\r\n+\r\n+  /// A pointer that previously triggered [onTertiaryLongPressDown] will not\r\n+  /// end up causing a long-press.\r\n+  ///\r\n+  /// This triggers once the gesture loses if [onTertiaryLongPressDown] has\r\n+  /// previously been triggered.\r\n+  ///\r\n+  /// If the user completed the long-press, and the gesture won, then\r\n+  /// [onTertiaryLongPressStart] and [onTertiaryLongPress] are called instead.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kTertiaryButton], the button this callback responds to.\r\n+  ///  * [LongPressGestureRecognizer.onTertiaryLongPressCancel], which exposes\r\n+  ///    this callback at the gesture layer.\r\n+  final GestureLongPressCancelCallback? onTertiaryLongPressCancel;\r\n+\r\n+  /// Called when a long press gesture with a tertiary button has been\r\n+  /// recognized.\r\n+  ///\r\n+  /// Triggered when a pointer has remained in contact with the screen at the\r\n+  /// same location for a long period of time.\r\n+  ///\r\n+  /// This is equivalent to (and is called immediately after)\r\n+  /// [onTertiaryLongPressStart]. The only difference between the two is that\r\n+  /// this callback does not contain details of the position at which the\r\n+  /// pointer initially contacted the screen.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kTertiaryButton], the button this callback responds to.\r\n+  ///  * [LongPressGestureRecognizer.onTertiaryLongPress], which exposes\r\n+  ///    this callback at the gesture layer.\r\n+  final GestureLongPressCallback? onTertiaryLongPress;\r\n+\r\n+  /// Called when a long press gesture with a tertiary button has been\r\n+  /// recognized.\r\n+  ///\r\n+  /// Triggered when a pointer has remained in contact with the screen at the\r\n+  /// same location for a long period of time.\r\n+  ///\r\n+  /// This is equivalent to (and is called immediately before)\r\n+  /// [onTertiaryLongPress]. The only difference between the two is that this\r\n+  /// callback contains details of the position at which the pointer initially\r\n+  /// contacted the screen, whereas [onTertiaryLongPress] does not.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kTertiaryButton], the button this callback responds to.\r\n+  ///  * [LongPressGestureRecognizer.onTertiaryLongPressStart], which exposes\r\n+  ///    this callback at the gesture layer.\r\n+  final GestureLongPressStartCallback? onTertiaryLongPressStart;\r\n+\r\n+  /// A pointer has been drag-moved after a long press with a tertiary button.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kTertiaryButton], the button this callback responds to.\r\n+  ///  * [LongPressGestureRecognizer.onTertiaryLongPressMoveUpdate], which exposes\r\n+  ///    this callback at the gesture layer.\r\n+  final GestureLongPressMoveUpdateCallback? onTertiaryLongPressMoveUpdate;\r\n+\r\n+  /// A pointer that has triggered a long-press with a tertiary button has\r\n+  /// stopped contacting the screen.\r\n+  ///\r\n+  /// This is equivalent to (and is called immediately after)\r\n+  /// [onTertiaryLongPressEnd]. The only difference between the two is that\r\n+  /// this callback does not contain details of the state of the pointer when\r\n+  /// it stopped contacting the screen.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kTertiaryButton], the button this callback responds to.\r\n+  ///  * [LongPressGestureRecognizer.onTertiaryLongPressUp], which exposes\r\n+  ///    this callback at the gesture layer.\r\n+  final GestureLongPressUpCallback? onTertiaryLongPressUp;\r\n+\r\n+  /// A pointer that has triggered a long-press with a tertiary button has\r\n+  /// stopped contacting the screen.\r\n+  ///\r\n+  /// This is equivalent to (and is called immediately before)\r\n+  /// [onTertiaryLongPressUp]. The only difference between the two is that\r\n+  /// this callback contains details of the state of the pointer when it\r\n+  /// stopped contacting the screen, whereas [onTertiaryLongPressUp] does not.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kTertiaryButton], the button this callback responds to.\r\n+  ///  * [LongPressGestureRecognizer.onTertiaryLongPressEnd], which exposes\r\n+  ///    this callback at the gesture layer.\r\n+  final GestureLongPressEndCallback? onTertiaryLongPressEnd;\r\n+\r\n+  /// A pointer has contacted the screen with a primary button and might begin\r\n+  /// to move vertically.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kPrimaryButton], the button this callback responds to.\r\n+  final GestureDragDownCallback? onVerticalDragDown;\r\n+\r\n+  /// A pointer has contacted the screen with a primary button and has begun to\r\n+  /// move vertically.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kPrimaryButton], the button this callback responds to.\r\n+  final GestureDragStartCallback? onVerticalDragStart;\r\n+\r\n+  /// A pointer that is in contact with the screen with a primary button and\r\n+  /// moving vertically has moved in the vertical direction.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kPrimaryButton], the button this callback responds to.\r\n+  final GestureDragUpdateCallback? onVerticalDragUpdate;\r\n+\r\n+  /// A pointer that was previously in contact with the screen with a primary\r\n+  /// button and moving vertically is no longer in contact with the screen and\r\n+  /// was moving at a specific velocity when it stopped contacting the screen.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kPrimaryButton], the button this callback responds to.\r\n+  final GestureDragEndCallback? onVerticalDragEnd;\r\n+\r\n+  /// The pointer that previously triggered [onVerticalDragDown] did not\r\n+  /// complete.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kPrimaryButton], the button this callback responds to.\r\n+  final GestureDragCancelCallback? onVerticalDragCancel;\r\n+\r\n+  /// A pointer has contacted the screen with a primary button and might begin\r\n+  /// to move horizontally.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kPrimaryButton], the button this callback responds to.\r\n+  final GestureDragDownCallback? onHorizontalDragDown;\r\n+\r\n+  /// A pointer has contacted the screen with a primary button and has begun to\r\n+  /// move horizontally.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kPrimaryButton], the button this callback responds to.\r\n+  final GestureDragStartCallback? onHorizontalDragStart;\r\n+\r\n+  /// A pointer that is in contact with the screen with a primary button and\r\n+  /// moving horizontally has moved in the horizontal direction.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kPrimaryButton], the button this callback responds to.\r\n+  final GestureDragUpdateCallback? onHorizontalDragUpdate;\r\n+\r\n+  /// A pointer that was previously in contact with the screen with a primary\r\n+  /// button and moving horizontally is no longer in contact with the screen and\r\n+  /// was moving at a specific velocity when it stopped contacting the screen.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kPrimaryButton], the button this callback responds to.\r\n+  final GestureDragEndCallback? onHorizontalDragEnd;\r\n+\r\n+  /// The pointer that previously triggered [onHorizontalDragDown] did not\r\n+  /// complete.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kPrimaryButton], the button this callback responds to.\r\n+  final GestureDragCancelCallback? onHorizontalDragCancel;\r\n+\r\n+  /// A pointer has contacted the screen with a primary button and might begin\r\n+  /// to move.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kPrimaryButton], the button this callback responds to.\r\n+  final GestureDragDownCallback? onPanDown;\r\n+\r\n+  /// A pointer has contacted the screen with a primary button and has begun to\r\n+  /// move.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kPrimaryButton], the button this callback responds to.\r\n+  final GestureDragStartCallback? onPanStart;\r\n+\r\n+  /// A pointer that is in contact with the screen with a primary button and\r\n+  /// moving has moved again.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kPrimaryButton], the button this callback responds to.\r\n+  final GestureDragUpdateCallback? onPanUpdate;\r\n+\r\n+  /// A pointer that was previously in contact with the screen with a primary\r\n+  /// button and moving is no longer in contact with the screen and was moving\r\n+  /// at a specific velocity when it stopped contacting the screen.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kPrimaryButton], the button this callback responds to.\r\n+  final GestureDragEndCallback? onPanEnd;\r\n+\r\n+  /// The pointer that previously triggered [onPanDown] did not complete.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [kPrimaryButton], the button this callback responds to.\r\n+  final GestureDragCancelCallback? onPanCancel;\r\n+\r\n+  /// The pointers in contact with the screen have established a focal point and\r\n+  /// initial scale of 1.0.\r\n+  final GestureScaleStartCallback? onScaleStart;\r\n+\r\n+  /// The pointers in contact with the screen have indicated a new focal point\r\n+  /// and/or scale.\r\n+  final GestureScaleUpdateCallback? onScaleUpdate;\r\n+\r\n+  /// The pointers are no longer in contact with the screen.\r\n+  final GestureScaleEndCallback? onScaleEnd;\r\n+\r\n+  /// The pointer is in contact with the screen and has pressed with sufficient\r\n+  /// force to initiate a force press. The amount of force is at least\r\n+  /// [ForcePressGestureRecognizer.startPressure].\r\n+  ///\r\n+  /// This callback will only be fired on devices with pressure\r\n+  /// detecting screens.\r\n+  final GestureForcePressStartCallback? onForcePressStart;\r\n+\r\n+  /// The pointer is in contact with the screen and has pressed with the maximum\r\n+  /// force. The amount of force is at least\r\n+  /// [ForcePressGestureRecognizer.peakPressure].\r\n+  ///\r\n+  /// This callback will only be fired on devices with pressure\r\n+  /// detecting screens.\r\n+  final GestureForcePressPeakCallback? onForcePressPeak;\r\n+\r\n+  /// A pointer is in contact with the screen, has previously passed the\r\n+  /// [ForcePressGestureRecognizer.startPressure] and is either moving on the\r\n+  /// plane of the screen, pressing the screen with varying forces or both\r\n+  /// simultaneously.\r\n+  ///\r\n+  /// This callback will only be fired on devices with pressure\r\n+  /// detecting screens.\r\n+  final GestureForcePressUpdateCallback? onForcePressUpdate;\r\n+\r\n+  /// The pointer tracked by [onForcePressStart] is no longer in contact with the screen.\r\n+  ///\r\n+  /// This callback will only be fired on devices with pressure\r\n+  /// detecting screens.\r\n+  final GestureForcePressEndCallback? onForcePressEnd;\r\n+\r\n+  /// How this gesture detector should behave during hit testing when deciding\r\n+  /// how the hit test propagates to children and whether to consider targets\r\n+  /// behind this one.\r\n+  ///\r\n+  /// This defaults to [HitTestBehavior.deferToChild] if [child] is not null and\r\n+  /// [HitTestBehavior.translucent] if child is null.\r\n+  ///\r\n+  /// See [HitTestBehavior] for the allowed values and their meanings.\r\n+  final HitTestBehavior? behavior;\r\n+\r\n+  /// Whether to exclude these gestures from the semantics tree. For\r\n+  /// example, the long-press gesture for showing a tooltip is\r\n+  /// excluded because the tooltip itself is included in the semantics\r\n+  /// tree directly and so having a gesture to show it would result in\r\n+  /// duplication of information.\r\n+  final bool excludeFromSemantics;\r\n+\r\n+  /// Determines the way that drag start behavior is handled.\r\n+  ///\r\n+  /// If set to [DragStartBehavior.start], gesture drag behavior will\r\n+  /// begin at the position where the drag gesture won the arena. If set to\r\n+  /// [DragStartBehavior.down] it will begin at the position where a down event\r\n+  /// is first detected.\r\n+  ///\r\n+  /// In general, setting this to [DragStartBehavior.start] will make drag\r\n+  /// animation smoother and setting it to [DragStartBehavior.down] will make\r\n+  /// drag behavior feel slightly more reactive.\r\n+  ///\r\n+  /// By default, the drag start behavior is [DragStartBehavior.start].\r\n+  ///\r\n+  /// Only the [DragGestureRecognizer.onStart] callbacks for the\r\n+  /// [VerticalDragGestureRecognizer], [HorizontalDragGestureRecognizer] and\r\n+  /// [PanGestureRecognizer] are affected by this setting.\r\n+  ///\r\n+  /// See also:\r\n+  ///\r\n+  ///  * [DragGestureRecognizer.dragStartBehavior], which gives an example for the different behaviors.\r\n+  final DragStartBehavior dragStartBehavior;\r\n+\r\n+  /// The kind of devices that are allowed to be recognized.\r\n+  ///\r\n+  /// If set to null, events from all device types will be recognized. Defaults to null.\r\n+  final Set<PointerDeviceKind>? supportedDevices;\r\n+\r\n+  /// {@macro flutter.gestures.scale.trackpadScrollCausesScale}\r\n+  final bool trackpadScrollCausesScale;\r\n+\r\n+  /// {@macro flutter.gestures.scale.trackpadScrollToScaleFactor}\r\n+  final Offset trackpadScrollToScaleFactor;\r\n+\r\n+  @override\r\n+  Widget build(BuildContext context) {\r\n+    return MouseRegion(\r\n+      cursor: \r\n+      child: GestureDetector(\r\n+        onTapDown: onTapDown,\r\n+        onTapUp: onTapUp,\r\n+        onTap: onTap,\r\n+        onTapCancel: onTapCancel,\r\n+        onSecondaryTap: onSecondaryTap,\r\n+        onSecondaryTapDown: onSecondaryTapDown,\r\n+        onSecondaryTapUp: onSecondaryTapUp,\r\n+        onSecondaryTapCancel: onSecondaryTapCancel,\r\n+        onTertiaryTapDown: onTertiaryTapDown,\r\n+        onTertiaryTapUp: onTertiaryTapUp,\r\n+        onTertiaryTapCancel: onTertiaryTapCancel,\r\n+        onDoubleTapDown: onDoubleTapDown,\r\n+        onDoubleTap: onDoubleTap,\r\n+        onDoubleTapCancel: onDoubleTapCancel,\r\n+        onLongPressDown: onLongPressDown,\r\n+        onLongPressCancel: onLongPressCancel,\r\n+        onLongPress: onLongPress,\r\n+        onLongPressStart: onLongPressStart,\r\n+        onLongPressMoveUpdate: onLongPressMoveUpdate,\r\n+        onLongPressUp: onLongPressUp,\r\n+        onLongPressEnd: onLongPressEnd,\r\n+        onSecondaryLongPressDown: onSecondaryLongPressDown,\r\n+        onSecondaryLongPressCancel: onSecondaryLongPressCancel,\r\n+        onSecondaryLongPress: onSecondaryLongPress,\r\n+        onSecondaryLongPressStart: onSecondaryLongPressStart,\r\n+        onSecondaryLongPressMoveUpdate: onSecondaryLongPressMoveUpdate,\r\n+        onSecondaryLongPressUp: onSecondaryLongPressUp,\r\n+        onSecondaryLongPressEnd: onSecondaryLongPressEnd,\r\n+        onTertiaryLongPressDown: onTertiaryLongPressDown,\r\n+        onTertiaryLongPressCancel: onTertiaryLongPressCancel,\r\n+        onTertiaryLongPress: onTertiaryLongPress,\r\n+        onTertiaryLongPressStart: onTertiaryLongPressStart,\r\n+        onTertiaryLongPressMoveUpdate: onTertiaryLongPressMoveUpdate,\r\n+        onTertiaryLongPressUp: onTertiaryLongPressUp,\r\n+        onTertiaryLongPressEnd: onTertiaryLongPressEnd,\r\n+        onVerticalDragDown: onVerticalDragDown,\r\n+        onVerticalDragStart: onVerticalDragStart,\r\n+        onVerticalDragUpdate: onVerticalDragUpdate,\r\n+        onVerticalDragEnd: onVerticalDragEnd,\r\n+        onVerticalDragCancel: onVerticalDragCancel,\r\n+        onHorizontalDragDown: onHorizontalDragDown,\r\n+        onHorizontalDragStart: onHorizontalDragStart,\r\n+        onHorizontalDragUpdate: onHorizontalDragUpdate,\r\n+        onHorizontalDragEnd: onHorizontalDragEnd,\r\n+        onHorizontalDragCancel: onHorizontalDragCancel,\r\n+        onPanDown: onPanDown,\r\n+        onPanStart: onPanStart,\r\n+        onPanUpdate: onPanUpdate,\r\n+        onPanEnd: onPanEnd,\r\n+        onPanCancel: onPanCancel,\r\n+        onScaleStart: onScaleStart,\r\n+        onScaleUpdate: onScaleUpdate,\r\n+        onScaleEnd: onScaleEnd,\r\n+        onForcePressStart: onForcePressStart,\r\n+        onForcePressPeak: onForcePressPeak,\r\n+        onForcePressUpdate: onForcePressUpdate,\r\n+        onForcePressEnd: onForcePressEnd,\r\n+        behavior: behavior,\r\n+        excludeFromSemantics: excludeFromSemantics,\r\n+        dragStartBehavior: dragStartBehavior,\r\n+        supportedDevices: supportedDevices,\r\n+        trackpadScrollCausesScale: trackpadScrollCausesScale,\r\n+        trackpadScrollToScaleFactor: trackpadScrollToScaleFactor,\r\n+        child: child,\r\n+      ),\r\n+    );\r\n+  }\r\n+}\r\n"
                }
            ],
            "date": 1698748058137,
            "name": "Commit-0",
            "content": "\r\n"
        }
    ]
}