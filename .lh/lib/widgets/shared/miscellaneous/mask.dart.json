{
    "sourceFile": "lib/widgets/shared/miscellaneous/mask.dart",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 14,
            "patches": [
                {
                    "date": 1698773867040,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1698773899049,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,7 +1,9 @@\n-import 'package:flutter/rendering.dart';\r\n-import 'package:flutter/widgets.dart';\r\n+// ignore_for_file: prefer_asserts_with_message, overridden_fields\r\n \r\n+import \"package:flutter/rendering.dart\";\r\n+import \"package:flutter/widgets.dart\";\r\n+\r\n /// A widget, which paints its [child] into a separate save layer.\r\n ///\r\n /// The [Paint], that is used for the save layer, can be set through [paint].\r\n ///\r\n@@ -12,13 +14,13 @@\n /// [debugCheckChildDoesNotNeedCompositing] to `false`.\r\n class SaveLayer extends SingleChildRenderObjectWidget {\r\n   /// Creates a widget, which paints its [child] into a separate save layer.\r\n   const SaveLayer({\r\n-    Key? key,\r\n+    super.key,\r\n     this.paint,\r\n     this.debugCheckChildDoesNotNeedCompositing = true,\r\n     this.child,\r\n-  }) : super(key: key, child: child);\r\n+  }) : super(child: child);\r\n \r\n   /// The [Paint] to use for the save layer.\r\n   ///\r\n   /// If this is `null`, `Paint()` will be used.\r\n@@ -53,9 +55,9 @@\n \r\n   @override\r\n   void debugFillProperties(DiagnosticPropertiesBuilder properties) {\r\n     super.debugFillProperties(properties);\r\n-    properties.add(DiagnosticsProperty<Paint?>('paint', paint));\r\n+    properties.add(DiagnosticsProperty<Paint?>(\"paint\", paint));\r\n   }\r\n }\r\n \r\n /// A [RenderProxyBox], that paints its child into a separate save layer.\r\n@@ -75,9 +77,11 @@\n   Paint? get saveLayerPaint => _saveLayerPaint;\r\n   Paint? _saveLayerPaint;\r\n \r\n   set saveLayerPaint(Paint? saveLayerPaint) {\r\n-    if (_saveLayerPaint == saveLayerPaint) return;\r\n+    if (_saveLayerPaint == saveLayerPaint) {\r\n+      return;\r\n+    }\r\n     markNeedsPaint();\r\n     _saveLayerPaint = saveLayerPaint;\r\n   }\r\n \r\n@@ -86,9 +90,11 @@\n   bool get debugCheckChildDoesNotNeedCompositing => _debugCheckChildDoesNotNeedCompositing;\r\n   bool _debugCheckChildDoesNotNeedCompositing;\r\n \r\n   set debugCheckChildDoesNotNeedCompositing(bool debugCheckChildDoesNotNeedCompositing) {\r\n-    if (_debugCheckChildDoesNotNeedCompositing == debugCheckChildDoesNotNeedCompositing) return;\r\n+    if (_debugCheckChildDoesNotNeedCompositing == debugCheckChildDoesNotNeedCompositing) {\r\n+      return;\r\n+    }\r\n     markNeedsCompositingBitsUpdate();\r\n     _debugCheckChildDoesNotNeedCompositing = debugCheckChildDoesNotNeedCompositing;\r\n   }\r\n \r\n@@ -104,9 +110,9 @@\n   }\r\n \r\n   @override\r\n   void paint(PaintingContext context, Offset offset) {\r\n-    final child = this.child;\r\n+    var child = this.child;\r\n     if (child == null) {\r\n       return;\r\n     }\r\n \r\n@@ -115,36 +121,38 @@\n     context.canvas.restore();\r\n   }\r\n \r\n   void _debugChildDoesNotNeedCompositing() {\r\n-    final child = this.child;\r\n+    var child = this.child;\r\n     if (child == null) {\r\n       return;\r\n     }\r\n \r\n     if (child.needsCompositing) {\r\n       throw FlutterError.fromParts([\r\n-        ErrorSummary('`SaveLayer.child` cannot contain compositing layers.'),\r\n+        ErrorSummary(\"`SaveLayer.child` cannot contain compositing layers.\"),\r\n         ErrorDescription(\r\n-          'The save layer, into which SaveLayer.child is painted, cannot '\r\n-          'encompass compositing layers.',\r\n+          \"The save layer, into which SaveLayer.child is painted, cannot \"\r\n+          \"encompass compositing layers.\",\r\n         ),\r\n         ErrorHint(\r\n-          'Ensure `SaveLayer.child` contains no widgets which need '\r\n-          'compositing, such as `RepaintBoundary`.',\r\n+          \"Ensure `SaveLayer.child` contains no widgets which need \"\r\n+          \"compositing, such as `RepaintBoundary`.\",\r\n         ),\r\n-        _leafCompositingRenderObjects(child).first.describeForError('')\r\n+        _leafCompositingRenderObjects(child).first.describeForError(\"\"),\r\n       ]);\r\n     }\r\n   }\r\n \r\n   @override\r\n   void debugFillProperties(DiagnosticPropertiesBuilder properties) {\r\n     super.debugFillProperties(properties);\r\n-    properties.add(DiagnosticsProperty<Paint?>(\r\n-      'saveLayerPaint',\r\n-      saveLayerPaint,\r\n-    ));\r\n+    properties.add(\r\n+      DiagnosticsProperty<Paint?>(\r\n+        \"saveLayerPaint\",\r\n+        saveLayerPaint,\r\n+      ),\r\n+    );\r\n   }\r\n }\r\n \r\n Iterable<RenderObject> _leafCompositingRenderObjects(\r\n@@ -152,9 +160,9 @@\n ) =>\r\n     (_renderTreeNodes(renderObject).toList()..sort((a, b) => a.depth - b.depth)).where(_isLeafCompositingRenderObject);\r\n \r\n Iterable<RenderObject> _renderTreeNodes(RenderObject root) sync* {\r\n-  final children = <RenderObject>[];\r\n+  var children = <RenderObject>[];\r\n   root.visitChildren((child) {\r\n     children.add(child);\r\n   });\r\n   yield root;\r\n"
                },
                {
                    "date": 1698774564204,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,8 +2,100 @@\n \r\n import \"package:flutter/rendering.dart\";\r\n import \"package:flutter/widgets.dart\";\r\n \r\n+/// A widget which paints a [mask] widget into a save layer and blends that\r\n+/// layer with its [child].\r\n+///\r\n+/// [blendMode] determines how [mask] and [child] are blended with each other.\r\n+/// In the context of this widget [mask] is the `src` and [child] the `dst`.\r\n+///\r\n+/// This widget sizes itself to the dimensions of [child] and forces [mask] to\r\n+/// the same size. For the purpose of hit testing [mask] is painted over\r\n+/// [child].\r\n+///\r\n+/// Since [mask] is panted into a save layer, this widget is relatively\r\n+/// expensive. See [Canvas.saveLayer] for more on the performance implications\r\n+/// of a save layer.\r\n+///\r\n+/// [mask] must not contain [RenderObject]s which need compositing because\r\n+/// the save layer into which [mask] is painted cannot encompass compositing\r\n+/// layers. `RepaintBoundary` is a widget, whose [RenderObject] needs\r\n+/// compositing, for example.\r\n+class WidgetMask extends StatelessWidget {\r\n+  /// Creates a widget which paints a [mask] widget into a save layer and blends\r\n+  /// that layer with its [child].\r\n+  const WidgetMask({\r\n+    required this.mask,\r\n+    required this.child,\r\n+    super.key,\r\n+    this.blendMode = BlendMode.srcOver,\r\n+    this.childSaveLayer = false,\r\n+  });\r\n+\r\n+  /// The [BlendMode] to use when blending the [mask] save layer with [child].\r\n+  ///\r\n+  /// In the context of this widget [mask] is the `src` and [child] the `dst`.\r\n+  final BlendMode blendMode;\r\n+\r\n+  /// Whether to paint [child] in its own save layer.\r\n+  ///\r\n+  /// This allows you to blend [child] and [mask] without the transparent\r\n+  /// areas of [child] influencing the result.\r\n+  ///\r\n+  /// Enabling this option impacts performance, since it adds another save layer\r\n+  /// and should only be done if necessary.\r\n+  final bool childSaveLayer;\r\n+\r\n+  /// The widget which is painted over the [child] widget, in a save layer with\r\n+  /// [BlendMode] [blendMode].\r\n+  final Widget mask;\r\n+\r\n+  /// The widget which determines the size of this widget and is painted behind\r\n+  /// the [mask] widget.\r\n+  final Widget child;\r\n+\r\n+  @override\r\n+  Widget build(BuildContext context) {\r\n+    Widget child = Stack(\r\n+      textDirection: TextDirection.ltr,\r\n+      // fit: StackFit.passthrough,\r\n+      children: [\r\n+        this.child,\r\n+        Positioned.fill(\r\n+          child: SaveLayer(\r\n+            paint: Paint()..blendMode = blendMode,\r\n+            child: mask,\r\n+          ),\r\n+        ),\r\n+      ],\r\n+    );\r\n+\r\n+    if (childSaveLayer) {\r\n+      child = SaveLayer(\r\n+        child: child,\r\n+      );\r\n+    }\r\n+\r\n+    return child;\r\n+  }\r\n+\r\n+  @override\r\n+  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\r\n+    super.debugFillProperties(properties);\r\n+    properties\r\n+      ..add(EnumProperty(\"blendMode\", blendMode))\r\n+      ..add(\r\n+        FlagProperty(\r\n+          \"childSaveLayer\",\r\n+          value: childSaveLayer,\r\n+          ifTrue: \"CHILD-SAVE-LAYER\",\r\n+          defaultValue: false,\r\n+        ),\r\n+      );\r\n+  }\r\n+}\r\n+\r\n /// A widget, which paints its [child] into a separate save layer.\r\n ///\r\n /// The [Paint], that is used for the save layer, can be set through [paint].\r\n ///\r\n"
                },
                {
                    "date": 1698774609249,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -110,8 +110,9 @@\n     super.key,\r\n     this.paint,\r\n     this.debugCheckChildDoesNotNeedCompositing = true,\r\n     this.child,\r\n+    \r\n   }) : super(child: child);\r\n \r\n   /// The [Paint] to use for the save layer.\r\n   ///\r\n"
                },
                {
                    "date": 1698774755910,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -59,9 +59,9 @@\n     Widget child = Stack(\r\n       textDirection: TextDirection.ltr,\r\n       // fit: StackFit.passthrough,\r\n       children: [\r\n-        this.child,\r\n+        ,\r\n         Positioned.fill(\r\n           child: SaveLayer(\r\n             paint: Paint()..blendMode = blendMode,\r\n             child: mask,\r\n@@ -110,9 +110,8 @@\n     super.key,\r\n     this.paint,\r\n     this.debugCheckChildDoesNotNeedCompositing = true,\r\n     this.child,\r\n-    \r\n   }) : super(child: child);\r\n \r\n   /// The [Paint] to use for the save layer.\r\n   ///\r\n"
                },
                {
                    "date": 1698774954863,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -59,9 +59,9 @@\n     Widget child = Stack(\r\n       textDirection: TextDirection.ltr,\r\n       // fit: StackFit.passthrough,\r\n       children: [\r\n-        ,\r\n+        SaveLayer(child: this.child),\r\n         Positioned.fill(\r\n           child: SaveLayer(\r\n             paint: Paint()..blendMode = blendMode,\r\n             child: mask,\r\n@@ -71,8 +71,9 @@\n     );\r\n \r\n     if (childSaveLayer) {\r\n       child = SaveLayer(\r\n+        \r\n         child: child,\r\n       );\r\n     }\r\n \r\n"
                },
                {
                    "date": 1698775397369,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -59,9 +59,9 @@\n     Widget child = Stack(\r\n       textDirection: TextDirection.ltr,\r\n       // fit: StackFit.passthrough,\r\n       children: [\r\n-        SaveLayer(child: this.child),\r\n+        SaveLayer(paint: Paintchild: this.child),\r\n         Positioned.fill(\r\n           child: SaveLayer(\r\n             paint: Paint()..blendMode = blendMode,\r\n             child: mask,\r\n@@ -71,9 +71,9 @@\n     );\r\n \r\n     if (childSaveLayer) {\r\n       child = SaveLayer(\r\n-        \r\n+        paint: Paint(),\r\n         child: child,\r\n       );\r\n     }\r\n \r\n"
                },
                {
                    "date": 1698775545746,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,276 @@\n+// ignore_for_file: prefer_asserts_with_message, overridden_fields\r\n+\r\n+import \"package:flutter/rendering.dart\";\r\n+import \"package:flutter/widgets.dart\";\r\n+\r\n+/// A widget which paints a [mask] widget into a save layer and blends that\r\n+/// layer with its [child].\r\n+///\r\n+/// [blendMode] determines how [mask] and [child] are blended with each other.\r\n+/// In the context of this widget [mask] is the `src` and [child] the `dst`.\r\n+///\r\n+/// This widget sizes itself to the dimensions of [child] and forces [mask] to\r\n+/// the same size. For the purpose of hit testing [mask] is painted over\r\n+/// [child].\r\n+///\r\n+/// Since [mask] is panted into a save layer, this widget is relatively\r\n+/// expensive. See [Canvas.saveLayer] for more on the performance implications\r\n+/// of a save layer.\r\n+///\r\n+/// [mask] must not contain [RenderObject]s which need compositing because\r\n+/// the save layer into which [mask] is painted cannot encompass compositing\r\n+/// layers. `RepaintBoundary` is a widget, whose [RenderObject] needs\r\n+/// compositing, for example.\r\n+class WidgetMask extends StatelessWidget {\r\n+  /// Creates a widget which paints a [mask] widget into a save layer and blends\r\n+  /// that layer with its [child].\r\n+  const WidgetMask({\r\n+    required this.mask,\r\n+    required this.child,\r\n+    super.key,\r\n+    this.blendMode = BlendMode.srcOver,\r\n+    this.childSaveLayer = false,\r\n+  });\r\n+\r\n+  /// The [BlendMode] to use when blending the [mask] save layer with [child].\r\n+  ///\r\n+  /// In the context of this widget [mask] is the `src` and [child] the `dst`.\r\n+  final BlendMode blendMode;\r\n+\r\n+  /// Whether to paint [child] in its own save layer.\r\n+  ///\r\n+  /// This allows you to blend [child] and [mask] without the transparent\r\n+  /// areas of [child] influencing the result.\r\n+  ///\r\n+  /// Enabling this option impacts performance, since it adds another save layer\r\n+  /// and should only be done if necessary.\r\n+  final bool childSaveLayer;\r\n+\r\n+  /// The widget which is painted over the [child] widget, in a save layer with\r\n+  /// [BlendMode] [blendMode].\r\n+  final Widget mask;\r\n+\r\n+  /// The widget which determines the size of this widget and is painted behind\r\n+  /// the [mask] widget.\r\n+  final Widget child;\r\n+\r\n+  @override\r\n+  Widget build(BuildContext context) {\r\n+    Widget child = Stack(\r\n+      textDirection: TextDirection.ltr,\r\n+      // fit: StackFit.passthrough,\r\n+      children: [\r\n+        this.child,\r\n+        Positioned.fill(\r\n+          child: SaveLayer(\r\n+            paint: Paint()..blendMode = blendMode,\r\n+            child: mask,\r\n+          ),\r\n+        ),\r\n+      ],\r\n+    );\r\n+\r\n+    if (childSaveLayer) {\r\n+      child = SaveLayer(\r\n+        child: child,\r\n+      );\r\n+    }\r\n+\r\n+    return child;\r\n+  }\r\n+\r\n+  @override\r\n+  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\r\n+    super.debugFillProperties(properties);\r\n+    properties\r\n+      ..add(EnumProperty(\"blendMode\", blendMode))\r\n+      ..add(\r\n+        FlagProperty(\r\n+          \"childSaveLayer\",\r\n+          value: childSaveLayer,\r\n+          ifTrue: \"CHILD-SAVE-LAYER\",\r\n+          defaultValue: false,\r\n+        ),\r\n+      );\r\n+  }\r\n+}\r\n+\r\n+/// A widget, which paints its [child] into a separate save layer.\r\n+///\r\n+/// The [Paint], that is used for the save layer, can be set through [paint].\r\n+///\r\n+/// Widgets that need compositing will only be partially or not at all painted\r\n+/// into the save layer. This can cause unexpected results, which is why\r\n+/// widgets that need compositing will cause an exception in debug mode, when\r\n+/// used as the [child]. To disable this check, set\r\n+/// [debugCheckChildDoesNotNeedCompositing] to `false`.\r\n+class SaveLayer extends SingleChildRenderObjectWidget {\r\n+  /// Creates a widget, which paints its [child] into a separate save layer.\r\n+  const SaveLayer({\r\n+    super.key,\r\n+    this.paint,\r\n+    this.debugCheckChildDoesNotNeedCompositing = true,\r\n+    this.child,\r\n+  }) : super(child: child);\r\n+\r\n+  /// The [Paint] to use for the save layer.\r\n+  ///\r\n+  /// If this is `null`, `Paint()` will be used.\r\n+  final Paint? paint;\r\n+\r\n+  /// Whether to check that [child] does not need compositing.\r\n+  // ignore: diagnostic_describe_all_properties\r\n+  final bool debugCheckChildDoesNotNeedCompositing;\r\n+\r\n+  /// The widget which will be painted into it's own save layer.\r\n+  ///\r\n+  /// {@macro flutter.widgets.ProxyWidget.child}\r\n+  @override\r\n+  final Widget? child;\r\n+\r\n+  @override\r\n+  RenderObject createRenderObject(BuildContext context) => RenderSaveLayer(\r\n+        saveLayerPaint: paint,\r\n+        debugCheckChildDoesNotNeedCompositing: debugCheckChildDoesNotNeedCompositing,\r\n+      );\r\n+\r\n+  @override\r\n+  void updateRenderObject(\r\n+    BuildContext context,\r\n+    covariant RenderSaveLayer renderObject,\r\n+  ) {\r\n+    super.updateRenderObject(context, renderObject);\r\n+    renderObject\r\n+      ..saveLayerPaint = paint\r\n+      ..debugCheckChildDoesNotNeedCompositing = debugCheckChildDoesNotNeedCompositing;\r\n+  }\r\n+\r\n+  @override\r\n+  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\r\n+    super.debugFillProperties(properties);\r\n+    properties.add(DiagnosticsProperty<Paint?>(\"paint\", paint));\r\n+  }\r\n+}\r\n+\r\n+/// A [RenderProxyBox], that paints its child into a separate save layer.\r\n+class RenderSaveLayer extends RenderProxyBox {\r\n+  /// Creates a [RenderProxyBox], that paints its child into a separate save\r\n+  /// layer.\r\n+  RenderSaveLayer({\r\n+    required Paint? saveLayerPaint,\r\n+    required bool debugCheckChildDoesNotNeedCompositing,\r\n+  })  : _saveLayerPaint = saveLayerPaint,\r\n+        _debugCheckChildDoesNotNeedCompositing = debugCheckChildDoesNotNeedCompositing,\r\n+        super();\r\n+\r\n+  /// The [Paint] to use for the save layer.\r\n+  ///\r\n+  /// If this is `null`, `Paint()` will be used.\r\n+  Paint? get saveLayerPaint => _saveLayerPaint;\r\n+  Paint? _saveLayerPaint;\r\n+\r\n+  set saveLayerPaint(Paint? saveLayerPaint) {\r\n+    if (_saveLayerPaint == saveLayerPaint) {\r\n+      return;\r\n+    }\r\n+    markNeedsPaint();\r\n+    _saveLayerPaint = saveLayerPaint;\r\n+  }\r\n+\r\n+  /// Whether to check that [child] does not need compositing.\r\n+  // ignore: diagnostic_describe_all_properties\r\n+  bool get debugCheckChildDoesNotNeedCompositing => _debugCheckChildDoesNotNeedCompositing;\r\n+  bool _debugCheckChildDoesNotNeedCompositing;\r\n+\r\n+  set debugCheckChildDoesNotNeedCompositing(bool debugCheckChildDoesNotNeedCompositing) {\r\n+    if (_debugCheckChildDoesNotNeedCompositing == debugCheckChildDoesNotNeedCompositing) {\r\n+      return;\r\n+    }\r\n+    markNeedsCompositingBitsUpdate();\r\n+    _debugCheckChildDoesNotNeedCompositing = debugCheckChildDoesNotNeedCompositing;\r\n+  }\r\n+\r\n+  @override\r\n+  bool get needsCompositing {\r\n+    // assert(() {\r\n+    //   if (_debugCheckChildDoesNotNeedCompositing) {\r\n+    //     _debugChildDoesNotNeedCompositing();\r\n+    //   }\r\n+    //   return true;\r\n+    // }());\r\n+    return super.needsCompositing;\r\n+  }\r\n+\r\n+  @override\r\n+  void paint(PaintingContext context, Offset offset) {\r\n+    var child = this.child;\r\n+    if (child == null) {\r\n+      return;\r\n+    }\r\n+\r\n+    context.canvas.saveLayer(offset & size, _saveLayerPaint ?? Paint());\r\n+    context.paintChild(child, offset);\r\n+    context.canvas.restore();\r\n+  }\r\n+\r\n+  void _debugChildDoesNotNeedCompositing() {\r\n+    var child = this.child;\r\n+    if (child == null) {\r\n+      return;\r\n+    }\r\n+\r\n+    if (child.needsCompositing) {\r\n+      throw FlutterError.fromParts([\r\n+        ErrorSummary(\"`SaveLayer.child` cannot contain compositing layers.\"),\r\n+        ErrorDescription(\r\n+          \"The save layer, into which SaveLayer.child is painted, cannot \"\r\n+          \"encompass compositing layers.\",\r\n+        ),\r\n+        ErrorHint(\r\n+          \"Ensure `SaveLayer.child` contains no widgets which need \"\r\n+          \"compositing, such as `RepaintBoundary`.\",\r\n+        ),\r\n+        _leafCompositingRenderObjects(child).first.describeForError(\"\"),\r\n+      ]);\r\n+    }\r\n+  }\r\n+\r\n+  @override\r\n+  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\r\n+    super.debugFillProperties(properties);\r\n+    properties.add(\r\n+      DiagnosticsProperty<Paint?>(\r\n+        \"saveLayerPaint\",\r\n+        saveLayerPaint,\r\n+      ),\r\n+    );\r\n+  }\r\n+}\r\n+\r\n+Iterable<RenderObject> _leafCompositingRenderObjects(\r\n+  RenderObject renderObject,\r\n+) =>\r\n+    (_renderTreeNodes(renderObject).toList()..sort((a, b) => a.depth - b.depth)).where(_isLeafCompositingRenderObject);\r\n+\r\n+Iterable<RenderObject> _renderTreeNodes(RenderObject root) sync* {\r\n+  var children = <RenderObject>[];\r\n+  root.visitChildren((child) {\r\n+    children.add(child);\r\n+  });\r\n+  yield root;\r\n+  yield* children.expand((child) => _renderTreeNodes(child));\r\n+}\r\n+\r\n+bool _isLeafCompositingRenderObject(RenderObject renderObject) {\r\n+  if (renderObject.needsCompositing) {\r\n+    var hasChildThatNeedsCompositing = false;\r\n+    renderObject.visitChildren((child) {\r\n+      if (!hasChildThatNeedsCompositing) {\r\n+        hasChildThatNeedsCompositing = child.needsCompositing;\r\n+      }\r\n+    });\r\n+    return !hasChildThatNeedsCompositing;\r\n+  } else {\r\n+    return false;\r\n+  }\r\n+}\r\n"
                },
                {
                    "date": 1698776205905,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -189,18 +189,18 @@\n     markNeedsCompositingBitsUpdate();\r\n     _debugCheckChildDoesNotNeedCompositing = debugCheckChildDoesNotNeedCompositing;\r\n   }\r\n \r\n-  @override\r\n-  bool get needsCompositing {\r\n-    // assert(() {\r\n-    //   if (_debugCheckChildDoesNotNeedCompositing) {\r\n-    //     _debugChildDoesNotNeedCompositing();\r\n-    //   }\r\n-    //   return true;\r\n-    // }());\r\n-    return super.needsCompositing;\r\n-  }\r\n+  // @override\r\n+  // bool get needsCompositing {\r\n+  //   assert(() {\r\n+  //     if (_debugCheckChildDoesNotNeedCompositing) {\r\n+  //       _debugChildDoesNotNeedCompositing();\r\n+  //     }\r\n+  //     return true;\r\n+  //   }());\r\n+  //   return super.needsCompositing;\r\n+  // }\r\n \r\n   @override\r\n   void paint(PaintingContext context, Offset offset) {\r\n     var child = this.child;\r\n@@ -273,281 +273,4 @@\n   } else {\r\n     return false;\r\n   }\r\n }\r\n-// ignore_for_file: prefer_asserts_with_message, overridden_fields\r\n-\r\n-import \"package:flutter/rendering.dart\";\r\n-import \"package:flutter/widgets.dart\";\r\n-\r\n-/// A widget which paints a [mask] widget into a save layer and blends that\r\n-/// layer with its [child].\r\n-///\r\n-/// [blendMode] determines how [mask] and [child] are blended with each other.\r\n-/// In the context of this widget [mask] is the `src` and [child] the `dst`.\r\n-///\r\n-/// This widget sizes itself to the dimensions of [child] and forces [mask] to\r\n-/// the same size. For the purpose of hit testing [mask] is painted over\r\n-/// [child].\r\n-///\r\n-/// Since [mask] is panted into a save layer, this widget is relatively\r\n-/// expensive. See [Canvas.saveLayer] for more on the performance implications\r\n-/// of a save layer.\r\n-///\r\n-/// [mask] must not contain [RenderObject]s which need compositing because\r\n-/// the save layer into which [mask] is painted cannot encompass compositing\r\n-/// layers. `RepaintBoundary` is a widget, whose [RenderObject] needs\r\n-/// compositing, for example.\r\n-class WidgetMask extends StatelessWidget {\r\n-  /// Creates a widget which paints a [mask] widget into a save layer and blends\r\n-  /// that layer with its [child].\r\n-  const WidgetMask({\r\n-    required this.mask,\r\n-    required this.child,\r\n-    super.key,\r\n-    this.blendMode = BlendMode.srcOver,\r\n-    this.childSaveLayer = false,\r\n-  });\r\n-\r\n-  /// The [BlendMode] to use when blending the [mask] save layer with [child].\r\n-  ///\r\n-  /// In the context of this widget [mask] is the `src` and [child] the `dst`.\r\n-  final BlendMode blendMode;\r\n-\r\n-  /// Whether to paint [child] in its own save layer.\r\n-  ///\r\n-  /// This allows you to blend [child] and [mask] without the transparent\r\n-  /// areas of [child] influencing the result.\r\n-  ///\r\n-  /// Enabling this option impacts performance, since it adds another save layer\r\n-  /// and should only be done if necessary.\r\n-  final bool childSaveLayer;\r\n-\r\n-  /// The widget which is painted over the [child] widget, in a save layer with\r\n-  /// [BlendMode] [blendMode].\r\n-  final Widget mask;\r\n-\r\n-  /// The widget which determines the size of this widget and is painted behind\r\n-  /// the [mask] widget.\r\n-  final Widget child;\r\n-\r\n-  @override\r\n-  Widget build(BuildContext context) {\r\n-    Widget child = Stack(\r\n-      textDirection: TextDirection.ltr,\r\n-      // fit: StackFit.passthrough,\r\n-      children: [\r\n-        SaveLayer(paint: Paintchild: this.child),\r\n-        Positioned.fill(\r\n-          child: SaveLayer(\r\n-            paint: Paint()..blendMode = blendMode,\r\n-            child: mask,\r\n-          ),\r\n-        ),\r\n-      ],\r\n-    );\r\n-\r\n-    if (childSaveLayer) {\r\n-      child = SaveLayer(\r\n-        paint: Paint(),\r\n-        child: child,\r\n-      );\r\n-    }\r\n-\r\n-    return child;\r\n-  }\r\n-\r\n-  @override\r\n-  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\r\n-    super.debugFillProperties(properties);\r\n-    properties\r\n-      ..add(EnumProperty(\"blendMode\", blendMode))\r\n-      ..add(\r\n-        FlagProperty(\r\n-          \"childSaveLayer\",\r\n-          value: childSaveLayer,\r\n-          ifTrue: \"CHILD-SAVE-LAYER\",\r\n-          defaultValue: false,\r\n-        ),\r\n-      );\r\n-  }\r\n-}\r\n-\r\n-/// A widget, which paints its [child] into a separate save layer.\r\n-///\r\n-/// The [Paint], that is used for the save layer, can be set through [paint].\r\n-///\r\n-/// Widgets that need compositing will only be partially or not at all painted\r\n-/// into the save layer. This can cause unexpected results, which is why\r\n-/// widgets that need compositing will cause an exception in debug mode, when\r\n-/// used as the [child]. To disable this check, set\r\n-/// [debugCheckChildDoesNotNeedCompositing] to `false`.\r\n-class SaveLayer extends SingleChildRenderObjectWidget {\r\n-  /// Creates a widget, which paints its [child] into a separate save layer.\r\n-  const SaveLayer({\r\n-    super.key,\r\n-    this.paint,\r\n-    this.debugCheckChildDoesNotNeedCompositing = true,\r\n-    this.child,\r\n-  }) : super(child: child);\r\n-\r\n-  /// The [Paint] to use for the save layer.\r\n-  ///\r\n-  /// If this is `null`, `Paint()` will be used.\r\n-  final Paint? paint;\r\n-\r\n-  /// Whether to check that [child] does not need compositing.\r\n-  // ignore: diagnostic_describe_all_properties\r\n-  final bool debugCheckChildDoesNotNeedCompositing;\r\n-\r\n-  /// The widget which will be painted into it's own save layer.\r\n-  ///\r\n-  /// {@macro flutter.widgets.ProxyWidget.child}\r\n-  @override\r\n-  final Widget? child;\r\n-\r\n-  @override\r\n-  RenderObject createRenderObject(BuildContext context) => RenderSaveLayer(\r\n-        saveLayerPaint: paint,\r\n-        debugCheckChildDoesNotNeedCompositing: debugCheckChildDoesNotNeedCompositing,\r\n-      );\r\n-\r\n-  @override\r\n-  void updateRenderObject(\r\n-    BuildContext context,\r\n-    covariant RenderSaveLayer renderObject,\r\n-  ) {\r\n-    super.updateRenderObject(context, renderObject);\r\n-    renderObject\r\n-      ..saveLayerPaint = paint\r\n-      ..debugCheckChildDoesNotNeedCompositing = debugCheckChildDoesNotNeedCompositing;\r\n-  }\r\n-\r\n-  @override\r\n-  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\r\n-    super.debugFillProperties(properties);\r\n-    properties.add(DiagnosticsProperty<Paint?>(\"paint\", paint));\r\n-  }\r\n-}\r\n-\r\n-/// A [RenderProxyBox], that paints its child into a separate save layer.\r\n-class RenderSaveLayer extends RenderProxyBox {\r\n-  /// Creates a [RenderProxyBox], that paints its child into a separate save\r\n-  /// layer.\r\n-  RenderSaveLayer({\r\n-    required Paint? saveLayerPaint,\r\n-    required bool debugCheckChildDoesNotNeedCompositing,\r\n-  })  : _saveLayerPaint = saveLayerPaint,\r\n-        _debugCheckChildDoesNotNeedCompositing = debugCheckChildDoesNotNeedCompositing,\r\n-        super();\r\n-\r\n-  /// The [Paint] to use for the save layer.\r\n-  ///\r\n-  /// If this is `null`, `Paint()` will be used.\r\n-  Paint? get saveLayerPaint => _saveLayerPaint;\r\n-  Paint? _saveLayerPaint;\r\n-\r\n-  set saveLayerPaint(Paint? saveLayerPaint) {\r\n-    if (_saveLayerPaint == saveLayerPaint) {\r\n-      return;\r\n-    }\r\n-    markNeedsPaint();\r\n-    _saveLayerPaint = saveLayerPaint;\r\n-  }\r\n-\r\n-  /// Whether to check that [child] does not need compositing.\r\n-  // ignore: diagnostic_describe_all_properties\r\n-  bool get debugCheckChildDoesNotNeedCompositing => _debugCheckChildDoesNotNeedCompositing;\r\n-  bool _debugCheckChildDoesNotNeedCompositing;\r\n-\r\n-  set debugCheckChildDoesNotNeedCompositing(bool debugCheckChildDoesNotNeedCompositing) {\r\n-    if (_debugCheckChildDoesNotNeedCompositing == debugCheckChildDoesNotNeedCompositing) {\r\n-      return;\r\n-    }\r\n-    markNeedsCompositingBitsUpdate();\r\n-    _debugCheckChildDoesNotNeedCompositing = debugCheckChildDoesNotNeedCompositing;\r\n-  }\r\n-\r\n-  @override\r\n-  bool get needsCompositing {\r\n-    assert(() {\r\n-      if (_debugCheckChildDoesNotNeedCompositing) {\r\n-        _debugChildDoesNotNeedCompositing();\r\n-      }\r\n-      return true;\r\n-    }());\r\n-    return super.needsCompositing;\r\n-  }\r\n-\r\n-  @override\r\n-  void paint(PaintingContext context, Offset offset) {\r\n-    var child = this.child;\r\n-    if (child == null) {\r\n-      return;\r\n-    }\r\n-\r\n-    context.canvas.saveLayer(offset & size, _saveLayerPaint ?? Paint());\r\n-    context.paintChild(child, offset);\r\n-    context.canvas.restore();\r\n-  }\r\n-\r\n-  void _debugChildDoesNotNeedCompositing() {\r\n-    var child = this.child;\r\n-    if (child == null) {\r\n-      return;\r\n-    }\r\n-\r\n-    if (child.needsCompositing) {\r\n-      throw FlutterError.fromParts([\r\n-        ErrorSummary(\"`SaveLayer.child` cannot contain compositing layers.\"),\r\n-        ErrorDescription(\r\n-          \"The save layer, into which SaveLayer.child is painted, cannot \"\r\n-          \"encompass compositing layers.\",\r\n-        ),\r\n-        ErrorHint(\r\n-          \"Ensure `SaveLayer.child` contains no widgets which need \"\r\n-          \"compositing, such as `RepaintBoundary`.\",\r\n-        ),\r\n-        _leafCompositingRenderObjects(child).first.describeForError(\"\"),\r\n-      ]);\r\n-    }\r\n-  }\r\n-\r\n-  @override\r\n-  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\r\n-    super.debugFillProperties(properties);\r\n-    properties.add(\r\n-      DiagnosticsProperty<Paint?>(\r\n-        \"saveLayerPaint\",\r\n-        saveLayerPaint,\r\n-      ),\r\n-    );\r\n-  }\r\n-}\r\n-\r\n-Iterable<RenderObject> _leafCompositingRenderObjects(\r\n-  RenderObject renderObject,\r\n-) =>\r\n-    (_renderTreeNodes(renderObject).toList()..sort((a, b) => a.depth - b.depth)).where(_isLeafCompositingRenderObject);\r\n-\r\n-Iterable<RenderObject> _renderTreeNodes(RenderObject root) sync* {\r\n-  var children = <RenderObject>[];\r\n-  root.visitChildren((child) {\r\n-    children.add(child);\r\n-  });\r\n-  yield root;\r\n-  yield* children.expand((child) => _renderTreeNodes(child));\r\n-}\r\n-\r\n-bool _isLeafCompositingRenderObject(RenderObject renderObject) {\r\n-  if (renderObject.needsCompositing) {\r\n-    var hasChildThatNeedsCompositing = false;\r\n-    renderObject.visitChildren((child) {\r\n-      if (!hasChildThatNeedsCompositing) {\r\n-        hasChildThatNeedsCompositing = child.needsCompositing;\r\n-      }\r\n-    });\r\n-    return !hasChildThatNeedsCompositing;\r\n-  } else {\r\n-    return false;\r\n-  }\r\n-}\r\n"
                },
                {
                    "date": 1698776442375,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,227 @@\n+// ignore_for_file: prefer_asserts_with_message, overridden_fields\r\n+\r\n+import \"package:flutter/rendering.dart\";\r\n+import \"package:flutter/widgets.dart\";\r\n+\r\n+/// A widget which paints a [mask] widget into a save layer and blends that\r\n+/// layer with its [child].\r\n+///\r\n+/// [blendMode] determines how [mask] and [child] are blended with each other.\r\n+/// In the context of this widget [mask] is the `src` and [child] the `dst`.\r\n+///\r\n+/// This widget sizes itself to the dimensions of [child] and forces [mask] to\r\n+/// the same size. For the purpose of hit testing [mask] is painted over\r\n+/// [child].\r\n+///\r\n+/// Since [mask] is panted into a save layer, this widget is relatively\r\n+/// expensive. See [Canvas.saveLayer] for more on the performance implications\r\n+/// of a save layer.\r\n+///\r\n+/// [mask] must not contain [RenderObject]s which need compositing because\r\n+/// the save layer into which [mask] is painted cannot encompass compositing\r\n+/// layers. `RepaintBoundary` is a widget, whose [RenderObject] needs\r\n+/// compositing, for example.\r\n+class WidgetMask extends StatelessWidget {\r\n+  /// Creates a widget which paints a [mask] widget into a save layer and blends\r\n+  /// that layer with its [child].\r\n+  const WidgetMask({\r\n+    required this.mask,\r\n+    required this.child,\r\n+    super.key,\r\n+    this.blendMode = BlendMode.srcOver,\r\n+    this.childSaveLayer = false,\r\n+  });\r\n+\r\n+  /// The [BlendMode] to use when blending the [mask] save layer with [child].\r\n+  ///\r\n+  /// In the context of this widget [mask] is the `src` and [child] the `dst`.\r\n+  final BlendMode blendMode;\r\n+\r\n+  /// Whether to paint [child] in its own save layer.\r\n+  ///\r\n+  /// This allows you to blend [child] and [mask] without the transparent\r\n+  /// areas of [child] influencing the result.\r\n+  ///\r\n+  /// Enabling this option impacts performance, since it adds another save layer\r\n+  /// and should only be done if necessary.\r\n+  final bool childSaveLayer;\r\n+\r\n+  /// The widget which is painted over the [child] widget, in a save layer with\r\n+  /// [BlendMode] [blendMode].\r\n+  final Widget mask;\r\n+\r\n+  /// The widget which determines the size of this widget and is painted behind\r\n+  /// the [mask] widget.\r\n+  final Widget child;\r\n+\r\n+  @override\r\n+  Widget build(BuildContext context) {\r\n+    Widget child = Stack(\r\n+      textDirection: TextDirection.ltr,\r\n+      // fit: StackFit.passthrough,\r\n+      children: [\r\n+        this.child,\r\n+        Positioned.fill(\r\n+          child: SaveLayer(\r\n+            paint: Paint()..blendMode = blendMode,\r\n+            child: mask,\r\n+          ),\r\n+        ),\r\n+      ],\r\n+    );\r\n+\r\n+    if (childSaveLayer) {\r\n+      child = SaveLayer(\r\n+        child: child,\r\n+      );\r\n+    }\r\n+\r\n+    return child;\r\n+  }\r\n+\r\n+  @override\r\n+  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\r\n+    super.debugFillProperties(properties);\r\n+    properties\r\n+      ..add(EnumProperty(\"blendMode\", blendMode))\r\n+      ..add(\r\n+        FlagProperty(\r\n+          \"childSaveLayer\",\r\n+          value: childSaveLayer,\r\n+          ifTrue: \"CHILD-SAVE-LAYER\",\r\n+          defaultValue: false,\r\n+        ),\r\n+      );\r\n+  }\r\n+}\r\n+\r\n+/// A widget, which paints its [child] into a separate save layer.\r\n+///\r\n+/// The [Paint], that is used for the save layer, can be set through [paint].\r\n+///\r\n+/// Widgets that need compositing will only be partially or not at all painted\r\n+/// into the save layer. This can cause unexpected results, which is why\r\n+/// widgets that need compositing will cause an exception in debug mode, when\r\n+/// used as the [child]. To disable this check, set\r\n+/// [debugCheckChildDoesNotNeedCompositing] to `false`.\r\n+class SaveLayer extends SingleChildRenderObjectWidget {\r\n+  /// Creates a widget, which paints its [child] into a separate save layer.\r\n+  const SaveLayer({\r\n+    super.key,\r\n+    this.paint,\r\n+    this.debugCheckChildDoesNotNeedCompositing = true,\r\n+    this.child,\r\n+  }) : super(child: child);\r\n+\r\n+  /// The [Paint] to use for the save layer.\r\n+  ///\r\n+  /// If this is `null`, `Paint()` will be used.\r\n+  final Paint? paint;\r\n+\r\n+  /// Whether to check that [child] does not need compositing.\r\n+  // ignore: diagnostic_describe_all_properties\r\n+  final bool debugCheckChildDoesNotNeedCompositing;\r\n+\r\n+  /// The widget which will be painted into it's own save layer.\r\n+  ///\r\n+  /// {@macro flutter.widgets.ProxyWidget.child}\r\n+  @override\r\n+  final Widget? child;\r\n+\r\n+  @override\r\n+  RenderObject createRenderObject(BuildContext context) => RenderSaveLayer(\r\n+        saveLayerPaint: paint,\r\n+        debugCheckChildDoesNotNeedCompositing: debugCheckChildDoesNotNeedCompositing,\r\n+      );\r\n+\r\n+  @override\r\n+  void updateRenderObject(\r\n+    BuildContext context,\r\n+    covariant RenderSaveLayer renderObject,\r\n+  ) {\r\n+    super.updateRenderObject(context, renderObject);\r\n+    renderObject\r\n+      ..saveLayerPaint = paint\r\n+      ..debugCheckChildDoesNotNeedCompositing = debugCheckChildDoesNotNeedCompositing;\r\n+  }\r\n+\r\n+  @override\r\n+  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\r\n+    super.debugFillProperties(properties);\r\n+    properties.add(DiagnosticsProperty<Paint?>(\"paint\", paint));\r\n+  }\r\n+}\r\n+\r\n+/// A [RenderProxyBox], that paints its child into a separate save layer.\r\n+class RenderSaveLayer extends RenderProxyBox {\r\n+  /// Creates a [RenderProxyBox], that paints its child into a separate save\r\n+  /// layer.\r\n+  RenderSaveLayer({\r\n+    required Paint? saveLayerPaint,\r\n+    required bool debugCheckChildDoesNotNeedCompositing,\r\n+  })  : _saveLayerPaint = saveLayerPaint,\r\n+        _debugCheckChildDoesNotNeedCompositing = debugCheckChildDoesNotNeedCompositing,\r\n+        super();\r\n+\r\n+  /// The [Paint] to use for the save layer.\r\n+  ///\r\n+  /// If this is `null`, `Paint()` will be used.\r\n+  Paint? get saveLayerPaint => _saveLayerPaint;\r\n+  Paint? _saveLayerPaint;\r\n+\r\n+  set saveLayerPaint(Paint? saveLayerPaint) {\r\n+    if (_saveLayerPaint == saveLayerPaint) {\r\n+      return;\r\n+    }\r\n+    markNeedsPaint();\r\n+    _saveLayerPaint = saveLayerPaint;\r\n+  }\r\n+\r\n+  /// Whether to check that [child] does not need compositing.\r\n+  // ignore: diagnostic_describe_all_properties\r\n+  bool get debugCheckChildDoesNotNeedCompositing => _debugCheckChildDoesNotNeedCompositing;\r\n+  bool _debugCheckChildDoesNotNeedCompositing;\r\n+\r\n+  set debugCheckChildDoesNotNeedCompositing(bool debugCheckChildDoesNotNeedCompositing) {\r\n+    if (_debugCheckChildDoesNotNeedCompositing == debugCheckChildDoesNotNeedCompositing) {\r\n+      return;\r\n+    }\r\n+    markNeedsCompositingBitsUpdate();\r\n+    _debugCheckChildDoesNotNeedCompositing = debugCheckChildDoesNotNeedCompositing;\r\n+  }\r\n+\r\n+  // @override\r\n+  // bool get needsCompositing {\r\n+  //   assert(() {\r\n+  //     if (_debugCheckChildDoesNotNeedCompositing) {\r\n+  //       _debugChildDoesNotNeedCompositing();\r\n+  //     }\r\n+  //     return true;\r\n+  //   }());\r\n+  //   return super.needsCompositing;\r\n+  // }\r\n+\r\n+  @override\r\n+  void paint(PaintingContext context, Offset offset) {\r\n+    var child = this.child;\r\n+    if (child == null) {\r\n+      return;\r\n+    }\r\n+\r\n+    print(child.needsComposting);\r\n+    context.canvas.saveLayer(offset & size, _saveLayerPaint ?? Paint());\r\n+    context.paintChild(child, offset);\r\n+    context.canvas.restore();\r\n+  }\r\n+\r\n+  @override\r\n+  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\r\n+    super.debugFillProperties(properties);\r\n+    properties.add(\r\n+      DiagnosticsProperty<Paint?>(\r\n+        \"saveLayerPaint\",\r\n+        saveLayerPaint,\r\n+      ),\r\n+    );\r\n+  }\r\n+}\r\n"
                },
                {
                    "date": 1698776472530,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -107,8 +107,9 @@\n class SaveLayer extends SingleChildRenderObjectWidget {\r\n   /// Creates a widget, which paints its [child] into a separate save layer.\r\n   const SaveLayer({\r\n     super.key,\r\n+    this.label\r\n     this.paint,\r\n     this.debugCheckChildDoesNotNeedCompositing = true,\r\n     this.child,\r\n   }) : super(child: child);\r\n@@ -127,8 +128,10 @@\n   /// {@macro flutter.widgets.ProxyWidget.child}\r\n   @override\r\n   final Widget? child;\r\n \r\n+  fin\r\n+\r\n   @override\r\n   RenderObject createRenderObject(BuildContext context) => RenderSaveLayer(\r\n         saveLayerPaint: paint,\r\n         debugCheckChildDoesNotNeedCompositing: debugCheckChildDoesNotNeedCompositing,\r\n@@ -156,8 +159,9 @@\n class RenderSaveLayer extends RenderProxyBox {\r\n   /// Creates a [RenderProxyBox], that paints its child into a separate save\r\n   /// layer.\r\n   RenderSaveLayer({\r\n+    required this.label,\r\n     required Paint? saveLayerPaint,\r\n     required bool debugCheckChildDoesNotNeedCompositing,\r\n   })  : _saveLayerPaint = saveLayerPaint,\r\n         _debugCheckChildDoesNotNeedCompositing = debugCheckChildDoesNotNeedCompositing,\r\n@@ -168,235 +172,10 @@\n   /// If this is `null`, `Paint()` will be used.\r\n   Paint? get saveLayerPaint => _saveLayerPaint;\r\n   Paint? _saveLayerPaint;\r\n \r\n-  set saveLayerPaint(Paint? saveLayerPaint) {\r\n-    if (_saveLayerPaint == saveLayerPaint) {\r\n-      return;\r\n-    }\r\n-    markNeedsPaint();\r\n-    _saveLayerPaint = saveLayerPaint;\r\n-  }\r\n+  final String label;\r\n \r\n-  /// Whether to check that [child] does not need compositing.\r\n-  // ignore: diagnostic_describe_all_properties\r\n-  bool get debugCheckChildDoesNotNeedCompositing => _debugCheckChildDoesNotNeedCompositing;\r\n-  bool _debugCheckChildDoesNotNeedCompositing;\r\n-\r\n-  set debugCheckChildDoesNotNeedCompositing(bool debugCheckChildDoesNotNeedCompositing) {\r\n-    if (_debugCheckChildDoesNotNeedCompositing == debugCheckChildDoesNotNeedCompositing) {\r\n-      return;\r\n-    }\r\n-    markNeedsCompositingBitsUpdate();\r\n-    _debugCheckChildDoesNotNeedCompositing = debugCheckChildDoesNotNeedCompositing;\r\n-  }\r\n-\r\n-  // @override\r\n-  // bool get needsCompositing {\r\n-  //   assert(() {\r\n-  //     if (_debugCheckChildDoesNotNeedCompositing) {\r\n-  //       _debugChildDoesNotNeedCompositing();\r\n-  //     }\r\n-  //     return true;\r\n-  //   }());\r\n-  //   return super.needsCompositing;\r\n-  // }\r\n-\r\n-  @override\r\n-  void paint(PaintingContext context, Offset offset) {\r\n-    var child = this.child;\r\n-    if (child == null) {\r\n-      return;\r\n-    }\r\n-\r\n-    print(child.needsComposting);\r\n-    context.canvas.saveLayer(offset & size, _saveLayerPaint ?? Paint());\r\n-    context.paintChild(child, offset);\r\n-    context.canvas.restore();\r\n-  }\r\n-\r\n-  @override\r\n-  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\r\n-    super.debugFillProperties(properties);\r\n-    properties.add(\r\n-      DiagnosticsProperty<Paint?>(\r\n-        \"saveLayerPaint\",\r\n-        saveLayerPaint,\r\n-      ),\r\n-    );\r\n-  }\r\n-}\r\n-// ignore_for_file: prefer_asserts_with_message, overridden_fields\r\n-\r\n-import \"package:flutter/rendering.dart\";\r\n-import \"package:flutter/widgets.dart\";\r\n-\r\n-/// A widget which paints a [mask] widget into a save layer and blends that\r\n-/// layer with its [child].\r\n-///\r\n-/// [blendMode] determines how [mask] and [child] are blended with each other.\r\n-/// In the context of this widget [mask] is the `src` and [child] the `dst`.\r\n-///\r\n-/// This widget sizes itself to the dimensions of [child] and forces [mask] to\r\n-/// the same size. For the purpose of hit testing [mask] is painted over\r\n-/// [child].\r\n-///\r\n-/// Since [mask] is panted into a save layer, this widget is relatively\r\n-/// expensive. See [Canvas.saveLayer] for more on the performance implications\r\n-/// of a save layer.\r\n-///\r\n-/// [mask] must not contain [RenderObject]s which need compositing because\r\n-/// the save layer into which [mask] is painted cannot encompass compositing\r\n-/// layers. `RepaintBoundary` is a widget, whose [RenderObject] needs\r\n-/// compositing, for example.\r\n-class WidgetMask extends StatelessWidget {\r\n-  /// Creates a widget which paints a [mask] widget into a save layer and blends\r\n-  /// that layer with its [child].\r\n-  const WidgetMask({\r\n-    required this.mask,\r\n-    required this.child,\r\n-    super.key,\r\n-    this.blendMode = BlendMode.srcOver,\r\n-    this.childSaveLayer = false,\r\n-  });\r\n-\r\n-  /// The [BlendMode] to use when blending the [mask] save layer with [child].\r\n-  ///\r\n-  /// In the context of this widget [mask] is the `src` and [child] the `dst`.\r\n-  final BlendMode blendMode;\r\n-\r\n-  /// Whether to paint [child] in its own save layer.\r\n-  ///\r\n-  /// This allows you to blend [child] and [mask] without the transparent\r\n-  /// areas of [child] influencing the result.\r\n-  ///\r\n-  /// Enabling this option impacts performance, since it adds another save layer\r\n-  /// and should only be done if necessary.\r\n-  final bool childSaveLayer;\r\n-\r\n-  /// The widget which is painted over the [child] widget, in a save layer with\r\n-  /// [BlendMode] [blendMode].\r\n-  final Widget mask;\r\n-\r\n-  /// The widget which determines the size of this widget and is painted behind\r\n-  /// the [mask] widget.\r\n-  final Widget child;\r\n-\r\n-  @override\r\n-  Widget build(BuildContext context) {\r\n-    Widget child = Stack(\r\n-      textDirection: TextDirection.ltr,\r\n-      // fit: StackFit.passthrough,\r\n-      children: [\r\n-        this.child,\r\n-        Positioned.fill(\r\n-          child: SaveLayer(\r\n-            paint: Paint()..blendMode = blendMode,\r\n-            child: mask,\r\n-          ),\r\n-        ),\r\n-      ],\r\n-    );\r\n-\r\n-    if (childSaveLayer) {\r\n-      child = SaveLayer(\r\n-        child: child,\r\n-      );\r\n-    }\r\n-\r\n-    return child;\r\n-  }\r\n-\r\n-  @override\r\n-  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\r\n-    super.debugFillProperties(properties);\r\n-    properties\r\n-      ..add(EnumProperty(\"blendMode\", blendMode))\r\n-      ..add(\r\n-        FlagProperty(\r\n-          \"childSaveLayer\",\r\n-          value: childSaveLayer,\r\n-          ifTrue: \"CHILD-SAVE-LAYER\",\r\n-          defaultValue: false,\r\n-        ),\r\n-      );\r\n-  }\r\n-}\r\n-\r\n-/// A widget, which paints its [child] into a separate save layer.\r\n-///\r\n-/// The [Paint], that is used for the save layer, can be set through [paint].\r\n-///\r\n-/// Widgets that need compositing will only be partially or not at all painted\r\n-/// into the save layer. This can cause unexpected results, which is why\r\n-/// widgets that need compositing will cause an exception in debug mode, when\r\n-/// used as the [child]. To disable this check, set\r\n-/// [debugCheckChildDoesNotNeedCompositing] to `false`.\r\n-class SaveLayer extends SingleChildRenderObjectWidget {\r\n-  /// Creates a widget, which paints its [child] into a separate save layer.\r\n-  const SaveLayer({\r\n-    super.key,\r\n-    this.paint,\r\n-    this.debugCheckChildDoesNotNeedCompositing = true,\r\n-    this.child,\r\n-  }) : super(child: child);\r\n-\r\n-  /// The [Paint] to use for the save layer.\r\n-  ///\r\n-  /// If this is `null`, `Paint()` will be used.\r\n-  final Paint? paint;\r\n-\r\n-  /// Whether to check that [child] does not need compositing.\r\n-  // ignore: diagnostic_describe_all_properties\r\n-  final bool debugCheckChildDoesNotNeedCompositing;\r\n-\r\n-  /// The widget which will be painted into it's own save layer.\r\n-  ///\r\n-  /// {@macro flutter.widgets.ProxyWidget.child}\r\n-  @override\r\n-  final Widget? child;\r\n-\r\n-  @override\r\n-  RenderObject createRenderObject(BuildContext context) => RenderSaveLayer(\r\n-        saveLayerPaint: paint,\r\n-        debugCheckChildDoesNotNeedCompositing: debugCheckChildDoesNotNeedCompositing,\r\n-      );\r\n-\r\n-  @override\r\n-  void updateRenderObject(\r\n-    BuildContext context,\r\n-    covariant RenderSaveLayer renderObject,\r\n-  ) {\r\n-    super.updateRenderObject(context, renderObject);\r\n-    renderObject\r\n-      ..saveLayerPaint = paint\r\n-      ..debugCheckChildDoesNotNeedCompositing = debugCheckChildDoesNotNeedCompositing;\r\n-  }\r\n-\r\n-  @override\r\n-  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\r\n-    super.debugFillProperties(properties);\r\n-    properties.add(DiagnosticsProperty<Paint?>(\"paint\", paint));\r\n-  }\r\n-}\r\n-\r\n-/// A [RenderProxyBox], that paints its child into a separate save layer.\r\n-class RenderSaveLayer extends RenderProxyBox {\r\n-  /// Creates a [RenderProxyBox], that paints its child into a separate save\r\n-  /// layer.\r\n-  RenderSaveLayer({\r\n-    required Paint? saveLayerPaint,\r\n-    required bool debugCheckChildDoesNotNeedCompositing,\r\n-  })  : _saveLayerPaint = saveLayerPaint,\r\n-        _debugCheckChildDoesNotNeedCompositing = debugCheckChildDoesNotNeedCompositing,\r\n-        super();\r\n-\r\n-  /// The [Paint] to use for the save layer.\r\n-  ///\r\n-  /// If this is `null`, `Paint()` will be used.\r\n-  Paint? get saveLayerPaint => _saveLayerPaint;\r\n-  Paint? _saveLayerPaint;\r\n-\r\n   set saveLayerPaint(Paint? saveLayerPaint) {\r\n     if (_saveLayerPaint == saveLayerPaint) {\r\n       return;\r\n     }\r\n@@ -434,35 +213,14 @@\n     if (child == null) {\r\n       return;\r\n     }\r\n \r\n+    print(child.needsCompositing);\r\n     context.canvas.saveLayer(offset & size, _saveLayerPaint ?? Paint());\r\n     context.paintChild(child, offset);\r\n     context.canvas.restore();\r\n   }\r\n \r\n-  void _debugChildDoesNotNeedCompositing() {\r\n-    var child = this.child;\r\n-    if (child == null) {\r\n-      return;\r\n-    }\r\n-\r\n-    if (child.needsCompositing) {\r\n-      throw FlutterError.fromParts([\r\n-        ErrorSummary(\"`SaveLayer.child` cannot contain compositing layers.\"),\r\n-        ErrorDescription(\r\n-          \"The save layer, into which SaveLayer.child is painted, cannot \"\r\n-          \"encompass compositing layers.\",\r\n-        ),\r\n-        ErrorHint(\r\n-          \"Ensure `SaveLayer.child` contains no widgets which need \"\r\n-          \"compositing, such as `RepaintBoundary`.\",\r\n-        ),\r\n-        _leafCompositingRenderObjects(child).first.describeForError(\"\"),\r\n-      ]);\r\n-    }\r\n-  }\r\n-\r\n   @override\r\n   void debugFillProperties(DiagnosticPropertiesBuilder properties) {\r\n     super.debugFillProperties(properties);\r\n     properties.add(\r\n@@ -472,32 +230,4 @@\n       ),\r\n     );\r\n   }\r\n }\r\n-\r\n-Iterable<RenderObject> _leafCompositingRenderObjects(\r\n-  RenderObject renderObject,\r\n-) =>\r\n-    (_renderTreeNodes(renderObject).toList()..sort((a, b) => a.depth - b.depth)).where(_isLeafCompositingRenderObject);\r\n-\r\n-Iterable<RenderObject> _renderTreeNodes(RenderObject root) sync* {\r\n-  var children = <RenderObject>[];\r\n-  root.visitChildren((child) {\r\n-    children.add(child);\r\n-  });\r\n-  yield root;\r\n-  yield* children.expand((child) => _renderTreeNodes(child));\r\n-}\r\n-\r\n-bool _isLeafCompositingRenderObject(RenderObject renderObject) {\r\n-  if (renderObject.needsCompositing) {\r\n-    var hasChildThatNeedsCompositing = false;\r\n-    renderObject.visitChildren((child) {\r\n-      if (!hasChildThatNeedsCompositing) {\r\n-        hasChildThatNeedsCompositing = child.needsCompositing;\r\n-      }\r\n-    });\r\n-    return !hasChildThatNeedsCompositing;\r\n-  } else {\r\n-    return false;\r\n-  }\r\n-}\r\n"
                },
                {
                    "date": 1698776537338,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -62,8 +62,9 @@\n       children: [\r\n         this.child,\r\n         Positioned.fill(\r\n           child: SaveLayer(\r\n+            label: \"mask\",\r\n             paint: Paint()..blendMode = blendMode,\r\n             child: mask,\r\n           ),\r\n         ),\r\n@@ -71,8 +72,9 @@\n     );\r\n \r\n     if (childSaveLayer) {\r\n       child = SaveLayer(\r\n+        label: \"child\",\r\n         child: child,\r\n       );\r\n     }\r\n \r\n@@ -106,10 +108,10 @@\n /// [debugCheckChildDoesNotNeedCompositing] to `false`.\r\n class SaveLayer extends SingleChildRenderObjectWidget {\r\n   /// Creates a widget, which paints its [child] into a separate save layer.\r\n   const SaveLayer({\r\n+    required this.label,\r\n     super.key,\r\n-    this.label\r\n     this.paint,\r\n     this.debugCheckChildDoesNotNeedCompositing = true,\r\n     this.child,\r\n   }) : super(child: child);\r\n@@ -128,14 +130,15 @@\n   /// {@macro flutter.widgets.ProxyWidget.child}\r\n   @override\r\n   final Widget? child;\r\n \r\n-  fin\r\n+  final String label;\r\n \r\n   @override\r\n   RenderObject createRenderObject(BuildContext context) => RenderSaveLayer(\r\n         saveLayerPaint: paint,\r\n         debugCheckChildDoesNotNeedCompositing: debugCheckChildDoesNotNeedCompositing,\r\n+        label: label,\r\n       );\r\n \r\n   @override\r\n   void updateRenderObject(\r\n@@ -214,9 +217,9 @@\n       return;\r\n     }\r\n \r\n     print(child.needsCompositing);\r\n-    context.canvas.saveLayer(offset & size, _saveLayerPaint ?? Paint());\r\n+    // context.canvas.saveLayer(offset & size, _saveLayerPaint ?? Paint());\r\n     context.paintChild(child, offset);\r\n     context.canvas.restore();\r\n   }\r\n \r\n"
                },
                {
                    "date": 1698776585508,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,235 @@\n+// ignore_for_file: prefer_asserts_with_message, overridden_fields\r\n+\r\n+import \"package:flutter/rendering.dart\";\r\n+import \"package:flutter/widgets.dart\";\r\n+\r\n+/// A widget which paints a [mask] widget into a save layer and blends that\r\n+/// layer with its [child].\r\n+///\r\n+/// [blendMode] determines how [mask] and [child] are blended with each other.\r\n+/// In the context of this widget [mask] is the `src` and [child] the `dst`.\r\n+///\r\n+/// This widget sizes itself to the dimensions of [child] and forces [mask] to\r\n+/// the same size. For the purpose of hit testing [mask] is painted over\r\n+/// [child].\r\n+///\r\n+/// Since [mask] is panted into a save layer, this widget is relatively\r\n+/// expensive. See [Canvas.saveLayer] for more on the performance implications\r\n+/// of a save layer.\r\n+///\r\n+/// [mask] must not contain [RenderObject]s which need compositing because\r\n+/// the save layer into which [mask] is painted cannot encompass compositing\r\n+/// layers. `RepaintBoundary` is a widget, whose [RenderObject] needs\r\n+/// compositing, for example.\r\n+class WidgetMask extends StatelessWidget {\r\n+  /// Creates a widget which paints a [mask] widget into a save layer and blends\r\n+  /// that layer with its [child].\r\n+  const WidgetMask({\r\n+    required this.mask,\r\n+    required this.child,\r\n+    super.key,\r\n+    this.blendMode = BlendMode.srcOver,\r\n+    this.childSaveLayer = false,\r\n+  });\r\n+\r\n+  /// The [BlendMode] to use when blending the [mask] save layer with [child].\r\n+  ///\r\n+  /// In the context of this widget [mask] is the `src` and [child] the `dst`.\r\n+  final BlendMode blendMode;\r\n+\r\n+  /// Whether to paint [child] in its own save layer.\r\n+  ///\r\n+  /// This allows you to blend [child] and [mask] without the transparent\r\n+  /// areas of [child] influencing the result.\r\n+  ///\r\n+  /// Enabling this option impacts performance, since it adds another save layer\r\n+  /// and should only be done if necessary.\r\n+  final bool childSaveLayer;\r\n+\r\n+  /// The widget which is painted over the [child] widget, in a save layer with\r\n+  /// [BlendMode] [blendMode].\r\n+  final Widget mask;\r\n+\r\n+  /// The widget which determines the size of this widget and is painted behind\r\n+  /// the [mask] widget.\r\n+  final Widget child;\r\n+\r\n+  @override\r\n+  Widget build(BuildContext context) {\r\n+    Widget child = Stack(\r\n+      textDirection: TextDirection.ltr,\r\n+      // fit: StackFit.passthrough,\r\n+      children: [\r\n+        this.child,\r\n+        Positioned.fill(\r\n+          child: SaveLayer(\r\n+            label: \"mask\",\r\n+            paint: Paint()..blendMode = blendMode,\r\n+            child: mask,\r\n+          ),\r\n+        ),\r\n+      ],\r\n+    );\r\n+\r\n+    if (childSaveLayer) {\r\n+      child = SaveLayer(\r\n+        label: \"child\",\r\n+        child: child,\r\n+      );\r\n+    }\r\n+\r\n+    return child;\r\n+  }\r\n+\r\n+  @override\r\n+  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\r\n+    super.debugFillProperties(properties);\r\n+    properties\r\n+      ..add(EnumProperty(\"blendMode\", blendMode))\r\n+      ..add(\r\n+        FlagProperty(\r\n+          \"childSaveLayer\",\r\n+          value: childSaveLayer,\r\n+          ifTrue: \"CHILD-SAVE-LAYER\",\r\n+          defaultValue: false,\r\n+        ),\r\n+      );\r\n+  }\r\n+}\r\n+\r\n+/// A widget, which paints its [child] into a separate save layer.\r\n+///\r\n+/// The [Paint], that is used for the save layer, can be set through [paint].\r\n+///\r\n+/// Widgets that need compositing will only be partially or not at all painted\r\n+/// into the save layer. This can cause unexpected results, which is why\r\n+/// widgets that need compositing will cause an exception in debug mode, when\r\n+/// used as the [child]. To disable this check, set\r\n+/// [debugCheckChildDoesNotNeedCompositing] to `false`.\r\n+class SaveLayer extends SingleChildRenderObjectWidget {\r\n+  /// Creates a widget, which paints its [child] into a separate save layer.\r\n+  const SaveLayer({\r\n+    required this.label,\r\n+    super.key,\r\n+    this.paint,\r\n+    this.debugCheckChildDoesNotNeedCompositing = true,\r\n+    this.child,\r\n+  }) : super(child: child);\r\n+\r\n+  /// The [Paint] to use for the save layer.\r\n+  ///\r\n+  /// If this is `null`, `Paint()` will be used.\r\n+  final Paint? paint;\r\n+\r\n+  /// Whether to check that [child] does not need compositing.\r\n+  // ignore: diagnostic_describe_all_properties\r\n+  final bool debugCheckChildDoesNotNeedCompositing;\r\n+\r\n+  /// The widget which will be painted into it's own save layer.\r\n+  ///\r\n+  /// {@macro flutter.widgets.ProxyWidget.child}\r\n+  @override\r\n+  final Widget? child;\r\n+\r\n+  final String label;\r\n+\r\n+  @override\r\n+  RenderObject createRenderObject(BuildContext context) => RenderSaveLayer(\r\n+        saveLayerPaint: paint,\r\n+        debugCheckChildDoesNotNeedCompositing: debugCheckChildDoesNotNeedCompositing,\r\n+        label: label,\r\n+      );\r\n+\r\n+  @override\r\n+  void updateRenderObject(\r\n+    BuildContext context,\r\n+    covariant RenderSaveLayer renderObject,\r\n+  ) {\r\n+    super.updateRenderObject(context, renderObject);\r\n+    renderObject\r\n+      ..saveLayerPaint = paint\r\n+      ..debugCheckChildDoesNotNeedCompositing = debugCheckChildDoesNotNeedCompositing;\r\n+  }\r\n+\r\n+  @override\r\n+  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\r\n+    super.debugFillProperties(properties);\r\n+    properties.add(DiagnosticsProperty<Paint?>(\"paint\", paint));\r\n+  }\r\n+}\r\n+\r\n+/// A [RenderProxyBox], that paints its child into a separate save layer.\r\n+class RenderSaveLayer extends RenderProxyBox {\r\n+  /// Creates a [RenderProxyBox], that paints its child into a separate save\r\n+  /// layer.\r\n+  RenderSaveLayer({\r\n+    required this.label,\r\n+    required Paint? saveLayerPaint,\r\n+    required bool debugCheckChildDoesNotNeedCompositing,\r\n+  })  : _saveLayerPaint = saveLayerPaint,\r\n+        _debugCheckChildDoesNotNeedCompositing = debugCheckChildDoesNotNeedCompositing,\r\n+        super();\r\n+\r\n+  /// The [Paint] to use for the save layer.\r\n+  ///\r\n+  /// If this is `null`, `Paint()` will be used.\r\n+  Paint? get saveLayerPaint => _saveLayerPaint;\r\n+  Paint? _saveLayerPaint;\r\n+\r\n+  final String label;\r\n+\r\n+  set saveLayerPaint(Paint? saveLayerPaint) {\r\n+    if (_saveLayerPaint == saveLayerPaint) {\r\n+      return;\r\n+    }\r\n+    markNeedsPaint();\r\n+    _saveLayerPaint = saveLayerPaint;\r\n+  }\r\n+\r\n+  /// Whether to check that [child] does not need compositing.\r\n+  // ignore: diagnostic_describe_all_properties\r\n+  bool get debugCheckChildDoesNotNeedCompositing => _debugCheckChildDoesNotNeedCompositing;\r\n+  bool _debugCheckChildDoesNotNeedCompositing;\r\n+\r\n+  set debugCheckChildDoesNotNeedCompositing(bool debugCheckChildDoesNotNeedCompositing) {\r\n+    if (_debugCheckChildDoesNotNeedCompositing == debugCheckChildDoesNotNeedCompositing) {\r\n+      return;\r\n+    }\r\n+    markNeedsCompositingBitsUpdate();\r\n+    _debugCheckChildDoesNotNeedCompositing = debugCheckChildDoesNotNeedCompositing;\r\n+  }\r\n+\r\n+  // @override\r\n+  // bool get needsCompositing {\r\n+  //   assert(() {\r\n+  //     if (_debugCheckChildDoesNotNeedCompositing) {\r\n+  //       _debugChildDoesNotNeedCompositing();\r\n+  //     }\r\n+  //     return true;\r\n+  //   }());\r\n+  //   return super.needsCompositing;\r\n+  // }\r\n+\r\n+  @override\r\n+  void paint(PaintingContext context, Offset offset) {\r\n+    var child = this.child;\r\n+    if (child == null) {\r\n+      return;\r\n+    }\r\n+\r\n+    context.canvas.saveLayer(offset & , _saveLayerPaint ?? Paint());\r\n+    context.paintChild(child, offset);\r\n+    context.canvas.restore();\r\n+  }\r\n+\r\n+  @override\r\n+  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\r\n+    super.debugFillProperties(properties);\r\n+    properties.add(\r\n+      DiagnosticsProperty<Paint?>(\r\n+        \"saveLayerPaint\",\r\n+        saveLayerPaint,\r\n+      ),\r\n+    );\r\n+  }\r\n+}\r\n"
                },
                {
                    "date": 1698776617356,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -216,10 +216,10 @@\n     if (child == null) {\r\n       return;\r\n     }\r\n \r\n-    context.canvas.saveLayer(offset & , _saveLayerPaint ?? Paint());\r\n-    context.paintChild(child, offset);\r\n+    context.canvas.saveLayer(offset & size, _saveLayerPaint ?? Paint());\r\n+    context.paintChild(child, Offset.);\r\n     context.canvas.restore();\r\n   }\r\n \r\n   @override\r\n@@ -232,240 +232,4 @@\n       ),\r\n     );\r\n   }\r\n }\r\n-// ignore_for_file: prefer_asserts_with_message, overridden_fields\r\n-\r\n-import \"package:flutter/rendering.dart\";\r\n-import \"package:flutter/widgets.dart\";\r\n-\r\n-/// A widget which paints a [mask] widget into a save layer and blends that\r\n-/// layer with its [child].\r\n-///\r\n-/// [blendMode] determines how [mask] and [child] are blended with each other.\r\n-/// In the context of this widget [mask] is the `src` and [child] the `dst`.\r\n-///\r\n-/// This widget sizes itself to the dimensions of [child] and forces [mask] to\r\n-/// the same size. For the purpose of hit testing [mask] is painted over\r\n-/// [child].\r\n-///\r\n-/// Since [mask] is panted into a save layer, this widget is relatively\r\n-/// expensive. See [Canvas.saveLayer] for more on the performance implications\r\n-/// of a save layer.\r\n-///\r\n-/// [mask] must not contain [RenderObject]s which need compositing because\r\n-/// the save layer into which [mask] is painted cannot encompass compositing\r\n-/// layers. `RepaintBoundary` is a widget, whose [RenderObject] needs\r\n-/// compositing, for example.\r\n-class WidgetMask extends StatelessWidget {\r\n-  /// Creates a widget which paints a [mask] widget into a save layer and blends\r\n-  /// that layer with its [child].\r\n-  const WidgetMask({\r\n-    required this.mask,\r\n-    required this.child,\r\n-    super.key,\r\n-    this.blendMode = BlendMode.srcOver,\r\n-    this.childSaveLayer = false,\r\n-  });\r\n-\r\n-  /// The [BlendMode] to use when blending the [mask] save layer with [child].\r\n-  ///\r\n-  /// In the context of this widget [mask] is the `src` and [child] the `dst`.\r\n-  final BlendMode blendMode;\r\n-\r\n-  /// Whether to paint [child] in its own save layer.\r\n-  ///\r\n-  /// This allows you to blend [child] and [mask] without the transparent\r\n-  /// areas of [child] influencing the result.\r\n-  ///\r\n-  /// Enabling this option impacts performance, since it adds another save layer\r\n-  /// and should only be done if necessary.\r\n-  final bool childSaveLayer;\r\n-\r\n-  /// The widget which is painted over the [child] widget, in a save layer with\r\n-  /// [BlendMode] [blendMode].\r\n-  final Widget mask;\r\n-\r\n-  /// The widget which determines the size of this widget and is painted behind\r\n-  /// the [mask] widget.\r\n-  final Widget child;\r\n-\r\n-  @override\r\n-  Widget build(BuildContext context) {\r\n-    Widget child = Stack(\r\n-      textDirection: TextDirection.ltr,\r\n-      // fit: StackFit.passthrough,\r\n-      children: [\r\n-        this.child,\r\n-        Positioned.fill(\r\n-          child: SaveLayer(\r\n-            label: \"mask\",\r\n-            paint: Paint()..blendMode = blendMode,\r\n-            child: mask,\r\n-          ),\r\n-        ),\r\n-      ],\r\n-    );\r\n-\r\n-    if (childSaveLayer) {\r\n-      child = SaveLayer(\r\n-        label: \"child\",\r\n-        child: child,\r\n-      );\r\n-    }\r\n-\r\n-    return child;\r\n-  }\r\n-\r\n-  @override\r\n-  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\r\n-    super.debugFillProperties(properties);\r\n-    properties\r\n-      ..add(EnumProperty(\"blendMode\", blendMode))\r\n-      ..add(\r\n-        FlagProperty(\r\n-          \"childSaveLayer\",\r\n-          value: childSaveLayer,\r\n-          ifTrue: \"CHILD-SAVE-LAYER\",\r\n-          defaultValue: false,\r\n-        ),\r\n-      );\r\n-  }\r\n-}\r\n-\r\n-/// A widget, which paints its [child] into a separate save layer.\r\n-///\r\n-/// The [Paint], that is used for the save layer, can be set through [paint].\r\n-///\r\n-/// Widgets that need compositing will only be partially or not at all painted\r\n-/// into the save layer. This can cause unexpected results, which is why\r\n-/// widgets that need compositing will cause an exception in debug mode, when\r\n-/// used as the [child]. To disable this check, set\r\n-/// [debugCheckChildDoesNotNeedCompositing] to `false`.\r\n-class SaveLayer extends SingleChildRenderObjectWidget {\r\n-  /// Creates a widget, which paints its [child] into a separate save layer.\r\n-  const SaveLayer({\r\n-    required this.label,\r\n-    super.key,\r\n-    this.paint,\r\n-    this.debugCheckChildDoesNotNeedCompositing = true,\r\n-    this.child,\r\n-  }) : super(child: child);\r\n-\r\n-  /// The [Paint] to use for the save layer.\r\n-  ///\r\n-  /// If this is `null`, `Paint()` will be used.\r\n-  final Paint? paint;\r\n-\r\n-  /// Whether to check that [child] does not need compositing.\r\n-  // ignore: diagnostic_describe_all_properties\r\n-  final bool debugCheckChildDoesNotNeedCompositing;\r\n-\r\n-  /// The widget which will be painted into it's own save layer.\r\n-  ///\r\n-  /// {@macro flutter.widgets.ProxyWidget.child}\r\n-  @override\r\n-  final Widget? child;\r\n-\r\n-  final String label;\r\n-\r\n-  @override\r\n-  RenderObject createRenderObject(BuildContext context) => RenderSaveLayer(\r\n-        saveLayerPaint: paint,\r\n-        debugCheckChildDoesNotNeedCompositing: debugCheckChildDoesNotNeedCompositing,\r\n-        label: label,\r\n-      );\r\n-\r\n-  @override\r\n-  void updateRenderObject(\r\n-    BuildContext context,\r\n-    covariant RenderSaveLayer renderObject,\r\n-  ) {\r\n-    super.updateRenderObject(context, renderObject);\r\n-    renderObject\r\n-      ..saveLayerPaint = paint\r\n-      ..debugCheckChildDoesNotNeedCompositing = debugCheckChildDoesNotNeedCompositing;\r\n-  }\r\n-\r\n-  @override\r\n-  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\r\n-    super.debugFillProperties(properties);\r\n-    properties.add(DiagnosticsProperty<Paint?>(\"paint\", paint));\r\n-  }\r\n-}\r\n-\r\n-/// A [RenderProxyBox], that paints its child into a separate save layer.\r\n-class RenderSaveLayer extends RenderProxyBox {\r\n-  /// Creates a [RenderProxyBox], that paints its child into a separate save\r\n-  /// layer.\r\n-  RenderSaveLayer({\r\n-    required this.label,\r\n-    required Paint? saveLayerPaint,\r\n-    required bool debugCheckChildDoesNotNeedCompositing,\r\n-  })  : _saveLayerPaint = saveLayerPaint,\r\n-        _debugCheckChildDoesNotNeedCompositing = debugCheckChildDoesNotNeedCompositing,\r\n-        super();\r\n-\r\n-  /// The [Paint] to use for the save layer.\r\n-  ///\r\n-  /// If this is `null`, `Paint()` will be used.\r\n-  Paint? get saveLayerPaint => _saveLayerPaint;\r\n-  Paint? _saveLayerPaint;\r\n-\r\n-  final String label;\r\n-\r\n-  set saveLayerPaint(Paint? saveLayerPaint) {\r\n-    if (_saveLayerPaint == saveLayerPaint) {\r\n-      return;\r\n-    }\r\n-    markNeedsPaint();\r\n-    _saveLayerPaint = saveLayerPaint;\r\n-  }\r\n-\r\n-  /// Whether to check that [child] does not need compositing.\r\n-  // ignore: diagnostic_describe_all_properties\r\n-  bool get debugCheckChildDoesNotNeedCompositing => _debugCheckChildDoesNotNeedCompositing;\r\n-  bool _debugCheckChildDoesNotNeedCompositing;\r\n-\r\n-  set debugCheckChildDoesNotNeedCompositing(bool debugCheckChildDoesNotNeedCompositing) {\r\n-    if (_debugCheckChildDoesNotNeedCompositing == debugCheckChildDoesNotNeedCompositing) {\r\n-      return;\r\n-    }\r\n-    markNeedsCompositingBitsUpdate();\r\n-    _debugCheckChildDoesNotNeedCompositing = debugCheckChildDoesNotNeedCompositing;\r\n-  }\r\n-\r\n-  // @override\r\n-  // bool get needsCompositing {\r\n-  //   assert(() {\r\n-  //     if (_debugCheckChildDoesNotNeedCompositing) {\r\n-  //       _debugChildDoesNotNeedCompositing();\r\n-  //     }\r\n-  //     return true;\r\n-  //   }());\r\n-  //   return super.needsCompositing;\r\n-  // }\r\n-\r\n-  @override\r\n-  void paint(PaintingContext context, Offset offset) {\r\n-    var child = this.child;\r\n-    if (child == null) {\r\n-      return;\r\n-    }\r\n-\r\n-    print(child.needsCompositing);\r\n-    // context.canvas.saveLayer(offset & size, _saveLayerPaint ?? Paint());\r\n-    context.paintChild(child, offset);\r\n-    context.canvas.restore();\r\n-  }\r\n-\r\n-  @override\r\n-  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\r\n-    super.debugFillProperties(properties);\r\n-    properties.add(\r\n-      DiagnosticsProperty<Paint?>(\r\n-        \"saveLayerPaint\",\r\n-        saveLayerPaint,\r\n-      ),\r\n-    );\r\n-  }\r\n-}\r\n"
                },
                {
                    "date": 1698776676601,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -167,9 +167,9 @@\n     required Paint? saveLayerPaint,\r\n     required bool debugCheckChildDoesNotNeedCompositing,\r\n   })  : _saveLayerPaint = saveLayerPaint,\r\n         _debugCheckChildDoesNotNeedCompositing = debugCheckChildDoesNotNeedCompositing,\r\n-        super();\r\n+        super;\r\n \r\n   /// The [Paint] to use for the save layer.\r\n   ///\r\n   /// If this is `null`, `Paint()` will be used.\r\n@@ -217,9 +217,9 @@\n       return;\r\n     }\r\n \r\n     context.canvas.saveLayer(offset & size, _saveLayerPaint ?? Paint());\r\n-    context.paintChild(child, Offset.);\r\n+    context.paintChild(child, offset);\r\n     context.canvas.restore();\r\n   }\r\n \r\n   @override\r\n"
                }
            ],
            "date": 1698773867040,
            "name": "Commit-0",
            "content": "import 'package:flutter/rendering.dart';\r\nimport 'package:flutter/widgets.dart';\r\n\r\n/// A widget, which paints its [child] into a separate save layer.\r\n///\r\n/// The [Paint], that is used for the save layer, can be set through [paint].\r\n///\r\n/// Widgets that need compositing will only be partially or not at all painted\r\n/// into the save layer. This can cause unexpected results, which is why\r\n/// widgets that need compositing will cause an exception in debug mode, when\r\n/// used as the [child]. To disable this check, set\r\n/// [debugCheckChildDoesNotNeedCompositing] to `false`.\r\nclass SaveLayer extends SingleChildRenderObjectWidget {\r\n  /// Creates a widget, which paints its [child] into a separate save layer.\r\n  const SaveLayer({\r\n    Key? key,\r\n    this.paint,\r\n    this.debugCheckChildDoesNotNeedCompositing = true,\r\n    this.child,\r\n  }) : super(key: key, child: child);\r\n\r\n  /// The [Paint] to use for the save layer.\r\n  ///\r\n  /// If this is `null`, `Paint()` will be used.\r\n  final Paint? paint;\r\n\r\n  /// Whether to check that [child] does not need compositing.\r\n  // ignore: diagnostic_describe_all_properties\r\n  final bool debugCheckChildDoesNotNeedCompositing;\r\n\r\n  /// The widget which will be painted into it's own save layer.\r\n  ///\r\n  /// {@macro flutter.widgets.ProxyWidget.child}\r\n  @override\r\n  final Widget? child;\r\n\r\n  @override\r\n  RenderObject createRenderObject(BuildContext context) => RenderSaveLayer(\r\n        saveLayerPaint: paint,\r\n        debugCheckChildDoesNotNeedCompositing: debugCheckChildDoesNotNeedCompositing,\r\n      );\r\n\r\n  @override\r\n  void updateRenderObject(\r\n    BuildContext context,\r\n    covariant RenderSaveLayer renderObject,\r\n  ) {\r\n    super.updateRenderObject(context, renderObject);\r\n    renderObject\r\n      ..saveLayerPaint = paint\r\n      ..debugCheckChildDoesNotNeedCompositing = debugCheckChildDoesNotNeedCompositing;\r\n  }\r\n\r\n  @override\r\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\r\n    super.debugFillProperties(properties);\r\n    properties.add(DiagnosticsProperty<Paint?>('paint', paint));\r\n  }\r\n}\r\n\r\n/// A [RenderProxyBox], that paints its child into a separate save layer.\r\nclass RenderSaveLayer extends RenderProxyBox {\r\n  /// Creates a [RenderProxyBox], that paints its child into a separate save\r\n  /// layer.\r\n  RenderSaveLayer({\r\n    required Paint? saveLayerPaint,\r\n    required bool debugCheckChildDoesNotNeedCompositing,\r\n  })  : _saveLayerPaint = saveLayerPaint,\r\n        _debugCheckChildDoesNotNeedCompositing = debugCheckChildDoesNotNeedCompositing,\r\n        super();\r\n\r\n  /// The [Paint] to use for the save layer.\r\n  ///\r\n  /// If this is `null`, `Paint()` will be used.\r\n  Paint? get saveLayerPaint => _saveLayerPaint;\r\n  Paint? _saveLayerPaint;\r\n\r\n  set saveLayerPaint(Paint? saveLayerPaint) {\r\n    if (_saveLayerPaint == saveLayerPaint) return;\r\n    markNeedsPaint();\r\n    _saveLayerPaint = saveLayerPaint;\r\n  }\r\n\r\n  /// Whether to check that [child] does not need compositing.\r\n  // ignore: diagnostic_describe_all_properties\r\n  bool get debugCheckChildDoesNotNeedCompositing => _debugCheckChildDoesNotNeedCompositing;\r\n  bool _debugCheckChildDoesNotNeedCompositing;\r\n\r\n  set debugCheckChildDoesNotNeedCompositing(bool debugCheckChildDoesNotNeedCompositing) {\r\n    if (_debugCheckChildDoesNotNeedCompositing == debugCheckChildDoesNotNeedCompositing) return;\r\n    markNeedsCompositingBitsUpdate();\r\n    _debugCheckChildDoesNotNeedCompositing = debugCheckChildDoesNotNeedCompositing;\r\n  }\r\n\r\n  @override\r\n  bool get needsCompositing {\r\n    assert(() {\r\n      if (_debugCheckChildDoesNotNeedCompositing) {\r\n        _debugChildDoesNotNeedCompositing();\r\n      }\r\n      return true;\r\n    }());\r\n    return super.needsCompositing;\r\n  }\r\n\r\n  @override\r\n  void paint(PaintingContext context, Offset offset) {\r\n    final child = this.child;\r\n    if (child == null) {\r\n      return;\r\n    }\r\n\r\n    context.canvas.saveLayer(offset & size, _saveLayerPaint ?? Paint());\r\n    context.paintChild(child, offset);\r\n    context.canvas.restore();\r\n  }\r\n\r\n  void _debugChildDoesNotNeedCompositing() {\r\n    final child = this.child;\r\n    if (child == null) {\r\n      return;\r\n    }\r\n\r\n    if (child.needsCompositing) {\r\n      throw FlutterError.fromParts([\r\n        ErrorSummary('`SaveLayer.child` cannot contain compositing layers.'),\r\n        ErrorDescription(\r\n          'The save layer, into which SaveLayer.child is painted, cannot '\r\n          'encompass compositing layers.',\r\n        ),\r\n        ErrorHint(\r\n          'Ensure `SaveLayer.child` contains no widgets which need '\r\n          'compositing, such as `RepaintBoundary`.',\r\n        ),\r\n        _leafCompositingRenderObjects(child).first.describeForError('')\r\n      ]);\r\n    }\r\n  }\r\n\r\n  @override\r\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\r\n    super.debugFillProperties(properties);\r\n    properties.add(DiagnosticsProperty<Paint?>(\r\n      'saveLayerPaint',\r\n      saveLayerPaint,\r\n    ));\r\n  }\r\n}\r\n\r\nIterable<RenderObject> _leafCompositingRenderObjects(\r\n  RenderObject renderObject,\r\n) =>\r\n    (_renderTreeNodes(renderObject).toList()..sort((a, b) => a.depth - b.depth)).where(_isLeafCompositingRenderObject);\r\n\r\nIterable<RenderObject> _renderTreeNodes(RenderObject root) sync* {\r\n  final children = <RenderObject>[];\r\n  root.visitChildren((child) {\r\n    children.add(child);\r\n  });\r\n  yield root;\r\n  yield* children.expand((child) => _renderTreeNodes(child));\r\n}\r\n\r\nbool _isLeafCompositingRenderObject(RenderObject renderObject) {\r\n  if (renderObject.needsCompositing) {\r\n    var hasChildThatNeedsCompositing = false;\r\n    renderObject.visitChildren((child) {\r\n      if (!hasChildThatNeedsCompositing) {\r\n        hasChildThatNeedsCompositing = child.needsCompositing;\r\n      }\r\n    });\r\n    return !hasChildThatNeedsCompositing;\r\n  } else {\r\n    return false;\r\n  }\r\n}\r\n"
        }
    ]
}