{
    "sourceFile": "lib/widgets/mouse_scroll.dart",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 8,
            "patches": [
                {
                    "date": 1698502088090,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1698502157877,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,176 @@\n+// ignore_for_file: unnecessary_breaks, discarded_futures\r\n+\r\n+import \"dart:math\" as math;\r\n+\r\n+import \"package:flutter/gestures.dart\";\r\n+import \"package:flutter/material.dart\";\r\n+import \"package:provider/provider.dart\";\r\n+\r\n+class MouseScroll extends StatelessWidget {\r\n+  const MouseScroll({\r\n+    required this.builder,\r\n+    this.controller,\r\n+    super.key,\r\n+    this.mobilePhysics = kMobilePhysics,\r\n+    this.duration = const Duration(milliseconds: 380),\r\n+    this.scrollSpeed = 1.0,\r\n+    this.animationCurve = Curves.easeOutQuart,\r\n+  });\r\n+  final ScrollController controller;\r\n+  final ScrollPhysics mobilePhysics;\r\n+  final Duration duration;\r\n+  final double scrollSpeed;\r\n+  final Curve animationCurve;\r\n+  final Widget Function(BuildContext, ScrollController, ScrollPhysics) builder;\r\n+\r\n+  @override\r\n+  Widget build(BuildContext context) {\r\n+    return ChangeNotifierProvider<ScrollState>(\r\n+      create: (BuildContext context) => ScrollState(mobilePhysics, controller, duration),\r\n+      builder: (BuildContext context, _) {\r\n+        ScrollState scrollState = context.read<ScrollState>();\r\n+        ScrollController controller = scrollState.controller;\r\n+        var (ScrollPhysics physics, _) = context.select((ScrollState s) => (s.activePhysics, s.updateState));\r\n+\r\n+        scrollState.handlePipelinedScroll?.call();\r\n+        return Listener(\r\n+          onPointerSignal: (PointerSignalEvent signalEvent) {\r\n+            scrollState.handleDesktopScroll(signalEvent, scrollSpeed, animationCurve);\r\n+          },\r\n+          onPointerDown: (PointerDownEvent pointerEvent) {\r\n+            scrollState.handleTouchScroll(pointerEvent);\r\n+          },\r\n+          child: builder(context, controller, physics),\r\n+        );\r\n+      },\r\n+    );\r\n+  }\r\n+}\r\n+\r\n+const BouncingScrollPhysics kMobilePhysics = BouncingScrollPhysics();\r\n+const NeverScrollableScrollPhysics kDesktopPhysics = NeverScrollableScrollPhysics();\r\n+\r\n+class ScrollState with ChangeNotifier {\r\n+  ScrollState(this.mobilePhysics, this.controller, this.duration);\r\n+\r\n+  final ScrollPhysics mobilePhysics;\r\n+  final ScrollController controller;\r\n+  final Duration duration;\r\n+\r\n+  late ScrollPhysics activePhysics = mobilePhysics;\r\n+  double _futurePosition = 0;\r\n+  bool updateState = false;\r\n+\r\n+  bool _previousDeltaIsPositive = false;\r\n+  double? _lastLock;\r\n+\r\n+  Future<void>? _animationEnd;\r\n+\r\n+  /// Scroll that is pipelined to be handled after the current render is finished.\r\n+  /// This is used to ensure that the scroll is handled while transitioning from physics.\r\n+  void Function()? handlePipelinedScroll;\r\n+\r\n+  static double calcMaxDelta(ScrollController controller, double delta) {\r\n+    double pixels = controller.position.pixels;\r\n+\r\n+    return delta.sign > 0\r\n+        ? math.min(pixels + delta, controller.position.maxScrollExtent) - pixels\r\n+        : math.max(pixels + delta, controller.position.minScrollExtent) - pixels;\r\n+  }\r\n+\r\n+  void handleDesktopScroll(\r\n+    PointerSignalEvent event,\r\n+    double scrollSpeed,\r\n+    Curve animationCurve, {\r\n+    bool shouldReadLastDirection = true,\r\n+  }) {\r\n+    // Ensure desktop physics is being used.\r\n+    if (activePhysics == kMobilePhysics || _lastLock != null) {\r\n+      if (_lastLock != null) {\r\n+        updateState = !updateState;\r\n+      }\r\n+      if (event case PointerScrollEvent()) {\r\n+        double pixels = controller.position.pixels;\r\n+\r\n+        /// If the scroll is at the top or bottom, don't allow the user to scroll further.\r\n+        if (pixels <= controller.position.minScrollExtent && event.scrollDelta.dy < 0 ||\r\n+            pixels >= controller.position.maxScrollExtent && event.scrollDelta.dy > 0) {\r\n+          return;\r\n+        } else {\r\n+          activePhysics = kDesktopPhysics;\r\n+        }\r\n+\r\n+        double computedDelta = calcMaxDelta(controller, event.scrollDelta.dy);\r\n+        bool isOutOfBounds = pixels < controller.position.minScrollExtent || //\r\n+            pixels > controller.position.maxScrollExtent;\r\n+\r\n+        if (!isOutOfBounds) {\r\n+          controller.jumpTo(_lastLock ?? (pixels - computedDelta));\r\n+        }\r\n+        double deltaDifference = computedDelta - event.scrollDelta.dy;\r\n+        handlePipelinedScroll = () {\r\n+          handlePipelinedScroll = null;\r\n+          double currentPos = controller.position.pixels;\r\n+          double currentDelta = event.scrollDelta.dy;\r\n+          bool shouldLock = _lastLock != null\r\n+              ? (_lastLock == currentPos)\r\n+              : (pixels != currentPos + deltaDifference &&\r\n+                  (currentPos != controller.position.maxScrollExtent || currentDelta < 0) &&\r\n+                  (currentPos != controller.position.minScrollExtent || currentDelta > 0));\r\n+\r\n+          if (!isOutOfBounds && shouldLock) {\r\n+            controller.jumpTo(pixels);\r\n+            _lastLock = pixels;\r\n+            controller.position.moveTo(pixels).whenComplete(() {\r\n+              if (activePhysics == kDesktopPhysics) {\r\n+                activePhysics = kMobilePhysics;\r\n+                notifyListeners();\r\n+              }\r\n+            });\r\n+            return;\r\n+          } else {\r\n+            if (_lastLock != null || isOutOfBounds) {\r\n+              double jumpTarget = _lastLock != null //\r\n+                  ? pixels\r\n+                  : (currentPos - calcMaxDelta(controller, currentDelta));\r\n+\r\n+              controller.jumpTo(jumpTarget);\r\n+            }\r\n+            _lastLock = null;\r\n+            handleDesktopScroll(event, scrollSpeed, animationCurve, shouldReadLastDirection: false);\r\n+          }\r\n+        };\r\n+        notifyListeners();\r\n+      }\r\n+    } else if (event case PointerScrollEvent()) {\r\n+      bool currentDeltaPositive = event.scrollDelta.dy > 0;\r\n+      if (shouldReadLastDirection && currentDeltaPositive == _previousDeltaIsPositive) {\r\n+        _futurePosition += event.scrollDelta.dy * scrollSpeed;\r\n+      } else {\r\n+        _futurePosition = controller.position.pixels + event.scrollDelta.dy * scrollSpeed;\r\n+      }\r\n+      _previousDeltaIsPositive = currentDeltaPositive;\r\n+\r\n+      Future<void> animationEnd = _animationEnd = controller.animateTo(\r\n+        _futurePosition,\r\n+        duration: duration,\r\n+        curve: animationCurve,\r\n+      );\r\n+      animationEnd.whenComplete(() {\r\n+        if (animationEnd == _animationEnd && activePhysics == kDesktopPhysics) {\r\n+          activePhysics = mobilePhysics;\r\n+          notifyListeners();\r\n+        }\r\n+      });\r\n+    }\r\n+  }\r\n+\r\n+  void handleTouchScroll(PointerDownEvent event) {\r\n+    if (activePhysics == kDesktopPhysics) {\r\n+      activePhysics = mobilePhysics;\r\n+      notifyListeners();\r\n+    }\r\n+  }\r\n+}\r\n+\r\n+class MiddleClickNotification extends Notification {}\r\n"
                },
                {
                    "date": 1698502189104,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,189 @@\n+// ignore_for_file: unnecessary_breaks, discarded_futures\r\n+\r\n+import \"dart:math\" as math;\r\n+\r\n+import \"package:flutter/gestures.dart\";\r\n+import \"package:flutter/material.dart\";\r\n+import \"package:provider/provider.dart\";\r\n+\r\n+class MouseScroll extends StatefulWidget {\r\n+  const MouseScroll({\r\n+    required this.builder,\r\n+    this.controller,\r\n+    super.key,\r\n+    this.mobilePhysics = kMobilePhysics,\r\n+    this.duration = const Duration(milliseconds: 380),\r\n+    this.scrollSpeed = 1.0,\r\n+    this.animationCurve = Curves.easeOutQuart,\r\n+  });\r\n+  final ScrollController? controller;\r\n+  final ScrollPhysics mobilePhysics;\r\n+  final Duration duration;\r\n+  final double scrollSpeed;\r\n+  final Curve animationCurve;\r\n+  final Widget Function(BuildContext, ScrollController, ScrollPhysics) builder;\r\n+\r\n+  @override\r\n+  State<MouseScroll> createState() => _MouseScrollState();\r\n+}\r\n+\r\n+class _MouseScrollState extends State<MouseScroll> {\r\n+  late final ScrollController scrollController;\r\n+\r\n+  @override\r\n+  void initState() {\r\n+    super.initState();\r\n+    \r\n+  }\r\n+\r\n+  @override\r\n+  Widget build(BuildContext context) {\r\n+    return ChangeNotifierProvider<ScrollState>(\r\n+      create: (BuildContext context) => ScrollState(widget.mobilePhysics, widget.controller, widget.duration),\r\n+      builder: (BuildContext context, _) {\r\n+        ScrollState scrollState = context.read<ScrollState>();\r\n+        ScrollController controller = scrollState.controller;\r\n+        var (ScrollPhysics physics, _) = context.select((ScrollState s) => (s.activePhysics, s.updateState));\r\n+\r\n+        scrollState.handlePipelinedScroll?.call();\r\n+        return Listener(\r\n+          onPointerSignal: (PointerSignalEvent signalEvent) {\r\n+            scrollState.handleDesktopScroll(signalEvent, widget.scrollSpeed, widget.animationCurve);\r\n+          },\r\n+          onPointerDown: (PointerDownEvent pointerEvent) {\r\n+            scrollState.handleTouchScroll(pointerEvent);\r\n+          },\r\n+          child: widget.builder(context, controller, physics),\r\n+        );\r\n+      },\r\n+    );\r\n+  }\r\n+}\r\n+\r\n+const BouncingScrollPhysics kMobilePhysics = BouncingScrollPhysics();\r\n+const NeverScrollableScrollPhysics kDesktopPhysics = NeverScrollableScrollPhysics();\r\n+\r\n+class ScrollState with ChangeNotifier {\r\n+  ScrollState(this.mobilePhysics, this.controller, this.duration);\r\n+\r\n+  final ScrollPhysics mobilePhysics;\r\n+  final ScrollController controller;\r\n+  final Duration duration;\r\n+\r\n+  late ScrollPhysics activePhysics = mobilePhysics;\r\n+  double _futurePosition = 0;\r\n+  bool updateState = false;\r\n+\r\n+  bool _previousDeltaIsPositive = false;\r\n+  double? _lastLock;\r\n+\r\n+  Future<void>? _animationEnd;\r\n+\r\n+  /// Scroll that is pipelined to be handled after the current render is finished.\r\n+  /// This is used to ensure that the scroll is handled while transitioning from physics.\r\n+  void Function()? handlePipelinedScroll;\r\n+\r\n+  static double calcMaxDelta(ScrollController controller, double delta) {\r\n+    double pixels = controller.position.pixels;\r\n+\r\n+    return delta.sign > 0\r\n+        ? math.min(pixels + delta, controller.position.maxScrollExtent) - pixels\r\n+        : math.max(pixels + delta, controller.position.minScrollExtent) - pixels;\r\n+  }\r\n+\r\n+  void handleDesktopScroll(\r\n+    PointerSignalEvent event,\r\n+    double scrollSpeed,\r\n+    Curve animationCurve, {\r\n+    bool shouldReadLastDirection = true,\r\n+  }) {\r\n+    // Ensure desktop physics is being used.\r\n+    if (activePhysics == kMobilePhysics || _lastLock != null) {\r\n+      if (_lastLock != null) {\r\n+        updateState = !updateState;\r\n+      }\r\n+      if (event case PointerScrollEvent()) {\r\n+        double pixels = controller.position.pixels;\r\n+\r\n+        /// If the scroll is at the top or bottom, don't allow the user to scroll further.\r\n+        if (pixels <= controller.position.minScrollExtent && event.scrollDelta.dy < 0 ||\r\n+            pixels >= controller.position.maxScrollExtent && event.scrollDelta.dy > 0) {\r\n+          return;\r\n+        } else {\r\n+          activePhysics = kDesktopPhysics;\r\n+        }\r\n+\r\n+        double computedDelta = calcMaxDelta(controller, event.scrollDelta.dy);\r\n+        bool isOutOfBounds = pixels < controller.position.minScrollExtent || //\r\n+            pixels > controller.position.maxScrollExtent;\r\n+\r\n+        if (!isOutOfBounds) {\r\n+          controller.jumpTo(_lastLock ?? (pixels - computedDelta));\r\n+        }\r\n+        double deltaDifference = computedDelta - event.scrollDelta.dy;\r\n+        handlePipelinedScroll = () {\r\n+          handlePipelinedScroll = null;\r\n+          double currentPos = controller.position.pixels;\r\n+          double currentDelta = event.scrollDelta.dy;\r\n+          bool shouldLock = _lastLock != null\r\n+              ? (_lastLock == currentPos)\r\n+              : (pixels != currentPos + deltaDifference &&\r\n+                  (currentPos != controller.position.maxScrollExtent || currentDelta < 0) &&\r\n+                  (currentPos != controller.position.minScrollExtent || currentDelta > 0));\r\n+\r\n+          if (!isOutOfBounds && shouldLock) {\r\n+            controller.jumpTo(pixels);\r\n+            _lastLock = pixels;\r\n+            controller.position.moveTo(pixels).whenComplete(() {\r\n+              if (activePhysics == kDesktopPhysics) {\r\n+                activePhysics = kMobilePhysics;\r\n+                notifyListeners();\r\n+              }\r\n+            });\r\n+            return;\r\n+          } else {\r\n+            if (_lastLock != null || isOutOfBounds) {\r\n+              double jumpTarget = _lastLock != null //\r\n+                  ? pixels\r\n+                  : (currentPos - calcMaxDelta(controller, currentDelta));\r\n+\r\n+              controller.jumpTo(jumpTarget);\r\n+            }\r\n+            _lastLock = null;\r\n+            handleDesktopScroll(event, scrollSpeed, animationCurve, shouldReadLastDirection: false);\r\n+          }\r\n+        };\r\n+        notifyListeners();\r\n+      }\r\n+    } else if (event case PointerScrollEvent()) {\r\n+      bool currentDeltaPositive = event.scrollDelta.dy > 0;\r\n+      if (shouldReadLastDirection && currentDeltaPositive == _previousDeltaIsPositive) {\r\n+        _futurePosition += event.scrollDelta.dy * scrollSpeed;\r\n+      } else {\r\n+        _futurePosition = controller.position.pixels + event.scrollDelta.dy * scrollSpeed;\r\n+      }\r\n+      _previousDeltaIsPositive = currentDeltaPositive;\r\n+\r\n+      Future<void> animationEnd = _animationEnd = controller.animateTo(\r\n+        _futurePosition,\r\n+        duration: duration,\r\n+        curve: animationCurve,\r\n+      );\r\n+      animationEnd.whenComplete(() {\r\n+        if (animationEnd == _animationEnd && activePhysics == kDesktopPhysics) {\r\n+          activePhysics = mobilePhysics;\r\n+          notifyListeners();\r\n+        }\r\n+      });\r\n+    }\r\n+  }\r\n+\r\n+  void handleTouchScroll(PointerDownEvent event) {\r\n+    if (activePhysics == kDesktopPhysics) {\r\n+      activePhysics = mobilePhysics;\r\n+      notifyListeners();\r\n+    }\r\n+  }\r\n+}\r\n+\r\n+class MiddleClickNotification extends Notification {}\r\n"
                },
                {
                    "date": 1698502274292,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -32,381 +32,39 @@\n \r\n   @override\r\n   void initState() {\r\n     super.initState();\r\n-    \r\n-  }\r\n \r\n-  @override\r\n-  Widget build(BuildContext context) {\r\n-    return ChangeNotifierProvider<ScrollState>(\r\n-      create: (BuildContext context) => ScrollState(widget.mobilePhysics, widget.controller, widget.duration),\r\n-      builder: (BuildContext context, _) {\r\n-        ScrollState scrollState = context.read<ScrollState>();\r\n-        ScrollController controller = scrollState.controller;\r\n-        var (ScrollPhysics physics, _) = context.select((ScrollState s) => (s.activePhysics, s.updateState));\r\n-\r\n-        scrollState.handlePipelinedScroll?.call();\r\n-        return Listener(\r\n-          onPointerSignal: (PointerSignalEvent signalEvent) {\r\n-            scrollState.handleDesktopScroll(signalEvent, widget.scrollSpeed, widget.animationCurve);\r\n-          },\r\n-          onPointerDown: (PointerDownEvent pointerEvent) {\r\n-            scrollState.handleTouchScroll(pointerEvent);\r\n-          },\r\n-          child: widget.builder(context, controller, physics),\r\n-        );\r\n-      },\r\n-    );\r\n+    scrollController = widget.controller ?? ScrollController();\r\n   }\r\n-}\r\n \r\n-const BouncingScrollPhysics kMobilePhysics = BouncingScrollPhysics();\r\n-const NeverScrollableScrollPhysics kDesktopPhysics = NeverScrollableScrollPhysics();\r\n-\r\n-class ScrollState with ChangeNotifier {\r\n-  ScrollState(this.mobilePhysics, this.controller, this.duration);\r\n-\r\n-  final ScrollPhysics mobilePhysics;\r\n-  final ScrollController controller;\r\n-  final Duration duration;\r\n-\r\n-  late ScrollPhysics activePhysics = mobilePhysics;\r\n-  double _futurePosition = 0;\r\n-  bool updateState = false;\r\n-\r\n-  bool _previousDeltaIsPositive = false;\r\n-  double? _lastLock;\r\n-\r\n-  Future<void>? _animationEnd;\r\n-\r\n-  /// Scroll that is pipelined to be handled after the current render is finished.\r\n-  /// This is used to ensure that the scroll is handled while transitioning from physics.\r\n-  void Function()? handlePipelinedScroll;\r\n-\r\n-  static double calcMaxDelta(ScrollController controller, double delta) {\r\n-    double pixels = controller.position.pixels;\r\n-\r\n-    return delta.sign > 0\r\n-        ? math.min(pixels + delta, controller.position.maxScrollExtent) - pixels\r\n-        : math.max(pixels + delta, controller.position.minScrollExtent) - pixels;\r\n-  }\r\n-\r\n-  void handleDesktopScroll(\r\n-    PointerSignalEvent event,\r\n-    double scrollSpeed,\r\n-    Curve animationCurve, {\r\n-    bool shouldReadLastDirection = true,\r\n-  }) {\r\n-    // Ensure desktop physics is being used.\r\n-    if (activePhysics == kMobilePhysics || _lastLock != null) {\r\n-      if (_lastLock != null) {\r\n-        updateState = !updateState;\r\n-      }\r\n-      if (event case PointerScrollEvent()) {\r\n-        double pixels = controller.position.pixels;\r\n-\r\n-        /// If the scroll is at the top or bottom, don't allow the user to scroll further.\r\n-        if (pixels <= controller.position.minScrollExtent && event.scrollDelta.dy < 0 ||\r\n-            pixels >= controller.position.maxScrollExtent && event.scrollDelta.dy > 0) {\r\n-          return;\r\n-        } else {\r\n-          activePhysics = kDesktopPhysics;\r\n-        }\r\n-\r\n-        double computedDelta = calcMaxDelta(controller, event.scrollDelta.dy);\r\n-        bool isOutOfBounds = pixels < controller.position.minScrollExtent || //\r\n-            pixels > controller.position.maxScrollExtent;\r\n-\r\n-        if (!isOutOfBounds) {\r\n-          controller.jumpTo(_lastLock ?? (pixels - computedDelta));\r\n-        }\r\n-        double deltaDifference = computedDelta - event.scrollDelta.dy;\r\n-        handlePipelinedScroll = () {\r\n-          handlePipelinedScroll = null;\r\n-          double currentPos = controller.position.pixels;\r\n-          double currentDelta = event.scrollDelta.dy;\r\n-          bool shouldLock = _lastLock != null\r\n-              ? (_lastLock == currentPos)\r\n-              : (pixels != currentPos + deltaDifference &&\r\n-                  (currentPos != controller.position.maxScrollExtent || currentDelta < 0) &&\r\n-                  (currentPos != controller.position.minScrollExtent || currentDelta > 0));\r\n-\r\n-          if (!isOutOfBounds && shouldLock) {\r\n-            controller.jumpTo(pixels);\r\n-            _lastLock = pixels;\r\n-            controller.position.moveTo(pixels).whenComplete(() {\r\n-              if (activePhysics == kDesktopPhysics) {\r\n-                activePhysics = kMobilePhysics;\r\n-                notifyListeners();\r\n-              }\r\n-            });\r\n-            return;\r\n-          } else {\r\n-            if (_lastLock != null || isOutOfBounds) {\r\n-              double jumpTarget = _lastLock != null //\r\n-                  ? pixels\r\n-                  : (currentPos - calcMaxDelta(controller, currentDelta));\r\n-\r\n-              controller.jumpTo(jumpTarget);\r\n-            }\r\n-            _lastLock = null;\r\n-            handleDesktopScroll(event, scrollSpeed, animationCurve, shouldReadLastDirection: false);\r\n-          }\r\n-        };\r\n-        notifyListeners();\r\n-      }\r\n-    } else if (event case PointerScrollEvent()) {\r\n-      bool currentDeltaPositive = event.scrollDelta.dy > 0;\r\n-      if (shouldReadLastDirection && currentDeltaPositive == _previousDeltaIsPositive) {\r\n-        _futurePosition += event.scrollDelta.dy * scrollSpeed;\r\n-      } else {\r\n-        _futurePosition = controller.position.pixels + event.scrollDelta.dy * scrollSpeed;\r\n-      }\r\n-      _previousDeltaIsPositive = currentDeltaPositive;\r\n-\r\n-      Future<void> animationEnd = _animationEnd = controller.animateTo(\r\n-        _futurePosition,\r\n-        duration: duration,\r\n-        curve: animationCurve,\r\n-      );\r\n-      animationEnd.whenComplete(() {\r\n-        if (animationEnd == _animationEnd && activePhysics == kDesktopPhysics) {\r\n-          activePhysics = mobilePhysics;\r\n-          notifyListeners();\r\n-        }\r\n-      });\r\n-    }\r\n-  }\r\n-\r\n-  void handleTouchScroll(PointerDownEvent event) {\r\n-    if (activePhysics == kDesktopPhysics) {\r\n-      activePhysics = mobilePhysics;\r\n-      notifyListeners();\r\n-    }\r\n-  }\r\n-}\r\n-\r\n-class MiddleClickNotification extends Notification {}\r\n-// ignore_for_file: unnecessary_breaks, discarded_futures\r\n-\r\n-import \"dart:math\" as math;\r\n-\r\n-import \"package:flutter/gestures.dart\";\r\n-import \"package:flutter/material.dart\";\r\n-import \"package:provider/provider.dart\";\r\n-\r\n-class MouseScroll extends StatelessWidget {\r\n-  const MouseScroll({\r\n-    required this.builder,\r\n-    this.controller,\r\n-    super.key,\r\n-    this.mobilePhysics = kMobilePhysics,\r\n-    this.duration = const Duration(milliseconds: 380),\r\n-    this.scrollSpeed = 1.0,\r\n-    this.animationCurve = Curves.easeOutQuart,\r\n-  });\r\n-  final ScrollController controller;\r\n-  final ScrollPhysics mobilePhysics;\r\n-  final Duration duration;\r\n-  final double scrollSpeed;\r\n-  final Curve animationCurve;\r\n-  final Widget Function(BuildContext, ScrollController, ScrollPhysics) builder;\r\n-\r\n   @override\r\n-  Widget build(BuildContext context) {\r\n-    return ChangeNotifierProvider<ScrollState>(\r\n-      create: (BuildContext context) => ScrollState(mobilePhysics, controller, duration),\r\n-      builder: (BuildContext context, _) {\r\n-        ScrollState scrollState = context.read<ScrollState>();\r\n-        ScrollController controller = scrollState.controller;\r\n-        var (ScrollPhysics physics, _) = context.select((ScrollState s) => (s.activePhysics, s.updateState));\r\n-\r\n-        scrollState.handlePipelinedScroll?.call();\r\n-        return Listener(\r\n-          onPointerSignal: (PointerSignalEvent signalEvent) {\r\n-            scrollState.handleDesktopScroll(signalEvent, scrollSpeed, animationCurve);\r\n-          },\r\n-          onPointerDown: (PointerDownEvent pointerEvent) {\r\n-            scrollState.handleTouchScroll(pointerEvent);\r\n-          },\r\n-          child: builder(context, controller, physics),\r\n-        );\r\n-      },\r\n-    );\r\n-  }\r\n-}\r\n-\r\n-const BouncingScrollPhysics kMobilePhysics = BouncingScrollPhysics();\r\n-const NeverScrollableScrollPhysics kDesktopPhysics = NeverScrollableScrollPhysics();\r\n-\r\n-class ScrollState with ChangeNotifier {\r\n-  ScrollState(this.mobilePhysics, this.controller, this.duration);\r\n-\r\n-  final ScrollPhysics mobilePhysics;\r\n-  final ScrollController controller;\r\n-  final Duration duration;\r\n-\r\n-  late ScrollPhysics activePhysics = mobilePhysics;\r\n-  double _futurePosition = 0;\r\n-  bool updateState = false;\r\n-\r\n-  bool _previousDeltaIsPositive = false;\r\n-  double? _lastLock;\r\n-\r\n-  Future<void>? _animationEnd;\r\n-\r\n-  /// Scroll that is pipelined to be handled after the current render is finished.\r\n-  /// This is used to ensure that the scroll is handled while transitioning from physics.\r\n-  void Function()? handlePipelinedScroll;\r\n-\r\n-  static double calcMaxDelta(ScrollController controller, double delta) {\r\n-    double pixels = controller.position.pixels;\r\n-\r\n-    return delta.sign > 0\r\n-        ? math.min(pixels + delta, controller.position.maxScrollExtent) - pixels\r\n-        : math.max(pixels + delta, controller.position.minScrollExtent) - pixels;\r\n-  }\r\n-\r\n-  void handleDesktopScroll(\r\n-    PointerSignalEvent event,\r\n-    double scrollSpeed,\r\n-    Curve animationCurve, {\r\n-    bool shouldReadLastDirection = true,\r\n-  }) {\r\n-    // Ensure desktop physics is being used.\r\n-    if (activePhysics == kMobilePhysics || _lastLock != null) {\r\n-      if (_lastLock != null) {\r\n-        updateState = !updateState;\r\n-      }\r\n-      if (event case PointerScrollEvent()) {\r\n-        double pixels = controller.position.pixels;\r\n-\r\n-        /// If the scroll is at the top or bottom, don't allow the user to scroll further.\r\n-        if (pixels <= controller.position.minScrollExtent && event.scrollDelta.dy < 0 ||\r\n-            pixels >= controller.position.maxScrollExtent && event.scrollDelta.dy > 0) {\r\n-          return;\r\n-        } else {\r\n-          activePhysics = kDesktopPhysics;\r\n-        }\r\n-\r\n-        double computedDelta = calcMaxDelta(controller, event.scrollDelta.dy);\r\n-        bool isOutOfBounds = pixels < controller.position.minScrollExtent || //\r\n-            pixels > controller.position.maxScrollExtent;\r\n-\r\n-        if (!isOutOfBounds) {\r\n-          controller.jumpTo(_lastLock ?? (pixels - computedDelta));\r\n-        }\r\n-        double deltaDifference = computedDelta - event.scrollDelta.dy;\r\n-        handlePipelinedScroll = () {\r\n-          handlePipelinedScroll = null;\r\n-          double currentPos = controller.position.pixels;\r\n-          double currentDelta = event.scrollDelta.dy;\r\n-          bool shouldLock = _lastLock != null\r\n-              ? (_lastLock == currentPos)\r\n-              : (pixels != currentPos + deltaDifference &&\r\n-                  (currentPos != controller.position.maxScrollExtent || currentDelta < 0) &&\r\n-                  (currentPos != controller.position.minScrollExtent || currentDelta > 0));\r\n-\r\n-          if (!isOutOfBounds && shouldLock) {\r\n-            controller.jumpTo(pixels);\r\n-            _lastLock = pixels;\r\n-            controller.position.moveTo(pixels).whenComplete(() {\r\n-              if (activePhysics == kDesktopPhysics) {\r\n-                activePhysics = kMobilePhysics;\r\n-                notifyListeners();\r\n-              }\r\n-            });\r\n-            return;\r\n-          } else {\r\n-            if (_lastLock != null || isOutOfBounds) {\r\n-              double jumpTarget = _lastLock != null //\r\n-                  ? pixels\r\n-                  : (currentPos - calcMaxDelta(controller, currentDelta));\r\n-\r\n-              controller.jumpTo(jumpTarget);\r\n-            }\r\n-            _lastLock = null;\r\n-            handleDesktopScroll(event, scrollSpeed, animationCurve, shouldReadLastDirection: false);\r\n-          }\r\n-        };\r\n-        notifyListeners();\r\n-      }\r\n-    } else if (event case PointerScrollEvent()) {\r\n-      bool currentDeltaPositive = event.scrollDelta.dy > 0;\r\n-      if (shouldReadLastDirection && currentDeltaPositive == _previousDeltaIsPositive) {\r\n-        _futurePosition += event.scrollDelta.dy * scrollSpeed;\r\n-      } else {\r\n-        _futurePosition = controller.position.pixels + event.scrollDelta.dy * scrollSpeed;\r\n-      }\r\n-      _previousDeltaIsPositive = currentDeltaPositive;\r\n-\r\n-      Future<void> animationEnd = _animationEnd = controller.animateTo(\r\n-        _futurePosition,\r\n-        duration: duration,\r\n-        curve: animationCurve,\r\n-      );\r\n-      animationEnd.whenComplete(() {\r\n-        if (animationEnd == _animationEnd && activePhysics == kDesktopPhysics) {\r\n-          activePhysics = mobilePhysics;\r\n-          notifyListeners();\r\n-        }\r\n-      });\r\n+  void dispose() {\r\n+    if (widget.controller case null) {\r\n+      scrollController.dispose();\r\n     }\r\n-  }\r\n \r\n-  void handleTouchScroll(PointerDownEvent event) {\r\n-    if (activePhysics == kDesktopPhysics) {\r\n-      activePhysics = mobilePhysics;\r\n-      notifyListeners();\r\n-    }\r\n+    super.dispose();\r\n   }\r\n-}\r\n \r\n-class MiddleClickNotification extends Notification {}\r\n-// ignore_for_file: unnecessary_breaks, discarded_futures\r\n-\r\n-import \"dart:math\" as math;\r\n-\r\n-import \"package:flutter/gestures.dart\";\r\n-import \"package:flutter/material.dart\";\r\n-import \"package:provider/provider.dart\";\r\n-\r\n-class MouseScroll extends StatelessWidget {\r\n-  const MouseScroll({\r\n-    required this.builder,\r\n-    required this.controller,\r\n-    super.key,\r\n-    this.mobilePhysics = kMobilePhysics,\r\n-    this.duration = const Duration(milliseconds: 380),\r\n-    this.scrollSpeed = 1.0,\r\n-    this.animationCurve = Curves.easeOutQuart,\r\n-  });\r\n-  final ScrollController controller;\r\n-  final ScrollPhysics mobilePhysics;\r\n-  final Duration duration;\r\n-  final double scrollSpeed;\r\n-  final Curve animationCurve;\r\n-  final Widget Function(BuildContext, ScrollController, ScrollPhysics) builder;\r\n-\r\n   @override\r\n   Widget build(BuildContext context) {\r\n     return ChangeNotifierProvider<ScrollState>(\r\n-      create: (BuildContext context) => ScrollState(mobilePhysics, controller, duration),\r\n+      create: (BuildContext context) => ScrollState(widget.mobilePhysics, scrollController, widget.duration),\r\n       builder: (BuildContext context, _) {\r\n         ScrollState scrollState = context.read<ScrollState>();\r\n         ScrollController controller = scrollState.controller;\r\n         var (ScrollPhysics physics, _) = context.select((ScrollState s) => (s.activePhysics, s.updateState));\r\n \r\n         scrollState.handlePipelinedScroll?.call();\r\n         return Listener(\r\n           onPointerSignal: (PointerSignalEvent signalEvent) {\r\n-            scrollState.handleDesktopScroll(signalEvent, scrollSpeed, animationCurve);\r\n+            scrollState.handleDesktopScroll(signalEvent, widget.scrollSpeed, widget.animationCurve);\r\n           },\r\n           onPointerDown: (PointerDownEvent pointerEvent) {\r\n             scrollState.handleTouchScroll(pointerEvent);\r\n           },\r\n-          child: builder(context, controller, physics),\r\n+          child: widget.builder(context, controller, physics),\r\n         );\r\n       },\r\n     );\r\n   }\r\n@@ -537,5 +195,4 @@\n     }\r\n   }\r\n }\r\n \r\n-class MiddleClickNotification extends Notification {}\r\n"
                },
                {
                    "date": 1698502312322,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -195,4 +195,5 @@\n     }\r\n   }\r\n }\r\n \r\n+class M\n\\ No newline at end of file\n"
                },
                {
                    "date": 1698502342516,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -195,5 +195,9 @@\n     }\r\n   }\r\n }\r\n \r\n-class M\n\\ No newline at end of file\n+class MouseSingleChildScrollView extends SingleChildScrollView {\r\n+  const MouseSingleChildScrollView({super.key});\r\n+\r\n+\r\n+}\r\n"
                },
                {
                    "date": 1698502383696,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -195,9 +195,12 @@\n     }\r\n   }\r\n }\r\n \r\n-class MouseSingleChildScrollView extends SingleChildScrollView {\r\n+class MouseSingleChildScrollView extends S{\r\n   const MouseSingleChildScrollView({super.key});\r\n \r\n-\r\n+  @override\r\n+  Widget build(BuildContext context) {\r\n+    return ;\r\n+  }\r\n }\r\n"
                },
                {
                    "date": 1698502465488,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -196,9 +196,21 @@\n   }\r\n }\r\n \r\n class MouseSingleChildScrollView extends StatelessWidget implements SingleChildScrollView {\r\n-  const MouseSingleChildScrollView({super.key});\r\n+  const MouseSingleChildScrollView({super.key\r\n+    super.key,\r\n+    this.scrollDirection = Axis.vertical,\r\n+    this.reverse = false,\r\n+    this.padding,\r\n+    this.primary,\r\n+    this.physics,\r\n+    this.controller,\r\n+    this.child,\r\n+    this.dragStartBehavior = DragStartBehavior.start,\r\n+    this.clipBehavior = Clip.hardEdge,\r\n+    this.restorationId,\r\n+    this.keyboardDismissBehavior = ScrollViewKeyboardDismissBehavior.manual,});\r\n \r\n   @override\r\n   Widget build(BuildContext context) {\r\n     return;\r\n"
                },
                {
                    "date": 1698502506419,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,294 @@\n+// ignore_for_file: unnecessary_breaks, discarded_futures\r\n+\r\n+import \"dart:math\" as math;\r\n+\r\n+import \"package:flutter/gestures.dart\";\r\n+import \"package:flutter/material.dart\";\r\n+import \"package:provider/provider.dart\";\r\n+\r\n+class MouseScroll extends StatefulWidget {\r\n+  const MouseScroll({\r\n+    required this.builder,\r\n+    this.controller,\r\n+    super.key,\r\n+    this.mobilePhysics = kMobilePhysics,\r\n+    this.duration = const Duration(milliseconds: 380),\r\n+    this.scrollSpeed = 1.0,\r\n+    this.animationCurve = Curves.easeOutQuart,\r\n+  });\r\n+  final ScrollController? controller;\r\n+  final ScrollPhysics mobilePhysics;\r\n+  final Duration duration;\r\n+  final double scrollSpeed;\r\n+  final Curve animationCurve;\r\n+  final Widget Function(BuildContext, ScrollController, ScrollPhysics) builder;\r\n+\r\n+  @override\r\n+  State<MouseScroll> createState() => _MouseScrollState();\r\n+}\r\n+\r\n+class _MouseScrollState extends State<MouseScroll> {\r\n+  late final ScrollController scrollController;\r\n+\r\n+  @override\r\n+  void initState() {\r\n+    super.initState();\r\n+\r\n+    scrollController = widget.controller ?? ScrollController();\r\n+  }\r\n+\r\n+  @override\r\n+  void dispose() {\r\n+    if (widget.controller case null) {\r\n+      scrollController.dispose();\r\n+    }\r\n+\r\n+    super.dispose();\r\n+  }\r\n+\r\n+  @override\r\n+  Widget build(BuildContext context) {\r\n+    return ChangeNotifierProvider<ScrollState>(\r\n+      create: (BuildContext context) => ScrollState(widget.mobilePhysics, scrollController, widget.duration),\r\n+      builder: (BuildContext context, _) {\r\n+        ScrollState scrollState = context.read<ScrollState>();\r\n+        ScrollController controller = scrollState.controller;\r\n+        var (ScrollPhysics physics, _) = context.select((ScrollState s) => (s.activePhysics, s.updateState));\r\n+\r\n+        scrollState.handlePipelinedScroll?.call();\r\n+        return Listener(\r\n+          onPointerSignal: (PointerSignalEvent signalEvent) {\r\n+            scrollState.handleDesktopScroll(signalEvent, widget.scrollSpeed, widget.animationCurve);\r\n+          },\r\n+          onPointerDown: (PointerDownEvent pointerEvent) {\r\n+            scrollState.handleTouchScroll(pointerEvent);\r\n+          },\r\n+          child: widget.builder(context, controller, physics),\r\n+        );\r\n+      },\r\n+    );\r\n+  }\r\n+}\r\n+\r\n+const BouncingScrollPhysics kMobilePhysics = BouncingScrollPhysics();\r\n+const NeverScrollableScrollPhysics kDesktopPhysics = NeverScrollableScrollPhysics();\r\n+\r\n+class ScrollState with ChangeNotifier {\r\n+  ScrollState(this.mobilePhysics, this.controller, this.duration);\r\n+\r\n+  final ScrollPhysics mobilePhysics;\r\n+  final ScrollController controller;\r\n+  final Duration duration;\r\n+\r\n+  late ScrollPhysics activePhysics = mobilePhysics;\r\n+  double _futurePosition = 0;\r\n+  bool updateState = false;\r\n+\r\n+  bool _previousDeltaIsPositive = false;\r\n+  double? _lastLock;\r\n+\r\n+  Future<void>? _animationEnd;\r\n+\r\n+  /// Scroll that is pipelined to be handled after the current render is finished.\r\n+  /// This is used to ensure that the scroll is handled while transitioning from physics.\r\n+  void Function()? handlePipelinedScroll;\r\n+\r\n+  static double calcMaxDelta(ScrollController controller, double delta) {\r\n+    double pixels = controller.position.pixels;\r\n+\r\n+    return delta.sign > 0\r\n+        ? math.min(pixels + delta, controller.position.maxScrollExtent) - pixels\r\n+        : math.max(pixels + delta, controller.position.minScrollExtent) - pixels;\r\n+  }\r\n+\r\n+  void handleDesktopScroll(\r\n+    PointerSignalEvent event,\r\n+    double scrollSpeed,\r\n+    Curve animationCurve, {\r\n+    bool shouldReadLastDirection = true,\r\n+  }) {\r\n+    // Ensure desktop physics is being used.\r\n+    if (activePhysics == kMobilePhysics || _lastLock != null) {\r\n+      if (_lastLock != null) {\r\n+        updateState = !updateState;\r\n+      }\r\n+      if (event case PointerScrollEvent()) {\r\n+        double pixels = controller.position.pixels;\r\n+\r\n+        /// If the scroll is at the top or bottom, don't allow the user to scroll further.\r\n+        if (pixels <= controller.position.minScrollExtent && event.scrollDelta.dy < 0 ||\r\n+            pixels >= controller.position.maxScrollExtent && event.scrollDelta.dy > 0) {\r\n+          return;\r\n+        } else {\r\n+          activePhysics = kDesktopPhysics;\r\n+        }\r\n+\r\n+        double computedDelta = calcMaxDelta(controller, event.scrollDelta.dy);\r\n+        bool isOutOfBounds = pixels < controller.position.minScrollExtent || //\r\n+            pixels > controller.position.maxScrollExtent;\r\n+\r\n+        if (!isOutOfBounds) {\r\n+          controller.jumpTo(_lastLock ?? (pixels - computedDelta));\r\n+        }\r\n+        double deltaDifference = computedDelta - event.scrollDelta.dy;\r\n+        handlePipelinedScroll = () {\r\n+          handlePipelinedScroll = null;\r\n+          double currentPos = controller.position.pixels;\r\n+          double currentDelta = event.scrollDelta.dy;\r\n+          bool shouldLock = _lastLock != null\r\n+              ? (_lastLock == currentPos)\r\n+              : (pixels != currentPos + deltaDifference &&\r\n+                  (currentPos != controller.position.maxScrollExtent || currentDelta < 0) &&\r\n+                  (currentPos != controller.position.minScrollExtent || currentDelta > 0));\r\n+\r\n+          if (!isOutOfBounds && shouldLock) {\r\n+            controller.jumpTo(pixels);\r\n+            _lastLock = pixels;\r\n+            controller.position.moveTo(pixels).whenComplete(() {\r\n+              if (activePhysics == kDesktopPhysics) {\r\n+                activePhysics = kMobilePhysics;\r\n+                notifyListeners();\r\n+              }\r\n+            });\r\n+            return;\r\n+          } else {\r\n+            if (_lastLock != null || isOutOfBounds) {\r\n+              double jumpTarget = _lastLock != null //\r\n+                  ? pixels\r\n+                  : (currentPos - calcMaxDelta(controller, currentDelta));\r\n+\r\n+              controller.jumpTo(jumpTarget);\r\n+            }\r\n+            _lastLock = null;\r\n+            handleDesktopScroll(event, scrollSpeed, animationCurve, shouldReadLastDirection: false);\r\n+          }\r\n+        };\r\n+        notifyListeners();\r\n+      }\r\n+    } else if (event case PointerScrollEvent()) {\r\n+      bool currentDeltaPositive = event.scrollDelta.dy > 0;\r\n+      if (shouldReadLastDirection && currentDeltaPositive == _previousDeltaIsPositive) {\r\n+        _futurePosition += event.scrollDelta.dy * scrollSpeed;\r\n+      } else {\r\n+        _futurePosition = controller.position.pixels + event.scrollDelta.dy * scrollSpeed;\r\n+      }\r\n+      _previousDeltaIsPositive = currentDeltaPositive;\r\n+\r\n+      Future<void> animationEnd = _animationEnd = controller.animateTo(\r\n+        _futurePosition,\r\n+        duration: duration,\r\n+        curve: animationCurve,\r\n+      );\r\n+      animationEnd.whenComplete(() {\r\n+        if (animationEnd == _animationEnd && activePhysics == kDesktopPhysics) {\r\n+          activePhysics = mobilePhysics;\r\n+          notifyListeners();\r\n+        }\r\n+      });\r\n+    }\r\n+  }\r\n+\r\n+  void handleTouchScroll(PointerDownEvent event) {\r\n+    if (activePhysics == kDesktopPhysics) {\r\n+      activePhysics = mobilePhysics;\r\n+      notifyListeners();\r\n+    }\r\n+  }\r\n+}\r\n+\r\n+class MouseSingleChildScrollView extends StatelessWidget implements SingleChildScrollView {\r\n+  const MouseSingleChildScrollView({\r\n+    super.key,\r\n+    this.scrollDirection = Axis.vertical,\r\n+    this.reverse = false,\r\n+    this.padding,\r\n+    this.primary,\r\n+    this.physics,\r\n+    this.controller,\r\n+    this.child,\r\n+    this.dragStartBehavior = DragStartBehavior.start,\r\n+    this.clipBehavior = Clip.hardEdge,\r\n+    this.restorationId,\r\n+    this.keyboardDismissBehavior = ScrollViewKeyboardDismissBehavior.manual,\r\n+  });\r\n+\r\n+  /// {@macro flutter.widgets.scroll_view.scrollDirection}\r\n+  @override\r\n+  final Axis scrollDirection;\r\n+\r\n+  /// Whether the scroll view scrolls in the reading direction.\r\n+  ///\r\n+  /// For example, if the reading direction is left-to-right and\r\n+  /// [scrollDirection] is [Axis.horizontal], then the scroll view scrolls from\r\n+  /// left to right when [reverse] is false and from right to left when\r\n+  /// [reverse] is true.\r\n+  ///\r\n+  /// Similarly, if [scrollDirection] is [Axis.vertical], then the scroll view\r\n+  /// scrolls from top to bottom when [reverse] is false and from bottom to top\r\n+  /// when [reverse] is true.\r\n+  ///\r\n+  /// Defaults to false.\r\n+  @override\r\n+  final bool reverse;\r\n+\r\n+  /// The amount of space by which to inset the child.\r\n+  @override\r\n+  final EdgeInsetsGeometry? padding;\r\n+\r\n+  /// An object that can be used to control the position to which this scroll\r\n+  /// view is scrolled.\r\n+  ///\r\n+  /// Must be null if [primary] is true.\r\n+  ///\r\n+  /// A [ScrollController] serves several purposes. It can be used to control\r\n+  /// the initial scroll position (see [ScrollController.initialScrollOffset]).\r\n+  /// It can be used to control whether the scroll view should automatically\r\n+  /// save and restore its scroll position in the [PageStorage] (see\r\n+  /// [ScrollController.keepScrollOffset]). It can be used to read the current\r\n+  /// scroll position (see [ScrollController.offset]), or change it (see\r\n+  /// [ScrollController.animateTo]).\r\n+  @override\r\n+  final ScrollController? controller;\r\n+\r\n+  /// {@macro flutter.widgets.scroll_view.primary}\r\n+  @override\r\n+  final bool? primary;\r\n+\r\n+  /// How the scroll view should respond to user input.\r\n+  ///\r\n+  /// For example, determines how the scroll view continues to animate after the\r\n+  /// user stops dragging the scroll view.\r\n+  ///\r\n+  /// Defaults to matching platform conventions.\r\n+  @override\r\n+  final ScrollPhysics? physics;\r\n+\r\n+  /// The widget that scrolls.\r\n+  ///\r\n+  /// {@macro flutter.widgets.ProxyWidget.child}\r\n+  @override\r\n+  final Widget? child;\r\n+\r\n+  /// {@macro flutter.widgets.scrollable.dragStartBehavior}\r\n+  @override\r\n+  final DragStartBehavior dragStartBehavior;\r\n+\r\n+  /// {@macro flutter.material.Material.clipBehavior}\r\n+  ///\r\n+  /// Defaults to [Clip.hardEdge].\r\n+  @override\r\n+  final Clip clipBehavior;\r\n+\r\n+  /// {@macro flutter.widgets.scrollable.restorationId}\r\n+  @override\r\n+  final String? restorationId;\r\n+\r\n+  /// {@macro flutter.widgets.scroll_view.keyboardDismissBehavior}\r\n+  @override\r\n+  final ScrollViewKeyboardDismissBehavior keyboardDismissBehavior;\r\n+\r\n+  @override\r\n+  Widget build(BuildContext context) {\r\n+    return;\r\n+  }\r\n+}\r\n"
                }
            ],
            "date": 1698502088090,
            "name": "Commit-0",
            "content": "// ignore_for_file: unnecessary_breaks, discarded_futures\r\n\r\nimport \"dart:math\" as math;\r\n\r\nimport \"package:flutter/gestures.dart\";\r\nimport \"package:flutter/material.dart\";\r\nimport \"package:provider/provider.dart\";\r\n\r\nclass MouseScroll extends StatelessWidget {\r\n  const MouseScroll({\r\n    required this.builder,\r\n    required this.controller,\r\n    super.key,\r\n    this.mobilePhysics = kMobilePhysics,\r\n    this.duration = const Duration(milliseconds: 380),\r\n    this.scrollSpeed = 1.0,\r\n    this.animationCurve = Curves.easeOutQuart,\r\n  });\r\n  final ScrollController controller;\r\n  final ScrollPhysics mobilePhysics;\r\n  final Duration duration;\r\n  final double scrollSpeed;\r\n  final Curve animationCurve;\r\n  final Widget Function(BuildContext, ScrollController, ScrollPhysics) builder;\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    return ChangeNotifierProvider<ScrollState>(\r\n      create: (BuildContext context) => ScrollState(mobilePhysics, controller, duration),\r\n      builder: (BuildContext context, _) {\r\n        ScrollState scrollState = context.read<ScrollState>();\r\n        ScrollController controller = scrollState.controller;\r\n        var (ScrollPhysics physics, _) = context.select((ScrollState s) => (s.activePhysics, s.updateState));\r\n\r\n        scrollState.handlePipelinedScroll?.call();\r\n        return Listener(\r\n          onPointerSignal: (PointerSignalEvent signalEvent) {\r\n            scrollState.handleDesktopScroll(signalEvent, scrollSpeed, animationCurve);\r\n          },\r\n          onPointerDown: (PointerDownEvent pointerEvent) {\r\n            scrollState.handleTouchScroll(pointerEvent);\r\n          },\r\n          child: builder(context, controller, physics),\r\n        );\r\n      },\r\n    );\r\n  }\r\n}\r\n\r\nconst BouncingScrollPhysics kMobilePhysics = BouncingScrollPhysics();\r\nconst NeverScrollableScrollPhysics kDesktopPhysics = NeverScrollableScrollPhysics();\r\n\r\nclass ScrollState with ChangeNotifier {\r\n  ScrollState(this.mobilePhysics, this.controller, this.duration);\r\n\r\n  final ScrollPhysics mobilePhysics;\r\n  final ScrollController controller;\r\n  final Duration duration;\r\n\r\n  late ScrollPhysics activePhysics = mobilePhysics;\r\n  double _futurePosition = 0;\r\n  bool updateState = false;\r\n\r\n  bool _previousDeltaIsPositive = false;\r\n  double? _lastLock;\r\n\r\n  Future<void>? _animationEnd;\r\n\r\n  /// Scroll that is pipelined to be handled after the current render is finished.\r\n  /// This is used to ensure that the scroll is handled while transitioning from physics.\r\n  void Function()? handlePipelinedScroll;\r\n\r\n  static double calcMaxDelta(ScrollController controller, double delta) {\r\n    double pixels = controller.position.pixels;\r\n\r\n    return delta.sign > 0\r\n        ? math.min(pixels + delta, controller.position.maxScrollExtent) - pixels\r\n        : math.max(pixels + delta, controller.position.minScrollExtent) - pixels;\r\n  }\r\n\r\n  void handleDesktopScroll(\r\n    PointerSignalEvent event,\r\n    double scrollSpeed,\r\n    Curve animationCurve, {\r\n    bool shouldReadLastDirection = true,\r\n  }) {\r\n    // Ensure desktop physics is being used.\r\n    if (activePhysics == kMobilePhysics || _lastLock != null) {\r\n      if (_lastLock != null) {\r\n        updateState = !updateState;\r\n      }\r\n      if (event case PointerScrollEvent()) {\r\n        double pixels = controller.position.pixels;\r\n\r\n        /// If the scroll is at the top or bottom, don't allow the user to scroll further.\r\n        if (pixels <= controller.position.minScrollExtent && event.scrollDelta.dy < 0 ||\r\n            pixels >= controller.position.maxScrollExtent && event.scrollDelta.dy > 0) {\r\n          return;\r\n        } else {\r\n          activePhysics = kDesktopPhysics;\r\n        }\r\n\r\n        double computedDelta = calcMaxDelta(controller, event.scrollDelta.dy);\r\n        bool isOutOfBounds = pixels < controller.position.minScrollExtent || //\r\n            pixels > controller.position.maxScrollExtent;\r\n\r\n        if (!isOutOfBounds) {\r\n          controller.jumpTo(_lastLock ?? (pixels - computedDelta));\r\n        }\r\n        double deltaDifference = computedDelta - event.scrollDelta.dy;\r\n        handlePipelinedScroll = () {\r\n          handlePipelinedScroll = null;\r\n          double currentPos = controller.position.pixels;\r\n          double currentDelta = event.scrollDelta.dy;\r\n          bool shouldLock = _lastLock != null\r\n              ? (_lastLock == currentPos)\r\n              : (pixels != currentPos + deltaDifference &&\r\n                  (currentPos != controller.position.maxScrollExtent || currentDelta < 0) &&\r\n                  (currentPos != controller.position.minScrollExtent || currentDelta > 0));\r\n\r\n          if (!isOutOfBounds && shouldLock) {\r\n            controller.jumpTo(pixels);\r\n            _lastLock = pixels;\r\n            controller.position.moveTo(pixels).whenComplete(() {\r\n              if (activePhysics == kDesktopPhysics) {\r\n                activePhysics = kMobilePhysics;\r\n                notifyListeners();\r\n              }\r\n            });\r\n            return;\r\n          } else {\r\n            if (_lastLock != null || isOutOfBounds) {\r\n              double jumpTarget = _lastLock != null //\r\n                  ? pixels\r\n                  : (currentPos - calcMaxDelta(controller, currentDelta));\r\n\r\n              controller.jumpTo(jumpTarget);\r\n            }\r\n            _lastLock = null;\r\n            handleDesktopScroll(event, scrollSpeed, animationCurve, shouldReadLastDirection: false);\r\n          }\r\n        };\r\n        notifyListeners();\r\n      }\r\n    } else if (event case PointerScrollEvent()) {\r\n      bool currentDeltaPositive = event.scrollDelta.dy > 0;\r\n      if (shouldReadLastDirection && currentDeltaPositive == _previousDeltaIsPositive) {\r\n        _futurePosition += event.scrollDelta.dy * scrollSpeed;\r\n      } else {\r\n        _futurePosition = controller.position.pixels + event.scrollDelta.dy * scrollSpeed;\r\n      }\r\n      _previousDeltaIsPositive = currentDeltaPositive;\r\n\r\n      Future<void> animationEnd = _animationEnd = controller.animateTo(\r\n        _futurePosition,\r\n        duration: duration,\r\n        curve: animationCurve,\r\n      );\r\n      animationEnd.whenComplete(() {\r\n        if (animationEnd == _animationEnd && activePhysics == kDesktopPhysics) {\r\n          activePhysics = mobilePhysics;\r\n          notifyListeners();\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  void handleTouchScroll(PointerDownEvent event) {\r\n    if (activePhysics == kDesktopPhysics) {\r\n      activePhysics = mobilePhysics;\r\n      notifyListeners();\r\n    }\r\n  }\r\n}\r\n\r\nclass MiddleClickNotification extends Notification {}\r\n"
        }
    ]
}